import { Injectable, NgModule } from '@angular/core';
import { __awaiter } from 'tslib';
import { OperationStatus, OperationService } from '@c8y/client';
import { gettext, Status, ModalService, AlertService } from '@c8y/ngx-components';
import { pickBy, has, without, difference, keys, assign, includes } from 'lodash-es';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@c8y/client';
import * as ɵngcc2 from '@c8y/ngx-components';
const OPERATION_STATUS_LABELS = {
    PENDING: gettext('Pending'),
    EXECUTING: gettext('Executing'),
    FAILED: gettext('Failed'),
    SUCCESSFUL: gettext('Successful')
};
const OPERATION_STATUS_OPTIONS_MAP = {
    PENDING: {
        label: OPERATION_STATUS_LABELS.PENDING,
        status: OperationStatus.PENDING,
        icon: 'clock-o',
        styleClass: ''
    },
    EXECUTING: {
        label: OPERATION_STATUS_LABELS.EXECUTING,
        status: OperationStatus.EXECUTING,
        icon: 'refresh',
        styleClass: 'text-info'
    },
    SUCCESSFUL: {
        label: OPERATION_STATUS_LABELS.SUCCESSFUL,
        status: OperationStatus.SUCCESSFUL,
        icon: 'check-circle',
        styleClass: 'text-success'
    },
    FAILED: {
        label: OPERATION_STATUS_LABELS.FAILED,
        status: OperationStatus.FAILED,
        icon: 'exclamation-circle',
        styleClass: 'text-danger'
    }
};
const CLEAN_KEYS = ['creationTime', 'deviceExternalIDs', 'id', 'self'];
const CLEAN_KEYS_UPDATE = ['deviceId', 'deviceName', 'bulkOperationId'];
const RESERVED_KEYS = CLEAN_KEYS.concat(['deviceId', 'deviceName', 'bulkOperationId']);
const STANDARD_KEYS = {
    failureReason: gettext('Failure reason'),
    description: gettext('Description'),
    status: gettext('Status')
};

class OperationsService {
    constructor(operationService, modal, alertService) {
        this.operationService = operationService;
        this.modal = modal;
        this.alertService = alertService;
    }
    getStandardKeys(operation) {
        return pickBy(STANDARD_KEYS, (_, key) => has(operation, key));
    }
    getNonStandardKeys(operation, excluding = []) {
        return without(difference(this.getKeys(operation), keys(this.getStandardKeys(operation))), ...excluding);
    }
    cancel(operation) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.modal.confirm(gettext('Cancel operation'), gettext('You are about to cancel the operation. Do you want to proceed?'), Status.DANGER);
                const operationAfterUpdate = (yield this.operationService.update({
                    id: operation.id,
                    status: OperationStatus.FAILED,
                    failureReason: gettext('Operation cancelled by user.')
                })).data;
                assign(operation, operationAfterUpdate);
                this.alertService.success(gettext('Operation cancelled.'));
            }
            catch (er) {
                if (er) {
                    this.alertService.addServerFailure(er);
                }
            }
        });
    }
    getKeys(managedObject) {
        return Object.keys(Object.assign({}, managedObject)).filter(key => !includes(RESERVED_KEYS, key));
    }
}
OperationsService.ɵfac = function OperationsService_Factory(t) { return new (t || OperationsService)(ɵngcc0.ɵɵinject(ɵngcc1.OperationService), ɵngcc0.ɵɵinject(ɵngcc2.ModalService), ɵngcc0.ɵɵinject(ɵngcc2.AlertService)); };
OperationsService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: OperationsService, factory: OperationsService.ɵfac });
OperationsService.ctorParameters = () => [
    { type: OperationService },
    { type: ModalService },
    { type: AlertService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(OperationsService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.OperationService }, { type: ɵngcc2.ModalService }, { type: ɵngcc2.AlertService }]; }, null); })();

class OperationsSharedModule {
}
OperationsSharedModule.ɵfac = function OperationsSharedModule_Factory(t) { return new (t || OperationsSharedModule)(); };
OperationsSharedModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: OperationsSharedModule });
OperationsSharedModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ providers: [OperationsService] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(OperationsSharedModule, [{
        type: NgModule,
        args: [{
                providers: [OperationsService]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { CLEAN_KEYS, CLEAN_KEYS_UPDATE, OPERATION_STATUS_LABELS, OPERATION_STATUS_OPTIONS_MAP, OperationsService, OperationsSharedModule, RESERVED_KEYS, STANDARD_KEYS };

//# sourceMappingURL=c8y-ngx-components-operations-shared.js.map