import { moveItemInArray, DragDropModule } from '@angular/cdk/drag-drop';
import * as i0 from '@angular/core';
import { Injectable, Component, forwardRef, Input, ElementRef, Optional, Output, EventEmitter, ContentChild, Pipe, NgModule } from '@angular/core';
import * as i2 from '@c8y/ngx-components';
import { gettext, C8yValidators, MAX_PAGE_SIZE, AppStateService, ColorService, ListItemDragHandleComponent, CoreModule } from '@c8y/ngx-components';
import { AssetSelectorModule } from '@c8y/ngx-components/assets-navigator';
import { CollapseModule } from 'ngx-bootstrap/collapse';
import { BsDropdownModule } from 'ngx-bootstrap/dropdown';
import * as i1$2 from 'ngx-bootstrap/modal';
import { BsModalRef, BsModalService, ModalModule } from 'ngx-bootstrap/modal';
import { PopoverModule } from 'ngx-bootstrap/popover';
import * as i1 from '@angular/forms';
import { Validators, FormBuilder, NG_VALUE_ACCESSOR, NG_VALIDATORS } from '@angular/forms';
import { map, take, filter, shareReplay, tap, startWith, switchMap, distinctUntilChanged, debounceTime } from 'rxjs/operators';
import { WidgetConfigComponent } from '@c8y/ngx-components/context-dashboard';
import { from, pipe, BehaviorSubject, combineLatest } from 'rxjs';
import { __awaiter } from 'tslib';
import { InventoryService, MeasurementService } from '@c8y/client';
import { sortBy, get, uniq } from 'lodash-es';
import * as i1$1 from '@c8y/client';
import * as i3 from '@c8y/client';

const AXIS_TYPES = [
    { val: undefined, text: gettext('Auto') },
    { val: 'left', text: gettext('Left') },
    { val: 'right', text: gettext('Right') }
];
const CHART_LINE_TYPES = [
    { val: 'line', text: gettext('Line') },
    { val: 'points', text: gettext('Points') },
    { val: 'linePoints', text: gettext('Line and points') },
    { val: 'bars', text: gettext('Bars') },
    { val: 'step-before', text: gettext('Step before') },
    { val: 'step-after', text: gettext('Step after') }
];
const CHART_RENDER_TYPES = [
    { val: 'min', text: gettext('Minimum') },
    { val: 'max', text: gettext('Maximum') },
    { val: 'area', text: gettext('Minimum and maximum') }
];

class DatapointAttributesFormValidationService {
    constructor(formBuilder) {
        this.formBuilder = formBuilder;
    }
    getDefaultFormGroup(fieldsToRemove = []) {
        const formFields = {
            __active: [true, []],
            __target: this.getTargetFormGroup(),
            __template: [undefined, []],
            color: ['', this.getColorValidators()],
            label: ['', this.getLabelValidators()],
            description: ['', this.getDescriptionValidators()],
            fragment: ['', this.getFragmentValidators()],
            series: ['', this.getSeriesValidators()],
            range: this.getMinMaxFormGroup(),
            unit: [undefined, this.getUnitValidators()],
            target: [undefined, this.getTargetValidators()],
            redRange: this.getMinMaxFormGroup(),
            yellowRange: this.getMinMaxFormGroup(),
            chart: this.getChartFormGroup()
        };
        if (fieldsToRemove.length) {
            for (const field of fieldsToRemove) {
                delete formFields[field];
            }
        }
        return this.formBuilder.group(formFields, {
            validators: this.getOverallValidators()
        });
    }
    convertToBackendFormat(formDataStructure) {
        if (!formDataStructure) {
            return {};
        }
        const { __active, __target, __template, color, label, description, fragment, series, range, unit, target, redRange, yellowRange, chart } = formDataStructure;
        const obj = {
            __active,
            __target,
            __template,
            color,
            label,
            description,
            fragment,
            series,
            min: range === null || range === void 0 ? void 0 : range.min,
            max: range === null || range === void 0 ? void 0 : range.max,
            unit,
            target,
            redRangeMin: redRange === null || redRange === void 0 ? void 0 : redRange.min,
            redRangeMax: redRange === null || redRange === void 0 ? void 0 : redRange.max,
            yellowRangeMin: yellowRange === null || yellowRange === void 0 ? void 0 : yellowRange.min,
            yellowRangeMax: yellowRange === null || yellowRange === void 0 ? void 0 : yellowRange.max,
            renderType: chart === null || chart === void 0 ? void 0 : chart.renderType,
            lineType: chart === null || chart === void 0 ? void 0 : chart.lineType,
            yAxisType: chart === null || chart === void 0 ? void 0 : chart.yAxisType
        };
        return obj;
    }
    convertToFormGroupFormat(backendDataStructure) {
        if (!backendDataStructure) {
            return {};
        }
        const { __active, __target, __template, color, label, description, fragment, series, min, max, unit, target, redRangeMin, redRangeMax, yellowRangeMin, yellowRangeMax, renderType, lineType, yAxisType } = backendDataStructure;
        const obj = {
            __active,
            __target,
            __template,
            color,
            label,
            description,
            fragment,
            series,
            range: {
                min: this.convertStringToNumber(min),
                max: this.convertStringToNumber(max)
            },
            unit,
            target: this.convertStringToNumber(target),
            redRange: {
                min: this.convertStringToNumber(redRangeMin),
                max: this.convertStringToNumber(redRangeMax)
            },
            yellowRange: {
                min: this.convertStringToNumber(yellowRangeMin),
                max: this.convertStringToNumber(yellowRangeMax)
            },
            chart: renderType || lineType || yAxisType ? { renderType, lineType, yAxisType } : undefined
        };
        return obj;
    }
    getColorValidators() {
        return [Validators.required, Validators.minLength(4)];
    }
    getLabelValidators() {
        return [Validators.required, Validators.minLength(1), Validators.maxLength(120)];
    }
    getDescriptionValidators() {
        return [];
    }
    getFragmentValidators() {
        return [
            Validators.required,
            Validators.minLength(1),
            Validators.maxLength(120),
            Validators.pattern(/^[^.]*$/)
        ];
    }
    getSeriesValidators() {
        return [
            Validators.required,
            Validators.minLength(1),
            Validators.maxLength(120),
            Validators.pattern(/^[^.]*$/)
        ];
    }
    getMinMaxValidators() {
        return [C8yValidators.minMaxValidator(), C8yValidators.requireBothMinAndMax()];
    }
    getUnitValidators() {
        return [];
    }
    getTargetValidators() {
        return [];
    }
    getOverallValidators() {
        return [
            C8yValidators.withinScale('redRange.min'),
            C8yValidators.withinScale('redRange.max'),
            C8yValidators.withinScale('yellowRange.min'),
            C8yValidators.withinScale('yellowRange.max'),
            C8yValidators.withinScale('target')
        ];
    }
    getMinMaxFormGroup() {
        return this.formBuilder.group({ min: [undefined, []], max: [undefined, []] }, { validators: this.getMinMaxValidators() });
    }
    getChartFormGroup() {
        return this.formBuilder.group({
            renderType: [CHART_RENDER_TYPES[0].val, []],
            lineType: [CHART_LINE_TYPES[0].val, []],
            yAxisType: [AXIS_TYPES[0].val, []]
        });
    }
    getTargetFormGroup() {
        return this.formBuilder.group({
            id: [undefined, []],
            name: [undefined, []]
        });
    }
    convertStringToNumber(possibleString) {
        if (typeof possibleString === 'string') {
            try {
                return Number.parseFloat(possibleString);
            }
            catch (_a) {
                return undefined;
            }
        }
        else {
            return possibleString;
        }
    }
}
DatapointAttributesFormValidationService.ɵprov = i0.ɵɵdefineInjectable({ factory: function DatapointAttributesFormValidationService_Factory() { return new DatapointAttributesFormValidationService(i0.ɵɵinject(i1.FormBuilder)); }, token: DatapointAttributesFormValidationService, providedIn: "root" });
DatapointAttributesFormValidationService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
DatapointAttributesFormValidationService.ctorParameters = () => [
    { type: FormBuilder }
];

class DatapointAttributesFormComponent {
    constructor(formValidations) {
        this.formValidations = formValidations;
        this.showTarget = true;
        this.showRange = true;
        this.showYellowRange = true;
        this.showRedRange = true;
        this.showChart = true;
        this.showFormIfTemplateWasSelected = false;
        this.rawValue = {};
        this.CHART_RENDER_TYPES = CHART_RENDER_TYPES;
        this.CHART_LINE_TYPES = CHART_LINE_TYPES;
        this.AXIS_TYPES = AXIS_TYPES;
        this.customValidationErrorMessages = {};
        this.formGroup = this.formValidations.getDefaultFormGroup();
        this.setSubForms();
    }
    validate(control) {
        var _a;
        return ((_a = this.formGroup) === null || _a === void 0 ? void 0 : _a.valid) ? null : { formInvalid: {} };
    }
    writeValue(obj) {
        this.rawValue = obj || {};
        if (obj) {
            this.formGroup.patchValue(this.formValidations.convertToFormGroupFormat(obj), {
                emitEvent: false
            });
        }
    }
    registerOnChange(fn) {
        this.formGroup.valueChanges
            .pipe(map(this.formValidations.convertToBackendFormat), map(formValue => Object.assign(this.rawValue, formValue)))
            .subscribe(fn);
    }
    registerOnTouched(fn) {
        this.formGroup.valueChanges.pipe(take(1)).subscribe(fn);
    }
    setDisabledState(isDisabled) {
        isDisabled ? this.formGroup.disable() : this.formGroup.enable();
    }
    setSubForms() {
        if (!this.formGroup) {
            this.range = this.yellowRange = this.redRange = this.chart = undefined;
            return;
        }
        this.range = this.formGroup.get('range');
        this.yellowRange = this.formGroup.get('yellowRange');
        this.redRange = this.formGroup.get('redRange');
        this.chart = this.formGroup.get('chart');
    }
}
DatapointAttributesFormComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-datapoint-attributes-form',
                template: "<div [formGroup]=\"formGroup\" *ngIf=\"!rawValue?.__template || showFormIfTemplateWasSelected\">\n  <fieldset class=\"c8y-fieldset\" *ngIf=\"formGroup.controls?.label || formGroup.controls?.unit || formGroup.controls?.target\">\n    <legend translate>Details</legend>\n    <div class=\"row\">\n      <div class=\"col-md-6\" *ngIf=\"formGroup.controls?.label\">\n        <c8y-form-group>\n          <label translate>Label</label>\n          <input\n            class=\"form-control\"\n            name=\"label\"\n            formControlName=\"label\"\n            [placeholder]=\"'e.g. {{ example }}' | translate: { example: 'Temperature' }\"\n          />\n          <c8y-messages [show]=\"formGroup.controls.label.touched && formGroup.controls.label.errors\">\n            <c8y-message\n              *ngFor=\"let item of customValidationErrorMessages['label'] | keyvalue\"\n              [name]=\"item.key\"\n              [text]=\"item.value\"\n            ></c8y-message>\n          </c8y-messages>\n        </c8y-form-group>\n      </div>\n\n      <div class=\"col-md-6\" *ngIf=\"formGroup.controls?.unit\">\n        <c8y-form-group>\n          <label translate>Unit</label>\n          <input\n            class=\"form-control\"\n            name=\"unit\"\n            formControlName=\"unit\"\n            [placeholder]=\"'e.g. {{ example }}' | translate: { example: '\u00BAC' }\"\n          />\n          <c8y-messages [show]=\"formGroup.controls.unit.touched && formGroup.controls.unit.errors\">\n            <c8y-message\n              *ngFor=\"let item of customValidationErrorMessages['unit'] | keyvalue\"\n              [name]=\"item.key\"\n              [text]=\"item.value\"\n            ></c8y-message>\n          </c8y-messages>\n        </c8y-form-group>\n      </div>\n\n      <div class=\"col-md-6\" *ngIf=\"formGroup.controls?.target && showTarget\">\n        <c8y-form-group\n          [ngClass]=\"{\n            'has-error':\n              (range?.touched || formGroup.controls.target.touched) &&\n              formGroup.controls?.target?.errors\n          }\"\n        >\n          <label translate>Target</label>\n          <input\n            type=\"number\"\n            class=\"form-control\"\n            name=\"target\"\n            formControlName=\"target\"\n            [placeholder]=\"'e.g. {{ example }}' | translate: { example: 25 }\"\n          />\n          <c8y-messages\n            [show]=\"\n              (range?.touched || formGroup.controls.target.touched) &&\n              formGroup.controls.target.errors\n            \"\n          >\n            <c8y-message\n              *ngFor=\"let item of customValidationErrorMessages['target'] | keyvalue\"\n              [name]=\"item.key\"\n              [text]=\"item.value\"\n            ></c8y-message>\n          </c8y-messages>\n        </c8y-form-group>\n      </div>\n    </div>\n  </fieldset>\n  <fieldset class=\"c8y-fieldset\" *ngIf=\"range && showRange\">\n    <legend translate>Range</legend>\n    <div class=\"row\" formGroupName=\"range\">\n      <div class=\"col-md-6\">\n        <c8y-form-group [ngClass]=\"{ 'has-error': range?.touched && range?.controls?.min?.errors }\">\n          <label translate>Min</label>\n          <input\n            type=\"number\"\n            class=\"form-control\"\n            name=\"min\"\n            formControlName=\"min\"\n            [placeholder]=\"'e.g. {{ example }}' | translate: { example: 0 }\"\n          />\n          <c8y-messages [show]=\"range?.touched && range.controls?.min?.errors\"> </c8y-messages>\n        </c8y-form-group>\n      </div>\n      <div class=\"col-md-6\">\n        <c8y-form-group [ngClass]=\"{ 'has-error': range?.touched && range?.controls?.max?.errors }\">\n          <label translate>Max</label>\n          <input\n            type=\"number\"\n            class=\"form-control\"\n            name=\"max\"\n            formControlName=\"max\"\n            [placeholder]=\"'e.g. {{ example }}' | translate: { example: 100 }\"\n          />\n          <c8y-messages [show]=\"range?.touched && range.controls?.max?.errors\">\n            <c8y-message\n              *ngFor=\"let item of customValidationErrorMessages['max'] | keyvalue\"\n              [name]=\"item.key\"\n              [text]=\"item.value\"\n            ></c8y-message>\n          </c8y-messages>\n        </c8y-form-group>\n      </div>\n    </div>\n  </fieldset>\n\n  <fieldset class=\"c8y-fieldset\" formGroupName=\"yellowRange\" *ngIf=\"yellowRange && showYellowRange\">\n    <legend translate>Yellow range</legend>\n    <div class=\"row\">\n      <div class=\"col-md-6\">\n        <c8y-form-group\n          [ngClass]=\"{\n            'has-error':\n              (range?.touched || yellowRange?.touched) && yellowRange?.controls?.min?.errors\n          }\"\n        >\n          <label translate>Min</label>\n          <input\n            type=\"number\"\n            class=\"form-control\"\n            name=\"min\"\n            formControlName=\"min\"\n            [placeholder]=\"'e.g. {{ example }}' | translate: { example: 50 }\"\n          />\n          <c8y-messages\n            [show]=\"(range?.touched || yellowRange?.touched) && yellowRange.controls?.min?.errors\"\n          >\n          </c8y-messages>\n        </c8y-form-group>\n      </div>\n\n      <div class=\"col-md-6\">\n        <c8y-form-group\n          [ngClass]=\"{\n            'has-error':\n              (range?.touched || yellowRange?.touched) && yellowRange?.controls?.max?.errors\n          }\"\n        >\n          <label translate>Max</label>\n          <input\n            type=\"number\"\n            class=\"form-control\"\n            name=\"max\"\n            formControlName=\"max\"\n            [placeholder]=\"'e.g. {{ example }}' | translate: { example: 75 }\"\n          />\n          <c8y-messages\n            [show]=\"(range?.touched || yellowRange?.touched) && yellowRange.controls?.max?.errors\"\n          >\n          </c8y-messages>\n        </c8y-form-group>\n      </div>\n    </div>\n  </fieldset>\n\n  <fieldset class=\"c8y-fieldset\" formGroupName=\"redRange\" *ngIf=\"redRange && showRedRange\">\n    <legend translate>Red range</legend>\n    <div class=\"row\">\n      <div class=\"col-md-6\">\n        <c8y-form-group\n          [ngClass]=\"{\n            'has-error': (range?.touched || redRange?.touched) && redRange?.controls?.min?.errors\n          }\"\n        >\n          <label translate>Min</label>\n          <input\n            type=\"number\"\n            class=\"form-control\"\n            name=\"min\"\n            formControlName=\"min\"\n            [placeholder]=\"'e.g. {{ example }}' | translate: { example: 75 }\"\n          />\n          <c8y-messages\n            [show]=\"(range?.touched || redRange?.touched) && redRange.controls?.min?.errors\"\n          >\n          </c8y-messages>\n        </c8y-form-group>\n      </div>\n\n      <div class=\"col-md-6\">\n        <c8y-form-group\n          [ngClass]=\"{\n            'has-error': (range?.touched || redRange?.touched) && redRange?.controls?.max?.errors\n          }\"\n        >\n          <label translate>Max</label>\n          <input\n            type=\"number\"\n            class=\"form-control\"\n            name=\"max\"\n            formControlName=\"max\"\n            [placeholder]=\"'e.g. {{ example }}' | translate: { example: 100 }\"\n          />\n          <c8y-messages\n            [show]=\"(range?.touched || redRange?.touched) && redRange.controls?.max?.errors\"\n          >\n          </c8y-messages>\n        </c8y-form-group>\n      </div>\n    </div>\n  </fieldset>\n\n  <fieldset class=\"c8y-fieldset\" *ngIf=\"chart && showChart\" formGroupName=\"chart\">\n    <legend translate>Chart</legend>\n    <div class=\"tight-grid\">\n      <div class=\"col-xs-6 col-sm-4\">\n        <c8y-form-group>\n          <label for=\"display\">\n            {{ 'Display' | translate }}\n            <button\n              class=\"btn-clean text-info\"\n              popover=\"{{ 'Value displayed when data is aggregated' | translate }}\"\n              [placement]=\"'right'\"\n              [triggers]=\"'focus'\"\n              [container]=\"'body'\"\n            >\n              <i c8yIcon=\"question-circle-o\"></i>\n            </button>\n          </label>\n          <div class=\"c8y-select-wrapper\">\n            <select class=\"form-control\" formControlName=\"renderType\">\n              <option *ngFor=\"let type of CHART_RENDER_TYPES\" [ngValue]=\"type.val\">\n                {{ type.text | translate }}\n              </option>\n            </select>\n          </div>\n        </c8y-form-group>\n      </div>\n      <div class=\"col-xs-6 col-sm-4\">\n        <c8y-form-group>\n          <label for=\"chartType\" translate>Chart type</label>\n          <div class=\"c8y-select-wrapper\">\n            <select class=\"form-control\" formControlName=\"lineType\">\n              <option *ngFor=\"let type of CHART_LINE_TYPES\" [ngValue]=\"type.val\">\n                {{ type.text | translate }}\n              </option>\n            </select>\n            <span></span>\n          </div>\n        </c8y-form-group>\n      </div>\n      <div class=\"col-xs-6 col-sm-4\">\n        <c8y-form-group>\n          <label for=\"yAxis\" translate>Y Axis</label>\n          <div class=\"c8y-select-wrapper\">\n            <select class=\"form-control\" formControlName=\"yAxisType\">\n              <option *ngFor=\"let type of AXIS_TYPES\" [ngValue]=\"type.val\">\n                {{ type.text | translate }}\n              </option>\n            </select>\n            <span></span>\n          </div>\n        </c8y-form-group>\n      </div>\n    </div>\n  </fieldset>\n</div>\n",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => DatapointAttributesFormComponent),
                        multi: true
                    },
                    {
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef(() => DatapointAttributesFormComponent),
                        multi: true
                    }
                ]
            },] }
];
DatapointAttributesFormComponent.ctorParameters = () => [
    { type: DatapointAttributesFormValidationService }
];
DatapointAttributesFormComponent.propDecorators = {
    showTarget: [{ type: Input }],
    showRange: [{ type: Input }],
    showYellowRange: [{ type: Input }],
    showRedRange: [{ type: Input }],
    showChart: [{ type: Input }],
    showFormIfTemplateWasSelected: [{ type: Input }]
};

const DATAPOINT_LIBRARY_FRAGMENT = 'c8y_Kpi';

class DatapointLibraryService {
    constructor(inventory, appState, measurements, color) {
        this.inventory = inventory;
        this.appState = appState;
        this.measurements = measurements;
        this.color = color;
        this.appState.currentUser.pipe(filter(user => !user)).subscribe(() => {
            this.cache = undefined;
        });
    }
    getAllDatapointLibraryEntriesCached(forceCacheRenew = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (forceCacheRenew) {
                this.cache = undefined;
            }
            if (!this.cache) {
                this.cache = this.getAllDatapointLibraryEntries();
            }
            return this.cache;
        });
    }
    getFirstDatapointLibraryPage() {
        return __awaiter(this, void 0, void 0, function* () {
            const filterObj = {
                currentPage: 1,
                pageSize: 50,
                fragmentType: DATAPOINT_LIBRARY_FRAGMENT,
                withTotalPages: true
            };
            return (yield this.inventory.list(filterObj));
        });
    }
    getAllDatapointLibraryItemsCached() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.cache) {
                this.cache = this.getAllDatapointLibraryEntries();
            }
            const res = yield this.cache;
            return res.map(tmp => tmp[DATAPOINT_LIBRARY_FRAGMENT]);
        });
    }
    updateDatapoints(datapoints, skipUpdatingTarget = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!Array.isArray(datapoints)) {
                return datapoints;
            }
            const currentTargetsPromise = !skipUpdatingTarget ? this.getCurrentVersionOfTargetsFromDatapoints(datapoints) : Promise.resolve([]);
            const [currentTemplates, currentTargets] = yield Promise.all([
                this.getCurrentTemplatesFromDatapoints(datapoints),
                currentTargetsPromise
            ]);
            const currentTemplateVersions = currentTemplates
                .map(tmp => this.mapDatapointLibraryEntry(tmp))
                .filter(tmp => !!tmp);
            for (const datapoint of datapoints) {
                const { fragment, series, __active, __target, color, label, __template } = datapoint;
                const foundCurrentTemplateVersion = currentTemplateVersions.find(tmp => tmp.__template === datapoint.__template);
                if (foundCurrentTemplateVersion) {
                    Object.assign(datapoint, foundCurrentTemplateVersion);
                    Object.assign(datapoint, {
                        fragment,
                        series,
                        __active,
                        __target,
                        color,
                        label,
                        __template
                    });
                }
                const foundCurrentTarget = currentTargets.find(target => target.id === (__target === null || __target === void 0 ? void 0 : __target.id));
                if (foundCurrentTarget) {
                    const { id, name } = foundCurrentTarget;
                    datapoint.__target = { id, name };
                }
            }
            return datapoints;
        });
    }
    getDatapointsOfAsset(parentReference, ignoreDatapointTemplates) {
        return __awaiter(this, void 0, void 0, function* () {
            const [kpiResponse, details] = yield Promise.all([
                (ignoreDatapointTemplates
                    ? Promise.resolve(null)
                    : this.inventory.assetKPIsList(parentReference, { pageSize: MAX_PAGE_SIZE })),
                this.inventory.getMeasurementsAndSeries(parentReference)
            ]);
            const kpis = kpiResponse && kpiResponse.data ? kpiResponse.data : [];
            const sortedDetails = sortBy(details, ['fragment', 'series']);
            return yield this.combineFragmentSeriesTuplesWithDetails(sortedDetails, parentReference, kpis);
        });
    }
    /**
     * Requests the last measurement with the given fragment and series to extract it's unit.
     * If the source attribute is provided, it will check the last measurement for this specific source.
     * @returns found unit or an empty string instead
     */
    guessUnitOfDatapoint(fragment, series, source) {
        return __awaiter(this, void 0, void 0, function* () {
            const measurementfilter = {
                valueFragmentSeries: series,
                valueFragmentType: fragment,
                pageSize: 1,
                revert: true,
                dateFrom: '1970-01-01'
            };
            if (source === null || source === void 0 ? void 0 : source.id) {
                measurementfilter.source = source === null || source === void 0 ? void 0 : source.id;
            }
            try {
                const { data: lastMeasurements } = yield this.measurements.list(measurementfilter);
                const measurement = lastMeasurements[0];
                if (measurement) {
                    const pathToUnit = `${fragment}.${series}.unit`;
                    const unit = get(measurement, pathToUnit);
                    if ((unit === null || unit === void 0 ? void 0 : unit.length) && typeof unit === 'string') {
                        return unit;
                    }
                }
            }
            catch (_a) {
                // nothing to do
            }
            return '';
        });
    }
    combineFragmentSeriesTuplesWithDetails(tuples, target, kpis) {
        return __awaiter(this, void 0, void 0, function* () {
            const datapoints = tuples.map(tuple => {
                var _a;
                const foundDatapointLibraryEntry = kpis.find(kpi => kpi[DATAPOINT_LIBRARY_FRAGMENT] &&
                    kpi[DATAPOINT_LIBRARY_FRAGMENT].fragment === tuple.fragment &&
                    kpi[DATAPOINT_LIBRARY_FRAGMENT].series === tuple.series);
                const datapoint = this.mapDatapointLibraryEntry(foundDatapointLibraryEntry) || tuple;
                if (!datapoint.label) {
                    datapoint.label = `${datapoint.fragment} → ${datapoint.series}`;
                }
                if (!((_a = datapoint.unit) === null || _a === void 0 ? void 0 : _a.length)) {
                    datapoint.unit = '';
                }
                datapoint.__target = target;
                return datapoint;
            });
            yield this.assignColorToDatapoints(datapoints);
            return datapoints;
        });
    }
    assignColorToDatapoints(datapoints) {
        return __awaiter(this, void 0, void 0, function* () {
            const datapointsWithoutColor = datapoints.filter(datapoint => !datapoint.color);
            yield Promise.all(datapointsWithoutColor.map(datapoint => this.color.generateColorForDatapoint(datapoint.fragment, datapoint.series).then(color => (datapoint.color = color))));
        });
    }
    getAllDatapointLibraryEntries() {
        return __awaiter(this, void 0, void 0, function* () {
            const entries = new Array();
            const filterObj = {
                currentPage: 1,
                pageSize: MAX_PAGE_SIZE,
                fragmentType: DATAPOINT_LIBRARY_FRAGMENT
            };
            let res = yield this.inventory.list(filterObj);
            while (res.data.length) {
                entries.push(...res.data);
                if (res.data.length < res.paging.pageSize) {
                    break;
                }
                res = yield res.paging.next();
            }
            return entries;
        });
    }
    mapDatapointLibraryEntry(entry) {
        if (!entry || !entry[DATAPOINT_LIBRARY_FRAGMENT]) {
            return null;
        }
        const datapoint = entry[DATAPOINT_LIBRARY_FRAGMENT];
        datapoint.__template = entry.id;
        return datapoint;
    }
    getCurrentTemplatesFromDatapoints(datapoints) {
        return __awaiter(this, void 0, void 0, function* () {
            const datapointsWithTemplateId = datapoints.filter(dp => !!dp.__template);
            const usedTemplateIds = datapointsWithTemplateId.map(dp => dp.__template);
            return yield this.getMOsByIds(usedTemplateIds);
        });
    }
    getCurrentVersionOfTargetsFromDatapoints(datapoints) {
        return __awaiter(this, void 0, void 0, function* () {
            const datapointsWithTarget = datapoints.filter(dp => { var _a; return !!((_a = dp.__target) === null || _a === void 0 ? void 0 : _a.id); });
            const usedTargetIds = datapointsWithTarget.map(dp => dp.__target.id);
            return yield this.getMOsByIds(usedTargetIds);
        });
    }
    getMOsByIds(ids) {
        return __awaiter(this, void 0, void 0, function* () {
            const uniqManagedObjectIds = uniq(ids);
            if (!uniqManagedObjectIds.length) {
                return [];
            }
            try {
                const { data: managedObjects } = yield this.inventory.list({
                    ids: uniqManagedObjectIds.join(),
                    pageSize: MAX_PAGE_SIZE
                });
                return managedObjects;
            }
            catch (_a) {
                // Fail silently in case we are not able to talk to the inventory API.
                // Should only be reached in case of an server side error.
                // instead of failing, pretend like we didn't receive any items.
                console.warn(`Failed to get the current version of the following managedObjects: ${uniqManagedObjectIds.join()}.`);
                return [];
            }
        });
    }
}
DatapointLibraryService.ɵprov = i0.ɵɵdefineInjectable({ factory: function DatapointLibraryService_Factory() { return new DatapointLibraryService(i0.ɵɵinject(i1$1.InventoryService), i0.ɵɵinject(i2.AppStateService), i0.ɵɵinject(i3.MeasurementService), i0.ɵɵinject(i2.ColorService)); }, token: DatapointLibraryService, providedIn: "root" });
DatapointLibraryService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
DatapointLibraryService.ctorParameters = () => [
    { type: InventoryService },
    { type: AppStateService },
    { type: MeasurementService },
    { type: ColorService }
];

class DatapointSelectorModalComponent {
    constructor(bsModal, elementRef) {
        this.bsModal = bsModal;
        this.elementRef = elementRef;
        this.allowChangingContext = true;
        this.allowSearch = true;
        this.allowDatapointsFromMultipleAssets = true;
        this.selectedDatapoints = new Array();
        this.title = gettext('Data point selector');
        this.saveButtonLabel = gettext('Add data points');
        this.guessDatapointUnit = true;
        this.defaultActiveState = true;
        this.assetSelectorConfig = {};
        this.result = new Promise((resolve, reject) => {
            this.save = resolve;
            this.cancel = reject;
        });
    }
    ngOnInit() {
        this.applyWorkaroundForAngularJSModalsThatMightBeOpenedInParallel();
    }
    saveChanges() {
        this.bsModal.hide();
        this.save(this.selectedDatapoints);
    }
    close() {
        this.bsModal.hide();
        this.cancel();
    }
    /**
     * changes the z-index of the modal, to make sure this modal is on top.
     * required as angularJS modals are placing them selves on top via adjusting z-index.
     * while angular modals use the order within the dom for this..
     */
    applyWorkaroundForAngularJSModalsThatMightBeOpenedInParallel() {
        const modalContainer = get(this.elementRef, 'nativeElement.parentElement.parentElement.parentElement');
        modalContainer.style.zIndex = '1060';
    }
}
DatapointSelectorModalComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-datapoint-selector-modal',
                template: "<div class=\"modal-header separator\">\n  <h4 class=\"text-medium\">{{ title | translate }}</h4>\n</div>\n<div class=\"modal-inner-scroll modal-inner-scroll--fixed\">\n  <c8y-datapoint-selector\n    [contextAsset]=\"contextAsset\"\n    [guessDatapointUnit]=\"guessDatapointUnit\"\n    [allowDatapointsFromMultipleAssets]=\"allowDatapointsFromMultipleAssets\"\n    [allowChangingContext]=\"allowChangingContext\"\n    [defaultActiveState]=\"defaultActiveState\"\n    [allowSearch]=\"allowSearch\"\n    [(ngModel)]=\"selectedDatapoints\"\n  ></c8y-datapoint-selector>\n</div>\n<div class=\"modal-footer\">\n  <button\n    type=\"button\"\n    [title]=\"'Cancel' | translate\"\n    class=\"btn btn-default\"\n    (click)=\"close()\"\n    translate\n  >\n    Cancel\n  </button>\n  <button\n    [title]=\"saveButtonLabel | translate\"\n    class=\"btn btn-primary\"\n    [disabled]=\"!this.selectedDatapoints?.length\"\n    (click)=\"saveChanges()\"\n  >\n    {{ saveButtonLabel | translate }}\n  </button>\n</div>\n"
            },] }
];
DatapointSelectorModalComponent.ctorParameters = () => [
    { type: BsModalRef },
    { type: ElementRef }
];

class DatapointSelectorService {
    constructor(modal) {
        this.modal = modal;
    }
    selectDataPoints(initialState = {}) {
        const modal = this.modal.show(DatapointSelectorModalComponent, {
            ignoreBackdropClick: true,
            keyboard: false,
            initialState,
            class: 'modal-lg'
        });
        const content = modal.content;
        return content.result;
    }
}
DatapointSelectorService.ɵprov = i0.ɵɵdefineInjectable({ factory: function DatapointSelectorService_Factory() { return new DatapointSelectorService(i0.ɵɵinject(i1$2.BsModalService)); }, token: DatapointSelectorService, providedIn: "root" });
DatapointSelectorService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
DatapointSelectorService.ctorParameters = () => [
    { type: BsModalService }
];

class DatapointSelectionListComponent {
    constructor(datapointSelector, datapointLibrary, formBuilder, widgetComponent) {
        this.datapointSelector = datapointSelector;
        this.datapointLibrary = datapointLibrary;
        this.formBuilder = formBuilder;
        this.widgetComponent = widgetComponent;
        this.actions = [];
        this.allowDragAndDrop = true;
        this.config = {};
        this.defaultFormOptions = {};
        this.minActiveCount = 1;
        this.resolveContext = true;
        this.maxActiveCountReached = false;
        this.usedValidators = {};
        this.formArray = this.formBuilder.array([]);
        this.isValid = this.formArray.statusChanges.pipe(map(status => status === 'VALID'));
        this.datapointLibraryEntries = from(this.datapointLibrary.getFirstDatapointLibraryPage()).pipe(shareReplay());
        this.change = this.formArray.valueChanges.pipe(map(res => this.transformValue(res)));
    }
    ngOnChanges(changes) {
        if (!changes.maxActiveCount && !changes.minActiveCount) {
            return;
        }
        if (changes.maxActiveCount) {
            this.usedValidators.maxActiveCount = C8yValidators.maxActiveCount(this.maxActiveCount);
        }
        if (changes.minActiveCount) {
            this.usedValidators.minActiveCount = C8yValidators.minActiveCount(this.minActiveCount);
        }
        const validators = Object.values(this.usedValidators);
        this.formArray.setValidators(validators);
    }
    registerOnTouched(fn) {
        this.formArray.valueChanges.pipe(take(1)).subscribe(fn);
    }
    validate(control) {
        return this.formArray.valid ? null : { formInvalid: {} };
    }
    ngOnInit() {
        var _a;
        const context = (_a = this.widgetComponent) === null || _a === void 0 ? void 0 : _a.context;
        if ((context === null || context === void 0 ? void 0 : context.id) && this.resolveContext) {
            const { name, id, c8y_IsDevice } = context;
            this.config.contextAsset = { name, id, c8y_IsDevice };
        }
    }
    writeValue(obj) {
        this.formArray.clear();
        if (obj === null || obj === void 0 ? void 0 : obj.length) {
            obj.forEach(val => {
                const formgroup = this.formBuilder.group({ details: [] });
                formgroup.patchValue({ details: val });
                this.formArray.push(formgroup);
            });
        }
        this.calculateMaxActiveCount();
    }
    registerOnChange(fn) {
        this.formArray.valueChanges
            .pipe(map(res => this.transformValue(res)), 
        // check maxActiveCount
        tap(res => {
            this.calculateMaxActiveCount();
        }))
            .subscribe(fn);
    }
    add() {
        var _a, _b, _c;
        const allowChangingContext = !((_a = this.widgetComponent) === null || _a === void 0 ? void 0 : _a.isDeviceTypeDashboard) && ((_b = this.config) === null || _b === void 0 ? void 0 : _b.allowChangingContext) !== false;
        this.datapointSelector
            .selectDataPoints(Object.assign(Object.assign({}, (this.config || {})), { selectedDatapoints: this.transformValue(this.formArray.value), defaultActiveState: true, allowChangingContext, allowSearch: !((_c = this.config) === null || _c === void 0 ? void 0 : _c.contextAsset) }))
            .then(result => {
            this.writeValue(result);
        }, error => {
            // nothing to do, modal was closed
        });
    }
    onItemRemoved(index) {
        this.formArray.removeAt(index);
    }
    drop(event) {
        const currentSorting = this.formArray.value;
        moveItemInArray(currentSorting, event.previousIndex, event.currentIndex);
        this.formArray.setValue(currentSorting);
    }
    transformValue(formArrayValue) {
        if (!formArrayValue) {
            return [];
        }
        return formArrayValue.map(tmp => Object.assign({}, ...Object.values(tmp)));
    }
    calculateMaxActiveCount() {
        if (this.maxActiveCount) {
            const currentlyActive = this.formArray.value.filter(tmp => { var _a; return (_a = tmp.details) === null || _a === void 0 ? void 0 : _a.__active; }).length;
            this.maxActiveCountReached = currentlyActive >= this.maxActiveCount;
        }
        this.maxActiveCountReached = false;
    }
}
DatapointSelectionListComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-datapoint-selection-list',
                template: "<div class=\"card-header separator sticky-top bg-component\">\n  <span class=\"card-title h4\" translate>Data points</span>\n</div>\n\n<c8y-list-group\n  class=\"flex-grow ff-scroll-fix cdk-droplist\"\n  cdkDropList\n  (cdkDropListDropped)=\"drop($event)\"\n  [cdkDropListDisabled]=\"!allowDragAndDrop || formArray.controls?.length < 2\"\n>\n  <div\n    class=\"alert alert-info\"\n    role=\"alert\"\n    ngNonBindable\n    *ngIf=\"formArray.errors?.minActiveCount\"\n    translate\n    [translateParams]=\"formArray.errors?.minActiveCount\"\n  >\n    At least {{ minActive }} active data points must be selected.\n  </div>\n\n  <div\n    class=\"alert alert-info\"\n    role=\"alert\"\n    ngNonBindable\n    *ngIf=\"formArray.errors?.maxActiveCount\"\n    translate\n    [translateParams]=\"formArray.errors?.maxActiveCount\"\n  >\n    At maximum {{ maxActive }} active data points are allowed to be selected.\n  </div>\n\n  <ng-content select=\".alert\"></ng-content>\n\n  <div class=\"c8y-empty-state\" *ngIf=\"!formArray.controls?.length\">\n    <h1 class=\"c8y-icon c8y-icon-data-points c8y-icon-duocolor\"></h1>\n    <div>\n      <p>\n        <strong translate>No data points to display.</strong>\n      </p>\n      <small translate>Add your first data point.</small>\n    </div>\n  </div>\n  <div [formGroup]=\"dpForm\" *ngFor=\"let dpForm of formArray.controls; let index = index\">\n    <c8y-datapoint-selector-list-item\n      class=\"d-block\"\n      [defaultFormOptions]=\"defaultFormOptions\"\n      [activeToggleDisabled]=\"maxActiveCountReached\"\n      [showActiveToggle]=\"true\"\n      [showAddRemoveButton]=\"false\"\n      [showOptions]=\"true\"\n      [editable]=\"true\"\n      [colorPickerDisabled]=\"false\"\n      [actions]=\"actions\"\n      [optionToRemove]=\"true\"\n      [datapointLibraryEntries]=\"datapointLibraryEntries\"\n      [hasUnlinkTemplateOption]=\"true\"\n      formControlName=\"details\"\n      (removed)=\"onItemRemoved(index)\"\n      cdkDrag\n    >\n      <c8y-li-drag-handle cdkDragHandle>\n        <i c8yIcon=\"drag-reorder\"></i>\n      </c8y-li-drag-handle>\n    </c8y-datapoint-selector-list-item>\n  </div>\n</c8y-list-group>\n\n<div class=\"card-footer bg-component sticky-bottom separator\">\n  <button [title]=\"'Add data point' | translate\" class=\"btn btn-default btn-sm\" (click)=\"add()\">\n    <i c8yIcon=\"plus-circle\"></i>\n    <span translate>Add data point</span>\n  </button>\n</div>\n",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        multi: true,
                        useExisting: forwardRef(() => DatapointSelectionListComponent)
                    },
                    {
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef(() => DatapointSelectionListComponent),
                        multi: true
                    }
                ]
            },] }
];
DatapointSelectionListComponent.ctorParameters = () => [
    { type: DatapointSelectorService },
    { type: DatapointLibraryService },
    { type: FormBuilder },
    { type: WidgetConfigComponent, decorators: [{ type: Optional }] }
];
DatapointSelectionListComponent.propDecorators = {
    actions: [{ type: Input }],
    allowDragAndDrop: [{ type: Input }],
    config: [{ type: Input }],
    defaultFormOptions: [{ type: Input }],
    maxActiveCount: [{ type: Input }],
    minActiveCount: [{ type: Input }],
    resolveContext: [{ type: Input }],
    isValid: [{ type: Output }],
    change: [{ type: Output }]
};

class DatapointSelectorListItemComponent {
    constructor(formBuilder) {
        this.formBuilder = formBuilder;
        this.defaultFormOptions = {};
        this.isSelected = false;
        this.isCollapsed = true;
        this.showAddRemoveButton = true;
        this.editable = true;
        this.showActiveToggle = false;
        this.activeToggleDisabled = false;
        this.showOptions = false;
        this.actions = [];
        this.optionToRemove = false;
        this.hasUnlinkTemplateOption = false;
        this.added = new EventEmitter();
        this.removed = new EventEmitter();
        this.colorPickerDisabled = true;
        this.disableTypeaheadIfSelected = false;
        this.pattern = '';
        this.formGroup = this.formBuilder.group({
            details: [],
            color: [],
            __active: [],
            __target: [],
            fragment: [],
            series: [],
            __template: []
        });
        this.isValid$ = this.formGroup.statusChanges.pipe(map((status) => status === 'VALID'), startWith(this.formGroup.valid));
    }
    validate(control) {
        var _a;
        return ((_a = this.formGroup) === null || _a === void 0 ? void 0 : _a.valid) ? null : { formInvalid: {} };
    }
    writeValue(obj) {
        this.formGroup.patchValue(Object.assign(Object.assign({}, obj), { details: obj }));
    }
    registerOnChange(fn) {
        this.formGroup.valueChanges.pipe(map(tmp => this.transformFormValue(tmp))).subscribe(fn);
    }
    registerOnTouched(fn) {
        this.formGroup.valueChanges.pipe(take(1)).subscribe(fn);
    }
    setDisabledState(isDisabled) {
        isDisabled ? this.formGroup.disable() : this.formGroup.enable();
    }
    collapse() {
        this.isCollapsed = !this.isCollapsed;
    }
    addOrRemoveItem() {
        const value = this.transformFormValue(this.formGroup.value);
        if (this.isSelected) {
            this.removed.emit(value);
        }
        else {
            this.added.emit(value);
        }
    }
    remove(dp) {
        this.removed.emit(this.transformFormValue(this.formGroup.value));
    }
    setPipe(filterStr) {
        this.pattern = filterStr;
        this.filterPipe = pipe(map((data) => {
            return this.filterDatapointLabel(data, filterStr);
        }));
    }
    unlinkDatapointTemplate() {
        const details = this.formGroup.value.details || {};
        this.resetUnusedProperties(details);
        this.formGroup.patchValue({ __template: undefined, details });
    }
    dataPointTemplateSelected(template) {
        const attributesToAssign = [
            'color',
            'label',
            'min',
            'max',
            'yellowRangeMax',
            'yellowRangeMin',
            'redRangeMax',
            'redRangeMin',
            'target',
            'orientation',
            'unit'
        ];
        const { fragment, series, __target, __active } = this.formGroup.value;
        const dataPoint = {
            fragment,
            series,
            __active,
            __target,
            __template: template.id
        };
        for (const attribute of attributesToAssign) {
            const value = template[DATAPOINT_LIBRARY_FRAGMENT][attribute];
            dataPoint[attribute] = value;
        }
        this.writeValue(dataPoint);
        this.setPipe('');
    }
    resetUnusedProperties(details) {
        const { showTarget, showYellowRange, showRedRange } = this.defaultFormOptions;
        details.__template = undefined;
        if (!showTarget) {
            details.target = undefined;
        }
        if (!showYellowRange) {
            details.yellowRangeMin = undefined;
            details.yellowRangeMax = undefined;
        }
        if (!showRedRange) {
            details.redRangeMin = undefined;
            details.redRangeMax = undefined;
        }
    }
    filterDatapointLabel(kpis, filterStr) {
        return kpis.filter((mo) => mo[DATAPOINT_LIBRARY_FRAGMENT] &&
            mo[DATAPOINT_LIBRARY_FRAGMENT].label &&
            typeof mo[DATAPOINT_LIBRARY_FRAGMENT].label === 'string' &&
            mo[DATAPOINT_LIBRARY_FRAGMENT].label.toLowerCase().indexOf(filterStr.toLowerCase()) > -1);
    }
    transformFormValue(formValue) {
        const obj = Object.assign({}, formValue.details || {}, formValue);
        delete obj.details;
        return obj;
    }
}
DatapointSelectorListItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-datapoint-selector-list-item',
                template: "<c8y-li class=\"c8y-list__item__collapse--container-small\" [formGroup]=\"formGroup\" #li>\n  <c8y-li-drag-handle><ng-content select=\"c8y-li-drag-handle\"></ng-content></c8y-li-drag-handle>\n  <c8y-li-icon *ngIf=\"showAddRemoveButton\" class=\"a-s-center p-r-4\">\n    <button\n      *ngIf=\"isSelected\"\n      class=\"btn btn-clean text-primary\"\n      (click)=\"addOrRemoveItem()\"\n      [title]=\"'Remove' | translate\"\n    >\n      <i c8yIcon=\"minus-circle\" class=\"text-danger\"></i>\n    </button>\n    <button\n      *ngIf=\"!isSelected\"\n      class=\"btn btn-clean text-primary\"\n      (click)=\"addOrRemoveItem()\"\n      [title]=\"'Select' | translate\"\n    >\n      <i c8yIcon=\"plus-circle\" class=\"text-primary\"></i>\n    </button>\n  </c8y-li-icon>\n\n  <c8y-li-checkbox\n    *ngIf=\"showActiveToggle\"\n    [displayAsSwitch]=\"true\"\n    formControlName=\"__active\"\n    (click)=\"$event.stopPropagation()\"\n    class=\"a-s-center p-r-0\"\n  ></c8y-li-checkbox>\n\n  <div class=\"d-flex a-i-center p-l-4\">\n    <div class=\"c8y-list__item__colorpicker p-t-0 p-b-0 p-l-0\" [title]=\"'Change color' | translate\">\n      <div class=\"c8y-colorpicker\">\n        <input type=\"color\" formControlName=\"color\" (click)=\"$event.stopPropagation()\" />\n        <span [style.background-color]=\"formGroup.value.color\"></span>\n      </div>\n    </div>\n    <button\n      class=\"btn-clean data-point-label text-truncate\"\n      [title]=\"formGroup.value.details?.label\"\n      (click)=\"li.collapsed = !li.collapsed\"\n    >\n      <span class=\"text-truncate\">\n        <c8y-highlight\n          [text]=\"formGroup.value.details?.label\"\n          [pattern]=\"highlightText\"\n          [shouldTrimPattern]=\"true\"\n        ></c8y-highlight>\n      </span>\n      <small class=\"text-truncate text-muted icon-flex\" *ngIf=\"formGroup.value.__target\">\n        <i c8yIcon=\"exchange\"></i>\n        <span class=\"text-truncate\">{{ formGroup.value.__target.name }}</span>\n      </small>\n    </button>\n\n    <button\n      class=\"btn-clean m-l-auto\"\n      *ngIf=\"!(isValid$ | async)\"\n      [popover]=\"'Some entries are invalid. Check the input fields with red borders.' | translate\"\n      container=\"body\"\n      [outsideClick]=\"true\"\n    >\n      <i class=\"text-danger\" c8yIcon=\"warning\"></i>\n    </button>\n  </div>\n\n  <c8y-li-action\n    *ngIf=\"optionToRemove\"\n    [icon]=\"'minus-circle'\"\n    [label]=\"'Remove from list' | translate\"\n    (click)=\"remove(formGroup.value)\"\n  ></c8y-li-action>\n  <c8y-li-action\n    *ngFor=\"let action of actions\"\n    [icon]=\"action.icon\"\n    [label]=\"action.label\"\n    (click)=\"action.callback(formGroup.value)\"\n  ></c8y-li-action>\n  <c8y-li-collapse>\n    <div class=\"data-point-details\">\n      <ul class=\"list-unstyled small m-b-16\">\n        <li class=\"p-t-4 p-b-4 flex-row separator-top-bottom\">\n          <label class=\"small m-b-0 m-r-8 flex-item-v-start text-muted\" translate>Fragment</label>\n          <span class=\"flex-item-right\">\n            <c8y-highlight\n              [text]=\"formGroup.value.fragment\"\n              [pattern]=\"highlightText\"\n              [shouldTrimPattern]=\"true\"\n            ></c8y-highlight>\n          </span>\n        </li>\n        <li class=\"p-t-4 p-b-4 flex-row separator-bottom\">\n          <label class=\"small m-b-0 m-r-8 flex-item-v-start text-muted\" translate>Series</label>\n          <span class=\"flex-item-right\">\n            <c8y-highlight\n              [text]=\"formGroup.value.series\"\n              [pattern]=\"highlightText\"\n              [shouldTrimPattern]=\"true\"\n            ></c8y-highlight>\n          </span>\n        </li>\n      </ul>\n      <div\n        class=\"form-group\"\n        *ngIf=\"datapointLibraryEntries && datapointLibraryEntries | async as libraryEntries\"\n      >\n        <label class=\"d-inline-block\" translate>Data point template</label>\n        <button\n          class=\"btn btn-clean\"\n          [popover]=\"datapointHintPopoverTemplate\"\n          (click)=\"$event.stopPropagation()\"\n          container=\"body\"\n          [outsideClick]=\"true\"\n        >\n          <i [c8yIcon]=\"'question-circle-o'\" class=\"m-l-4 text-info\"></i>\n        </button>\n\n        <ng-template #datapointHintPopoverTemplate>\n          {{\n            'Using a data point template sets color, label, unit and ranges. Removing the template allows you to set the values manually.'\n              | translate\n          }}\n        </ng-template>\n        <div class=\"d-flex\">\n          <c8y-typeahead\n            [placeholder]=\"'No template' | translate\"\n            [ngModel]=\"formGroup.value.__template ? formGroup.value.details : undefined\"\n            [ngModelOptions]=\"{ standalone: true }\"\n            (onSearch)=\"setPipe($event)\"\n            [displayProperty]=\"'label'\"\n            [hideNew]=\"true\"\n            *ngIf=\"datapointLibraryEntries\"\n            [disabled]=\"isSelected && disableTypeaheadIfSelected\"\n            class=\"flex-grow\"\n          >\n            <c8y-li\n              *c8yFor=\"\n                let item of datapointLibraryEntries;\n                loadMore: 'auto';\n                pipe: filterPipe;\n                notFound: notFoundTemplate\n              \"\n              class=\"p-l-8 p-r-8 c8y-list__item--link interact\"\n              (click)=\"dataPointTemplateSelected(item)\"\n              [active]=\"formGroup.value.__template === item.id\"\n            >\n              <c8y-highlight [text]=\"item.c8y_Kpi?.label\" [pattern]=\"pattern\"></c8y-highlight>\n              <c8y-li-icon icon=\"circle\" [style.color]=\"item.c8y_Kpi?.color\"></c8y-li-icon>\n            </c8y-li>\n            <ng-template #notFoundTemplate>\n              <c8y-li class=\"bg-gray-lighter p-8\" *ngIf=\"pattern.length > 0\">\n                <span>No match found.</span>\n              </c8y-li>\n            </ng-template>\n          </c8y-typeahead>\n          <button\n            *ngIf=\"formGroup.value.__template\"\n            class=\"btn btn-info btn-xs btn-icon a-s-center m-l-8\"\n            [popover]=\"datapointOverviewPopoverTemplate\"\n            placement=\"left\"\n            container=\"body\"\n            [outsideClick]=\"true\"\n            [title]=\"'Info' | translate\"\n          >\n            <i c8yIcon=\"info\" class=\"text-info\"></i>\n          </button>\n          <button\n            *ngIf=\"formGroup.value.__template && hasUnlinkTemplateOption\"\n            class=\"btn btn-danger btn-xs btn-icon a-s-center m-l-8\"\n            (click)=\"unlinkDatapointTemplate()\"\n            [title]=\"'Unlink data point template' | translate\"\n          >\n            <i c8yIcon=\"unlink\"></i>\n          </button>\n        </div>\n      </div>\n      <ng-template #datapointOverviewPopoverTemplate>\n        <c8y-datapoint-template-popover\n          [datapoint]=\"formGroup.value.details\"\n        ></c8y-datapoint-template-popover>\n      </ng-template>\n      <c8y-datapoint-attributes-form\n        *ngIf=\"defaultFormOptions\"\n        [showTarget]=\"defaultFormOptions.showTarget\"\n        [showRange]=\"defaultFormOptions.showRange\"\n        [showYellowRange]=\"defaultFormOptions.showYellowRange\"\n        [showRedRange]=\"defaultFormOptions.showRedRange\"\n        [showChart]=\"defaultFormOptions.showChart\"\n        [showFormIfTemplateWasSelected]=\"defaultFormOptions.showFormIfTemplateWasSelected\"\n        formControlName=\"details\"\n      ></c8y-datapoint-attributes-form>\n    </div>\n  </c8y-li-collapse>\n</c8y-li>\n",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => DatapointSelectorListItemComponent),
                        multi: true
                    },
                    {
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef(() => DatapointSelectorListItemComponent),
                        multi: true
                    }
                ]
            },] }
];
DatapointSelectorListItemComponent.ctorParameters = () => [
    { type: FormBuilder }
];
DatapointSelectorListItemComponent.propDecorators = {
    defaultFormOptions: [{ type: Input }],
    isSelected: [{ type: Input }],
    isCollapsed: [{ type: Input }],
    showAddRemoveButton: [{ type: Input }],
    editable: [{ type: Input }],
    showActiveToggle: [{ type: Input }],
    activeToggleDisabled: [{ type: Input }],
    showOptions: [{ type: Input }],
    datapointLibraryEntries: [{ type: Input }],
    actions: [{ type: Input }],
    optionToRemove: [{ type: Input }],
    hasUnlinkTemplateOption: [{ type: Input }],
    added: [{ type: Output }],
    removed: [{ type: Output }],
    colorPickerDisabled: [{ type: Input }],
    disableTypeaheadIfSelected: [{ type: Input }],
    highlightText: [{ type: Input }],
    dragHandle: [{ type: ContentChild, args: [ListItemDragHandleComponent,] }]
};

class DatapointSelectorComponent {
    constructor(datapointService) {
        this.datapointService = datapointService;
        this.allowChangingContext = true;
        this.allowDatapointsFromMultipleAssets = true;
        this.selectedDatapoints = new Array();
        this.defaultActiveState = true;
        this.ignoreDatapointTemplates = false;
        this.guessDatapointUnit = true;
        this.allowSearch = true;
        this.searchString = '';
        this.maxNumberOfDatapoints = 50;
        this.loadingDatapoints = false;
        this.assetSelection = new BehaviorSubject(null);
        this.searchString$ = new BehaviorSubject('');
        this.touched = false;
        this.setupObservables();
    }
    ngOnInit() {
        if (!this.ignoreDatapointTemplates) {
            this.datapointLibraryEntries = from(this.datapointService.getFirstDatapointLibraryPage());
        }
        if (this.contextAsset) {
            this.selectionChanged(this.contextAsset);
        }
    }
    writeValue(obj) {
        this.selectedDatapoints = obj;
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    datapointAdded(dp) {
        this.markAsTouched();
        dp.__active = this.defaultActiveState;
        if (this.guessDatapointUnit && !dp.unit) {
            this.datapointService.guessUnitOfDatapoint(dp.fragment, dp.series, dp.__target).then(unit => {
                dp.unit = unit;
            });
        }
        this.selectedDatapoints = [...this.selectedDatapoints, dp];
        this.emitCurrentSelection();
    }
    datapointRemoved(dp) {
        this.markAsTouched();
        this.selectedDatapoints = this.selectedDatapoints.filter(tmp => {
            var _a, _b;
            return tmp.fragment !== dp.fragment ||
                tmp.series !== dp.series ||
                ((_a = tmp.__target) === null || _a === void 0 ? void 0 : _a.id) !== ((_b = dp.__target) === null || _b === void 0 ? void 0 : _b.id);
        });
        this.emitCurrentSelection();
    }
    selectionChanged(evt) {
        if (Array.isArray(evt) && evt.length !== 0) {
            return this.selectAsset(evt[0]);
        }
        if (!Array.isArray(evt) && evt.items) {
            return this.selectionChanged(evt.items);
        }
        if (!Array.isArray(evt) && evt.id) {
            return this.selectAsset(evt);
        }
        // reset selection
        this.assetSelection.next(null);
    }
    trackByFn(_index, item) {
        var _a;
        return `${item.fragment}-${(_a = item.__target) === null || _a === void 0 ? void 0 : _a.id}-${item.series}`;
    }
    searchStringChanged(newValue = '') {
        this.searchString$.next(newValue);
        this.searchString = newValue;
    }
    setupObservables() {
        this.datapoints$ = this.assetSelection.pipe(tap(() => {
            this.loadingDatapoints = true;
        }), switchMap(asset => (asset === null || asset === void 0 ? void 0 : asset.id)
            ? this.datapointService.getDatapointsOfAsset(asset, this.ignoreDatapointTemplates)
            : []), tap(() => (this.loadingDatapoints = false)), shareReplay(1));
        this.searchStringChanges$ = this.searchString$.pipe(distinctUntilChanged(), debounceTime(500), shareReplay(1));
        this.filteredDatapoints$ = combineLatest([this.searchStringChanges$, this.datapoints$]).pipe(map(([searchString, datapoints]) => {
            if (!searchString) {
                return datapoints;
            }
            const lowerCaseSearchString = searchString.toLowerCase();
            return datapoints.filter(datapoint => this.includesSearchString(datapoint, lowerCaseSearchString));
        }), map(filtered => filtered.slice(0, this.maxNumberOfDatapoints)));
    }
    selectAsset(asset) {
        this.assetSelection.next(asset);
        this.searchStringChanged();
        if (!this.allowDatapointsFromMultipleAssets) {
            this.clearSelection();
        }
    }
    clearSelection() {
        this.selectedDatapoints = [];
        this.emitCurrentSelection();
    }
    emitCurrentSelection() {
        this.onChange(this.selectedDatapoints);
    }
    markAsTouched() {
        if (!this.touched) {
            this.onTouched();
            this.touched = true;
        }
    }
    includesSearchString(datapoint, lowerCaseSearchString) {
        var _a, _b, _c;
        const label = (_a = datapoint.label) === null || _a === void 0 ? void 0 : _a.toLowerCase();
        if (label && label.includes(lowerCaseSearchString)) {
            return true;
        }
        const fragment = (_b = datapoint.fragment) === null || _b === void 0 ? void 0 : _b.toLowerCase();
        if (fragment && fragment.includes(lowerCaseSearchString)) {
            return true;
        }
        const series = (_c = datapoint.series) === null || _c === void 0 ? void 0 : _c.toLowerCase();
        if (series && series.includes(lowerCaseSearchString)) {
            return true;
        }
        return false;
    }
}
DatapointSelectorComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-datapoint-selector',
                template: "<div class=\"d-grid grid__row--1 fit-h\" [ngClass]=\"allowChangingContext ? 'grid__col--3-6-3--md' : 'grid__col--8-4--md'\">\n  <div class=\"d-flex d-col p-relative bg-gray-white\" *ngIf=\"allowChangingContext\">\n    <c8y-asset-selector-miller\n      [(ngModel)]=\"contextAsset\"\n      [asset]=\"contextAsset\"\n      (onSelected)=\"selectionChanged($event)\"\n      [container]=\"''\"\n      [config]=\"{\n        view: 'miller',\n        groupsSelectable: true,\n        columnHeaders: true,\n        showChildDevices: true,\n        showUnassignedDevices: true,\n        singleColumn: true,\n        search: allowSearch\n      }\"\n      class=\"d-contents\"\n    ></c8y-asset-selector-miller>\n  </div>\n  <!-- center column -->\n  <div class=\"inner-scroll bg-component\">\n    <ng-template #noDeviceEmptyState>\n      <div class=\"p-16\">\n        <div class=\"c8y-empty-state text-left\">\n          <h1 class=\"c8y-icon c8y-icon-data-points c8y-icon-duocolor\"></h1>\n          <div>\n            <p>\n              <strong translate>No data points to display.</strong>\n            </p>\n            <small translate>Select an asset from the list.</small>\n          </div>\n        </div>\n      </div>\n    </ng-template>\n    <ng-template #loadingData>\n      <div class=\"p-16 text-center\">\n        <c8y-loading></c8y-loading>\n      </div>\n    </ng-template>\n    <div *ngIf=\"assetSelection | async as asset; else noDeviceEmptyState\" class=\"bg-inherit\">\n      <div class=\"p-l-16 p-r-16 p-t-8 p-b-8 sticky-top bg-inherit separator-bottom\">\n        <p\n          class=\"text-medium text-truncate\"\n          [title]=\"'Available data points' | translate\"\n        >\n          {{ 'Available data points' | translate }}\n        </p>\n        <div *ngIf=\"!loadingDatapoints\" id=\"search\" class=\"input-group input-group-search m-t-4\">\n          <input\n            type=\"search\"\n            class=\"form-control\"\n            placeholder=\"Search\u2026\"\n            [ngModel]=\"searchString\"\n            (ngModelChange)=\"searchStringChanged($event)\"\n          />\n          <span class=\"input-group-addon\">\n            <i c8yIcon=\"search\" *ngIf=\"!searchString; else clearSearchString\"></i>\n            <ng-template #clearSearchString>\n                <i\n                  c8yIcon=\"times\"\n                  class=\"text-muted\"\n                  *ngIf=\"searchString\"\n                  (click)=\"searchString = ''\"\n                ></i>\n            </ng-template>\n          </span>\n        </div>\n      </div>\n      <ng-container *ngIf=\"filteredDatapoints$ | async as filteredDatapoints; else loadingData\">\n        <ng-container *ngIf=\"!loadingDatapoints; else loadingData\">\n          <ng-container *ngIf=\"datapoints$ | async as datapoints\">\n            <div class=\"p-16\" *ngIf=\"!filteredDatapoints.length\">\n              <c8y-ui-empty-state\n                [icon]=\"'c8y-data-points'\"\n                [title]=\"'No data points to display.' | translate\"\n                [subtitle]=\"datapoints.length ? ('Try another search term.' | translate) : ('Select an asset with data points from the list.' | translate)\"\n                [horizontal]=\"true\"\n              ></c8y-ui-empty-state>\n            </div>\n\n\n\n            <c8y-list-group>\n              <c8y-list-item *ngIf=\"datapoints.length > maxNumberOfDatapoints && filteredDatapoints.length >= maxNumberOfDatapoints\"\n                class=\"sticky-top\"\n                style=\"top: 72px\"\n                translate\n              >\n                <div class=\"alert alert-warning m-b-0\">\n                  {{ 'Due to the large number, only a subset of data points are displayed. Use search to narrow down the number of results.' | translate}}\n                </div>\n              </c8y-list-item>\n              <c8y-datapoint-selector-list-item\n                [ngModel]=\"dp\"\n                [isSelected]=\"selectedDatapoints | includesDatapoint: dp\"\n                [datapointLibraryEntries]=\"datapointLibraryEntries\"\n                [disableTypeaheadIfSelected]=\"true\"\n                (added)=\"datapointAdded($event)\"\n                (removed)=\"datapointRemoved($event)\"\n                [highlightText]=\"searchStringChanges$ | async\"\n                class=\"d-contents\"\n                *ngFor=\"let dp of filteredDatapoints; trackBy: trackByFn\"\n              ></c8y-datapoint-selector-list-item>\n            </c8y-list-group>\n          </ng-container>\n        </ng-container>\n      </ng-container>\n    </div>\n  </div>\n  <!-- last column  -->\n  <div class=\"inner-scroll bg-gray-white\">\n    <p\n      class=\"text-medium m-b-4 p-l-16 p-r-16 p-t-8 p-b-8 separator-bottom sticky-top text-truncate\"\n      [title]=\"'Selected data points' | translate\"\n      translate\n    >\n      Selected data points\n    </p>\n    <div class=\"d-flex flex-wrap gap-8 p-l-16 p-r-16 p-b-16\">\n      <div class=\"c8y-datapoint-pill\" *ngFor=\"let selectedDp of selectedDatapoints\">\n        <button\n          [title]=\"'Remove' | translate\"\n          type=\"button\"\n          class=\"c8y-datapoint-pill__btn\"\n          (click)=\"datapointRemoved(selectedDp)\"\n        >\n          <i c8yIcon=\"remove\" class=\"icon-14\"></i>\n        </button>\n        <div\n          class=\"c8y-datapoint-pill__label\"\n          [title]=\"selectedDp | datapointLabel: { doNotUseLabel: true, includeDevice: true }\"\n        >\n          <i\n            c8yIcon=\"circle\"\n            class=\"m-r-4 icon-14\"\n            [style.color]=\"selectedDp.color\"\n          ></i>\n          <span class=\"text-truncate\">\n            <span class=\"text-truncate\">{{ selectedDp | datapointLabel }}</span>\n            <small class=\"text-muted text-10\" *ngIf=\"selectedDp?.__target?.name\">\n              {{ selectedDp?.__target?.name }}\n            </small>\n          </span>\n        </div>\n      </div>\n    </div>\n    <div class=\"p-16\" *ngIf=\"!selectedDatapoints || !selectedDatapoints.length\">\n      <div class=\"c8y-empty-state text-left\">\n        <h1 class=\"c8y-icon c8y-icon-data-points c8y-icon-duocolor\"></h1>\n        <p>\n          <strong translate>No data points selected.</strong>\n        </p>\n      </div>\n    </div>\n  </div>\n</div>\n",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        multi: true,
                        useExisting: forwardRef(() => DatapointSelectorComponent)
                    }
                ]
            },] }
];
DatapointSelectorComponent.ctorParameters = () => [
    { type: DatapointLibraryService }
];
DatapointSelectorComponent.propDecorators = {
    contextAsset: [{ type: Input }],
    allowChangingContext: [{ type: Input }],
    allowDatapointsFromMultipleAssets: [{ type: Input }],
    defaultActiveState: [{ type: Input }],
    ignoreDatapointTemplates: [{ type: Input }],
    guessDatapointUnit: [{ type: Input }],
    allowSearch: [{ type: Input }]
};

class DatapointTemplatePopoverComponent {
    constructor() {
        this.attributes = [
            {
                label: gettext('Fragment'),
                key: 'fragment'
            },
            {
                label: gettext('Series'),
                key: 'series'
            },
            {
                label: gettext('Unit'),
                key: 'unit'
            },
            {
                label: gettext('Range'),
                key: 'min'
            },
            {
                label: gettext('Target'),
                key: 'target'
            },
            {
                label: gettext('Yellow range'),
                labelColor: 'yellow',
                key: 'yellowRangeMin'
            },
            {
                label: gettext('Red range'),
                labelColor: 'red',
                key: 'redRangeMin'
            }
        ];
    }
}
DatapointTemplatePopoverComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-datapoint-template-popover',
                template: "<p class=\"text-medium\">\n  <i c8yIcon=\"circle\" [style.color]=\"datapoint.color\"></i>\n  {{ datapoint.label }}\n</p>\n<p>{{ datapoint.description }}</p>\n\n<ul class=\"list-unstyled small p-t-16\">\n  <ng-container *ngFor=\"let attribute of attributes; let i = index\">\n    <li\n      class=\"p-t-4 p-b-4 flex-row separator-bottom text-nowrap\"\n      *ngIf=\"datapoint[attribute.key] !== undefined\"\n    >\n      <label class=\"small m-b-0 m-r-8\">\n        <i *ngIf=\"attribute.labelColor\" c8yIcon=\"square\" [style.color]=\"attribute.labelColor\"></i>\n        {{ attribute.label | translate }}\n      </label>\n      <ng-container [ngSwitch]=\"attribute.key\">\n        <span *ngSwitchCase=\"'min'\" class=\"flex-item-right\">\n          {{ datapoint['min'] }} \u2014 {{ datapoint['max'] }}\n        </span>\n        <span *ngSwitchCase=\"'yellowRangeMin'\" class=\"flex-item-right\">\n          {{ datapoint['yellowRangeMin'] }} \u2014 {{ datapoint['yellowRangeMax'] }}\n        </span>\n        <span *ngSwitchCase=\"'redRangeMin'\" class=\"flex-item-right\">\n          {{ datapoint['redRangeMin'] }} \u2014 {{ datapoint['redRangeMax'] }}\n        </span>\n        <span *ngSwitchDefault class=\"flex-item-right\">\n          {{ datapoint[attribute.key] }}\n        </span>\n      </ng-container>\n    </li>\n  </ng-container>\n</ul>\n"
            },] }
];
DatapointTemplatePopoverComponent.propDecorators = {
    datapoint: [{ type: Input }],
    attributes: [{ type: Input }]
};

class DatapointLabelPipe {
    transform(datapoint, options = { includeDevice: false, doNotUseLabel: false }) {
        var _a, _b, _c, _d;
        let label = '';
        try {
            if (!(options === null || options === void 0 ? void 0 : options.doNotUseLabel) && datapoint.label) {
                label = datapoint.label;
            }
            else {
                label = `${datapoint.fragment} → ${datapoint.series}`;
            }
            if ((options === null || options === void 0 ? void 0 : options.includeDevice) && (((_a = datapoint.__target) === null || _a === void 0 ? void 0 : _a.name) || ((_b = datapoint.__target) === null || _b === void 0 ? void 0 : _b.id))) {
                label += ` (${((_c = datapoint.__target) === null || _c === void 0 ? void 0 : _c.name) || ((_d = datapoint.__target) === null || _d === void 0 ? void 0 : _d.id)})`;
            }
        }
        catch (e) {
            // nothing to do
        }
        return label;
    }
}
DatapointLabelPipe.decorators = [
    { type: Pipe, args: [{
                name: 'datapointLabel'
            },] }
];

class FilterDatapointsPipe {
    transform(datapoints, searchString) {
        if (!searchString || !datapoints || !Array.isArray(datapoints)) {
            return datapoints;
        }
        const lowerCaseSearchString = searchString.toLowerCase().trim();
        return datapoints.filter(datapoint => this.includesSearchStringIgnoringCasing(datapoint, lowerCaseSearchString));
    }
    includesSearchStringIgnoringCasing(datapoint, lowerCaseSearchString) {
        var _a, _b, _c;
        const label = (_a = datapoint.label) === null || _a === void 0 ? void 0 : _a.toLowerCase();
        if (label && label.includes(lowerCaseSearchString)) {
            return true;
        }
        const fragment = (_b = datapoint.fragment) === null || _b === void 0 ? void 0 : _b.toLowerCase();
        if (fragment && fragment.includes(lowerCaseSearchString)) {
            return true;
        }
        const series = (_c = datapoint.series) === null || _c === void 0 ? void 0 : _c.toLowerCase();
        if (series && series.includes(lowerCaseSearchString)) {
            return true;
        }
        return false;
    }
}
FilterDatapointsPipe.decorators = [
    { type: Pipe, args: [{
                name: 'filterDatapoints'
            },] }
];

class IncludesDatapointPipe {
    transform(datapointList, datapoint) {
        if (!Array.isArray(datapointList) || !datapoint) {
            return false;
        }
        return datapointList.some(tmp => {
            var _a, _b;
            return tmp.fragment === datapoint.fragment &&
                tmp.series === datapoint.series &&
                ((_a = tmp.__target) === null || _a === void 0 ? void 0 : _a.id) === ((_b = datapoint.__target) === null || _b === void 0 ? void 0 : _b.id);
        });
    }
}
IncludesDatapointPipe.decorators = [
    { type: Pipe, args: [{
                name: 'includesDatapoint'
            },] }
];

class DatapointSelectorModule {
}
DatapointSelectorModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    AssetSelectorModule,
                    CollapseModule,
                    CoreModule,
                    BsDropdownModule,
                    ModalModule,
                    PopoverModule,
                    DragDropModule
                ],
                declarations: [
                    DatapointSelectorComponent,
                    DatapointSelectorModalComponent,
                    DatapointSelectorListItemComponent,
                    DatapointSelectionListComponent,
                    DatapointTemplatePopoverComponent,
                    IncludesDatapointPipe,
                    DatapointLabelPipe,
                    FilterDatapointsPipe,
                    DatapointAttributesFormComponent
                ],
                exports: [
                    DatapointSelectorComponent,
                    DatapointSelectorModalComponent,
                    DatapointSelectorListItemComponent,
                    DatapointSelectionListComponent,
                    DatapointTemplatePopoverComponent,
                    IncludesDatapointPipe,
                    DatapointLabelPipe,
                    DatapointAttributesFormComponent
                ]
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { AXIS_TYPES, CHART_LINE_TYPES, CHART_RENDER_TYPES, DATAPOINT_LIBRARY_FRAGMENT, DatapointAttributesFormComponent, DatapointAttributesFormValidationService, DatapointLibraryService, DatapointSelectionListComponent, DatapointSelectorComponent, DatapointSelectorListItemComponent, DatapointSelectorModalComponent, DatapointSelectorModule, DatapointSelectorService, DatapointTemplatePopoverComponent as ɵa, IncludesDatapointPipe as ɵb, DatapointLabelPipe as ɵc, FilterDatapointsPipe as ɵd };
//# sourceMappingURL=c8y-ngx-components-datapoint-selector.js.map
