import * as i0 from '@angular/core';
import { EventEmitter, Component, Output, Input, Injectable, ViewChild, NgModule } from '@angular/core';
import * as i2 from '@c8y/ngx-components';
import { gettext, AppStateService, AlertService, Status, ModalService, CoreModule, CommonModule, FormsModule, PopoverConfirmComponent, ViewContext, HOOK_ROUTE } from '@c8y/ngx-components';
import { __awaiter } from 'tslib';
import { FetchClient, InventoryService, IdentityService } from '@c8y/client';
import { orderBy, head, findIndex, get, find } from 'lodash-es';
import { RouterModule, Router } from '@angular/router';
import * as i1 from '@c8y/client';
import { TranslateService } from '@ngx-translate/core';
import { BsModalRef, BsModalService } from 'ngx-bootstrap/modal';
import { saveAs } from 'file-saver';
import { pipe } from 'rxjs';
import { map } from 'rxjs/operators';

class NoConnectionsFoundComponent {
    constructor() {
        this.onAction = new EventEmitter();
        this.header = gettext('Connections');
    }
    addConnection() {
        this.onAction.emit();
    }
}
NoConnectionsFoundComponent.decorators = [
    { type: Component, args: [{
                selector: 'no-connections-found',
                template: "<div class=\"card content-fullpage split-view--5-7\">\n  <div class=\"card-header separator grid__col--fullspan\">\n    <h4>{{ header | translate}}</h4>\n  </div>\n  <div class=\"inner-scroll split-view__list\">\n    <div class=\"bg-gray-white flex-grow\">\n      <div class=\"card-block large-padding\">\n        <c8y-ui-empty-state\n          [icon]=\"'plug'\"\n          [title]=\"'No connections found.' | translate\"\n          [subtitle]=\"'Click below to add a new connection.' | translate\"\n          [horizontal]=\"true\"\n        ></c8y-ui-empty-state>\n      </div>\n    </div>\n\n    <div class=\"card-footer separator\">\n      <button\n        title=\"{{ 'Add connection' | translate }}\"\n        class=\"btn btn-primary\"\n        (click)=\"addConnection()\"\n      >\n        <i [c8yIcon]=\"'plus-circle'\"></i>\n        {{ 'Add connection' | translate }}\n      </button>\n    </div>\n  </div>\n  <div class=\"inner-scroll split-view__detail\">\n    <div class=\"flex-grow\">\n      <div class=\"card-block large-padding\">\n        <c8y-ui-empty-state\n          [icon]=\"'more-details'\"\n          [title]=\"'No settings to display.' | translate\"\n          [subtitle]=\"'Add a connection.' | translate\"\n          [horizontal]=\"true\"\n        ></c8y-ui-empty-state>\n      </div>\n    </div>\n  </div>\n</div>\n"
            },] }
];
NoConnectionsFoundComponent.propDecorators = {
    onAction: [{ type: Output }],
    header: [{ type: Input }]
};

var ConnectionType;
(function (ConnectionType) {
    ConnectionType[ConnectionType["ACTILITY"] = 0] = "ACTILITY";
    ConnectionType[ConnectionType["SIGFOX"] = 1] = "SIGFOX";
})(ConnectionType || (ConnectionType = {}));
function isSigfoxConnection(connection) {
    return typeof connection.parentGroupId !== 'undefined';
}
function isActilityConnection(connection) {
    return typeof connection.profileId !== 'undefined';
}

class MultipleLnsConnectorService {
    constructor(client, appStateService, alertService) {
        this.client = client;
        this.appStateService = appStateService;
        this.alertService = alertService;
        this.headers = { 'Content-Type': 'application/json' };
    }
    list(connectionType) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `${this.getBaseUrlByType(connectionType)}/lns-connection`;
            const options = {
                method: 'GET',
                headers: this.headers
            };
            return this.client.fetch(url, options);
        });
    }
    /**
     * Saves the connection.
     * @param connection The connection to be saved.
     * @param originalName The original name of the connection, required to perform an update.
     */
    save(connection, originalName = null) {
        return __awaiter(this, void 0, void 0, function* () {
            if (originalName) {
                return this.update(connection, originalName);
            }
            return this.create(connection);
        });
    }
    detail(connectionType, connectionName) {
        return __awaiter(this, void 0, void 0, function* () {
            const name = connectionName.toLocaleLowerCase();
            const url = `${this.getBaseUrlByType(connectionType)}/lns-connection/${encodeURIComponent(String(name))}`;
            const options = {
                method: 'GET',
                headers: this.headers
            };
            const res = yield this.client.fetch(url, options);
            if (res.status === 200) {
                return yield res.json();
            }
            return null;
        });
    }
    exists(connectionType, connectionName) {
        return __awaiter(this, void 0, void 0, function* () {
            const connection = yield this.detail(connectionType, connectionName);
            return connection !== null;
        });
    }
    create(connection) {
        return __awaiter(this, void 0, void 0, function* () {
            connection.name = connection.name.toLocaleLowerCase();
            const url = `${this.getBaseUrlByConnection(connection)}/lns-connection`;
            const options = {
                method: 'POST',
                headers: this.headers,
                body: JSON.stringify(connection)
            };
            return this.client.fetch(url, options);
        });
    }
    update(connection, originalName) {
        return __awaiter(this, void 0, void 0, function* () {
            connection.name = connection.name.toLocaleLowerCase();
            const url = `${this.getBaseUrlByConnection(connection)}/lns-connection/${encodeURIComponent(String(originalName))}`;
            const options = {
                method: 'PUT',
                headers: this.headers,
                body: JSON.stringify(connection)
            };
            return this.client.fetch(url, options);
        });
    }
    getBaseUrlByConnection(connection) {
        return isSigfoxConnection(connection)
            ? 'service/sigfox-agent'
            : isActilityConnection(connection)
                ? 'service/actility'
                : '';
    }
    getBaseUrlByType(connectionType) {
        return (connectionType === ConnectionType.SIGFOX)
            ? 'service/sigfox-agent'
            : (connectionType === ConnectionType.ACTILITY)
                ? 'service/actility'
                : '';
    }
    delete(connection) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `${this.getBaseUrlByConnection(connection)}/lns-connection`;
            const options = {
                method: 'DELETE'
            };
            return this.client.fetch(`${url}/${encodeURIComponent(String(connection.name))}`, options);
        });
    }
    getApplication(name) {
        const { references } = this.appStateService.currentTenant.value.applications;
        return references.find(({ application }) => application.name === name).application;
    }
    download(url) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const options = {
                    method: 'GET'
                };
                return this.client.fetch(url, options);
            }
            catch (e) {
                this.alertService.addServerFailure(e);
            }
        });
    }
}
MultipleLnsConnectorService.ɵprov = i0.ɵɵdefineInjectable({ factory: function MultipleLnsConnectorService_Factory() { return new MultipleLnsConnectorService(i0.ɵɵinject(i1.FetchClient), i0.ɵɵinject(i2.AppStateService), i0.ɵɵinject(i2.AlertService)); }, token: MultipleLnsConnectorService, providedIn: "root" });
MultipleLnsConnectorService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
MultipleLnsConnectorService.ctorParameters = () => [
    { type: FetchClient },
    { type: AppStateService },
    { type: AlertService }
];

class ConnectionInfoWithDownloadCsvComponent {
    constructor(modal, connectorService) {
        this.modal = modal;
        this.connectorService = connectorService;
    }
    dismiss() {
        this.modal.hide();
    }
    download() {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `/service/${this.appData.contextPath}${this.messageData.URL}`;
            const res = yield this.connectorService.download(url);
            const streamData = yield res.blob();
            saveAs(streamData, 'DeviceList.csv');
        });
    }
}
ConnectionInfoWithDownloadCsvComponent.decorators = [
    { type: Component, args: [{
                selector: 'connection-info-with-download-csv',
                template: "<div class=\"modal-dialog\">\n  <div class=\"modal-content\">\n    <div class=\"c8y-prompt alert alert-danger\">\n      <h3 class=\"m-b-16\">\n        <i class=\"dlt-c8y-icon-exclamation-circle\"></i>\n        <span>{{ modalTitle | translate }}</span>\n      </h3>\n      <p class=\"text-break-word\">\n        {{ messageData.message | translate }}\n      </p>\n      \n      <span class=\"btn-default\" (click)=\"download()\">{{\n        'Click to download link with affected devices' | translate\n      }}</span>\n      <div class=\"alert-footer\">\n        <button title=\"{{ 'Cancel' | translate }}\" class=\"btn btn-default\" (click)=\"dismiss()\">\n          {{ 'Cancel' | translate }}\n        </button>\n      </div>\n    </div>\n  </div>\n</div>\n"
            },] }
];
ConnectionInfoWithDownloadCsvComponent.ctorParameters = () => [
    { type: BsModalRef },
    { type: MultipleLnsConnectorService }
];
ConnectionInfoWithDownloadCsvComponent.propDecorators = {
    messageData: [{ type: Input }],
    appData: [{ type: Input }],
    modalTitle: [{ type: Input }]
};

class SigfoxMultipleLnsConnectorComponent {
    constructor(connectorService, alertService, translateService, modalService, modal) {
        this.connectorService = connectorService;
        this.alertService = alertService;
        this.translateService = translateService;
        this.modalService = modalService;
        this.modal = modal;
        this.state = 'loadingConnection';
        this.connection = {};
        this.connections = Array();
        this.showPassword = false;
        this.cardHeader = gettext('Sigfox connections');
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.loadConnections();
        });
    }
    loadConnections() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.connectorService.list(ConnectionType.SIGFOX);
            if (res && res.status !== 200) {
                const data = res.json ? yield res.json() : undefined;
                this.alertService.addServerFailure({ data, res });
                this.state = 'loadingError';
            }
            else {
                const list = yield res.json();
                this.connections = orderBy(list, ['name'], ['asc']);
                yield this.setModel();
            }
        });
    }
    setModel(connectionObj = null) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.resetEditedUnsavedConnection();
            this.connection = connectionObj
                ? connectionObj
                : this.state === 'savedSuccessfully'
                    ? this.connection
                    : head(this.connections);
            this.state = 'updateConnection';
            this.showPassword = false;
            this.connectionBeingEdited = this.connection ? this.connection.name : undefined;
        });
    }
    resetEditedUnsavedConnection() {
        return __awaiter(this, void 0, void 0, function* () {
            const originalConnectionIndex = (!this.connection) ? 0 : findIndex(this.connections, { name: this.connectionBeingEdited });
            if (this.connectionBeingEdited && this.state === 'updateConnection') {
                const isConnectionExist = yield this.connectorService.detail(ConnectionType.SIGFOX, this.connectionBeingEdited);
                this.connections[originalConnectionIndex] = isConnectionExist;
            }
        });
    }
    addConnection() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.resetEditedUnsavedConnection();
            this.connection = {};
            this.connectionBeingEdited = '';
            this.state = 'addConnections';
            this.showPassword = true;
        });
    }
    save() {
        return __awaiter(this, void 0, void 0, function* () {
            const checkForConnectionName = (this.connectionBeingEdited && this.connectionBeingEdited !== '') ? this.connectionBeingEdited : this.connection.name;
            const isConnectionExist = yield this.connectorService.exists(ConnectionType.SIGFOX, checkForConnectionName);
            if (this.state === 'addConnections' && isConnectionExist) {
                const mesg = this.translateService.instant(gettext(`Connection with name "{{ name }}" already exists.`), { name: this.connection.name });
                this.alertService.danger(mesg);
            }
            else {
                this.saveConnection();
            }
        });
    }
    deleteConnection(connection) {
        return __awaiter(this, void 0, void 0, function* () {
            const mesg = this.translateService.instant(gettext(`You are about to delete the connection "{{ name }}". Do you want to proceed?`), { name: connection.name });
            try {
                yield this.modal.confirm(gettext('Delete connection'), mesg, Status.DANGER, {
                    ok: gettext('Delete'),
                    cancel: gettext('Cancel')
                });
                yield this.delete(connection);
            }
            catch (error) {
                // empty catch block
            }
        });
    }
    changePassword() {
        this.showPassword = !this.showPassword;
        if (this.connectorsForm.controls.password) {
            this.connectorsForm.controls.password.setValue(null);
        }
    }
    saveConnection() {
        return __awaiter(this, void 0, void 0, function* () {
            let res;
            res = yield this.connectorService.save(this.connection, this.connectionBeingEdited);
            if (res && (res.status === 201 || res.status === 200)) {
                this.state = 'savedSuccessfully';
                this.alertService.success(gettext('Connection saved.'));
                yield this.loadConnections();
            }
            else if (res && res.status === 500) {
                const data = res.json ? yield res.json() : undefined;
                const app = this.connectorService.getApplication('sigfox-agent');
                const initialState = {
                    messageData: data,
                    appData: app,
                    modalTitle: gettext('Failed to update the connection')
                };
                this.modalService.show(ConnectionInfoWithDownloadCsvComponent, { initialState });
            }
            else {
                const data = res.json ? yield res.json() : undefined;
                this.alertService.addServerFailure({ data, res });
            }
        });
    }
    delete(connection) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.connectorService.delete(connection);
                if (response.ok && response.status === 204) {
                    this.alertService.success(gettext('Connection deleted.'));
                    yield this.loadConnections();
                }
                else if (response && response.status === 500) {
                    const data = response.json ? yield response.json() : undefined;
                    const app = this.connectorService.getApplication('sigfox-agent');
                    const initialState = {
                        messageData: data,
                        appData: app,
                        modalTitle: gettext('Failed to delete the connection')
                    };
                    this.modalService.show(ConnectionInfoWithDownloadCsvComponent, { initialState });
                }
                else {
                    const data = response.json ? yield response.json() : undefined;
                    this.alertService.addServerFailure({ data, response });
                }
            }
            catch (error) {
                // empty catch block
            }
        });
    }
}
SigfoxMultipleLnsConnectorComponent.decorators = [
    { type: Component, args: [{
                selector: 'sigfox-multiple-lns-connector',
                template: "<ng-container *ngIf=\"state === 'loadingConnection'; else renderListAndForm\">\n  <c8y-loading></c8y-loading>\n</ng-container>\n<ng-template #renderListAndForm>\n  <no-connections-found\n    (onAction)=\"addConnection()\"\n    *ngIf=\"connections.length === 0 && state !== 'addConnections'\"\n    [header]=\"cardHeader | translate\"\n  >\n  </no-connections-found>\n  <div>\n    <div\n      class=\"card content-fullpage split-view--5-7\"\n      *ngIf=\"connections.length !== 0 || state === 'addConnections'\"\n    >\n      <div class=\"card-header separator grid__col--fullspan\">\n        <h4>{{ cardHeader | translate }}</h4>\n      </div>\n      <div class=\"inner-scroll split-view__list\">\n        <div class=\"bg-gray-white flex-grow\">\n          <c8y-list-group class=\"nav c8y-nav-stacked\">\n            <c8y-li\n              class=\"c8y-stacked-item p-0\"\n              [class.active]=\"connection.name === connection.name\"\n              *ngFor=\"let connection of connections; let index = index\"\n              (click)=\"setModel(connection)\"\n            >\n              <c8y-li-icon [icon]=\"'plug'\"></c8y-li-icon>\n              <span title=\"{{ connection.name }}\">\n                {{ connection.name }}\n              </span>\n            </c8y-li>\n\n            <c8y-li\n              *ngIf=\"state === 'addConnections'\"\n              class=\"c8y-nav-stacked active\"\n              (click)=\"addConnection()\"\n            >\n              <c8y-li-icon [icon]=\"'plug'\"></c8y-li-icon>\n              {{ 'New connection' | translate }}\n            </c8y-li>\n          </c8y-list-group>\n        </div>\n        <div class=\"card-footer separator-top\">\n          <button\n            [disabled]=\"state === 'addConnections'\"\n            title=\"{{ 'Add connection' | translate }}\"\n            class=\"btn btn-default\"\n            (click)=\"addConnection()\"\n          >\n            <i [c8yIcon]=\"'plus-circle'\"></i>\n            {{ 'Add connection' | translate }}\n          </button>\n        </div>\n      </div>\n\n      <!-- 'split-view__detail--selected' condition needs to be fixed. this is needed so that both columns are visible in tablet format -->\n\n      <div\n        class=\"inner-scroll split-view__detail\"\n        ng-class=\"{ 'split-view__detail--selected': vm.selected && vm.jsonSchemaObjects }\"\n      >\n        <div class=\"card-header separator visible-sm visible-xs fit-w sticky-top\">\n          <button\n            title=\"{{ 'Back' | translate }}\"\n            class=\"btn btn-clean text-primary\"\n            ng-click=\"vm.deselect()\"\n          >\n            <i [c8yIcon]=\"'chevron-left'\"></i>\n            <span>{{ 'Back' | translate }}</span>\n          </button>\n        </div>\n        <form #connectorsForm=\"ngForm\" class=\"d-contents\">\n          <div class=\"flex-grow\">\n            <div class=\"card-block large-padding\">\n              <c8y-form-group>\n                <label for=\"name\">\n                  {{ 'Name' | translate }}\n                </label>\n                <input\n                  type=\"text\"\n                  class=\"form-control\"\n                  [placeholder]=\"'e.g. Sigfox connection' | translate\"\n                  id=\"name\"\n                  name=\"name\"\n                  [(ngModel)]=\"connection.name\"\n                  required\n                />\n              </c8y-form-group>\n\n              <c8y-form-group>\n                <label for=\"description\">\n                  {{ 'Description' | translate }}\n                </label>\n                <input\n                  type=\"text\"\n                  class=\"form-control\"\n                  [placeholder]=\"'e.g. This connection has a built-in functionality to detect...' | translate\"\n                  id=\"description\"\n                  name=\"description\"\n                  [(ngModel)]=\"connection.description\"                  \n                />\n              </c8y-form-group>\n\n              <c8y-form-group>\n                <label for=\"baseUrl\">\n                  {{ 'URL' | translate }}\n                </label>\n                <input\n                  type=\"text\"\n                  class=\"form-control\"\n                  [placeholder]=\"\n                    'e.g. {{ example }}' | translate: { example: 'https://backend.sigfox.com/api' }\n                  \"\n                  id=\"baseUrl\"\n                  name=\"baseUrl\"\n                  [(ngModel)]=\"connection.baseUrl\"\n                  required\n                />\n              </c8y-form-group>\n              <c8y-form-group>\n                <label for=\"parentGroupId\">\n                  {{ 'Parent group ID' | translate }}\n                </label>\n                <input\n                  type=\"text\"\n                  class=\"form-control\"\n                  [placeholder]=\"'e.g. {{ example }}' | translate: { example: '58c1793b9e93a15370f71caa' }\"\n                  id=\"parentGroupId\"\n                  name=\"parentGroupId\"\n                  [(ngModel)]=\"connection.parentGroupId\"\n                  required\n                  pattern=\"[a-z\\d]+\"\n                />\n                <c8y-messages>\n                  <c8y-message\n                    name=\"pattern\"\n                    text=\"{{ 'Must be a valid Parent group ID' | translate }}\"\n                  ></c8y-message>\n                </c8y-messages>\n              </c8y-form-group>\n\n              <c8y-form-group>\n                <label for=\"username\">\n                  {{ 'Username' | translate }}\n                </label>\n                <input\n                  type=\"text\"\n                  class=\"form-control\"\n                  placeholder=\"{{ 'e.g. joe`LOCALIZE`' | translate }}\"\n                  id=\"username\"\n                  name=\"username\"\n                  [(ngModel)]=\"connection.username\"\n                  required\n                />\n              </c8y-form-group>\n              <c8y-form-group *ngIf=\"showPassword\">\n                <label for=\"password\">\n                  {{ 'Password' | translate }}\n                </label>\n                <input\n                  type=\"password\"\n                  class=\"form-control\"\n                  placeholder=\"{{ 'e.g. my_password' | translate }}\"\n                  id=\"password\"\n                  name=\"password\"\n                  [(ngModel)]=\"connection.password\"\n                  [required]=\"state === 'addConnections'\"\n                />\n              </c8y-form-group>\n\n              <button\n                *ngIf=\"state === 'updateConnection'\"\n                type=\"button\"\n                class=\"btn btn-default\"\n                name=\"changePassword\"\n                (click)=\"changePassword()\"\n              >\n                <span title=\"{{ 'Change password' | translate }}\" *ngIf=\"!showPassword\">{{\n                  'Change password' | translate\n                }}</span>\n                <span title=\"{{ 'Cancel password change' | translate }}\" *ngIf=\"showPassword\">{{\n                  'Cancel password change' | translate\n                }}</span>\n              </button>\n            </div>\n          </div>\n\n          <div class=\"card-footer separator-top\">\n            <button\n              title=\"{{ 'Cancel' | translate }}\"\n              class=\"btn btn-default\"\n              (click)=\"setModel()\"\n              translate\n              type=\"button\"\n            >\n              Cancel\n          </button>\n            <button\n              *ngIf=\"state === 'updateConnection'\"\n              title=\"{{ 'Delete' | translate }}\"\n              class=\"btn btn-danger\"\n              (click)=\"deleteConnection(connection)\"\n              translate\n              type=\"button\"\n            >\n              Delete\n          </button>\n            <button\n              [disabled]=\"!this.connectorsForm.form.valid || this.connectorsForm.form.pristine\"\n              title=\"{{ 'Save' | translate }}\"\n              class=\"btn btn-primary\"\n              (click)=\"save()\"\n              translate\n              type=\"submit\"\n            >\n              Save\n            </button>\n          </div>\n        </form>\n      </div>\n    </div>\n  </div>\n</ng-template>\n"
            },] }
];
SigfoxMultipleLnsConnectorComponent.ctorParameters = () => [
    { type: MultipleLnsConnectorService },
    { type: AlertService },
    { type: TranslateService },
    { type: BsModalService },
    { type: ModalService }
];
SigfoxMultipleLnsConnectorComponent.propDecorators = {
    connectorsForm: [{ type: ViewChild, args: ['connectorsForm', { static: false },] }]
};

class ActilityMultipleLnsConnectorComponent {
    constructor(connectorService, alertService, translateService, modal, modalService) {
        this.connectorService = connectorService;
        this.alertService = alertService;
        this.translateService = translateService;
        this.modal = modal;
        this.modalService = modalService;
        this.state = 'loadingConnection';
        this.connection = {};
        this.connections = Array();
        this.showPassword = false;
        this.cardHeader = gettext('Actility connections');
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.loadConnections();
        });
    }
    loadConnections() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.connectorService.list(ConnectionType.ACTILITY);
            if (res && res.status !== 200) {
                const data = res.json ? yield res.json() : undefined;
                this.alertService.addServerFailure({ data, res });
                this.state = 'loadingError';
            }
            else {
                const list = yield res.json();
                this.connections = orderBy(list, ['name'], ['asc']);
                yield this.setModel();
            }
        });
    }
    setModel(connectionObj = null) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.resetEditedUnsavedConnection();
            this.connection = connectionObj
                ? connectionObj
                : this.state === 'savedSuccessfully'
                    ? this.connection
                    : head(this.connections);
            this.state = 'updateConnection';
            this.showPassword = false;
            this.connectionBeingEdited = (this.connection) ? this.connection.name : undefined;
        });
    }
    setAdminAndCoreApiVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            this.connection.adminApiVersion = 'latest';
            this.connection.coreApiVersion = 'latest';
        });
    }
    resetEditedUnsavedConnection() {
        return __awaiter(this, void 0, void 0, function* () {
            const originalConnectionIndex = (!this.connection) ? 0 : findIndex(this.connections, { name: this.connectionBeingEdited });
            if (this.connectionBeingEdited && this.state === 'updateConnection') {
                const isConnectionExist = yield this.connectorService.detail(ConnectionType.ACTILITY, this.connectionBeingEdited);
                this.connections[originalConnectionIndex] = isConnectionExist;
            }
        });
    }
    addConnection() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.resetEditedUnsavedConnection();
            this.connection = {};
            this.connectionBeingEdited = '';
            this.state = 'addConnections';
            this.showPassword = true;
            yield this.setAdminAndCoreApiVersion();
        });
    }
    save() {
        return __awaiter(this, void 0, void 0, function* () {
            const checkForConnectionName = this.connectionBeingEdited !== '' ? this.connectionBeingEdited : this.connection.name;
            const isConnectionExist = yield this.connectorService.exists(ConnectionType.ACTILITY, checkForConnectionName);
            if (this.state === 'addConnections' && isConnectionExist) {
                const mesg = this.translateService.instant(gettext(`Connection with name "{{ name }}" already exists.`), { name: this.connection.name });
                this.alertService.danger(mesg);
            }
            else {
                this.saveConnection();
            }
        });
    }
    deleteConnection(connection) {
        return __awaiter(this, void 0, void 0, function* () {
            const mesg = this.translateService.instant(gettext(`You are about to delete the connection "{{ name }}". Do you want to proceed?`), { name: connection.name });
            try {
                yield this.modal.confirm(gettext('Delete connection'), mesg, Status.DANGER, {
                    ok: gettext('Delete'),
                    cancel: gettext('Cancel')
                });
                yield this.delete(connection);
            }
            catch (error) {
                // empty catch block
            }
        });
    }
    changePassword() {
        this.showPassword = !this.showPassword;
        if (this.connectorsForm.controls.password) {
            this.connectorsForm.controls.password.setValue(null);
        }
    }
    saveConnection() {
        return __awaiter(this, void 0, void 0, function* () {
            let res;
            res = yield this.connectorService.save(this.connection, this.connectionBeingEdited);
            if (res && (res.status === 201 || res.status === 200)) {
                this.state = 'savedSuccessfully';
                this.alertService.success(gettext('Connection saved.'));
                yield this.loadConnections();
            }
            else if (res && res.status === 500) {
                const data = res.json ? yield res.json() : undefined;
                const app = this.connectorService.getApplication('sigfox-agent');
                const initialState = {
                    messageData: data,
                    appData: app,
                    modalTitle: gettext('Failed to update the connection')
                };
                this.modalService.show(ConnectionInfoWithDownloadCsvComponent, { initialState });
            }
            else {
                const data = res.json ? yield res.json() : undefined;
                this.alertService.addServerFailure({ data, res });
            }
        });
    }
    delete(connection) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.connectorService.delete(connection);
                if (response.ok && response.status === 204) {
                    this.alertService.success(gettext('Connection deleted.'));
                    yield this.loadConnections();
                }
                else if (response && response.status === 500) {
                    const data = response.json ? yield response.json() : undefined;
                    const app = this.connectorService.getApplication('sigfox-agent');
                    const initialState = {
                        messageData: data,
                        appData: app,
                        modalTitle: gettext('Failed to delete the connection')
                    };
                    this.modalService.show(ConnectionInfoWithDownloadCsvComponent, { initialState });
                }
                else {
                    const data = response.json ? yield response.json() : undefined;
                    this.alertService.addServerFailure({ data, response });
                }
            }
            catch (error) {
                // empty catch block
            }
        });
    }
}
ActilityMultipleLnsConnectorComponent.decorators = [
    { type: Component, args: [{
                selector: 'actility-multiple-lns-connector',
                template: "<ng-container *ngIf=\"state === 'loadingConnection'; else renderListAndForm\">\n  <c8y-loading></c8y-loading>\n</ng-container>\n<ng-template #renderListAndForm>\n  <no-connections-found\n    (onAction)=\"addConnection()\"\n    *ngIf=\"connections.length === 0 && state !== 'addConnections'\"\n    [header]=\"cardHeader | translate\"\n  >\n  </no-connections-found>\n  <div>\n    <div\n      class=\"card content-fullpage split-view--5-7\"\n      *ngIf=\"connections.length !== 0 || state === 'addConnections'\"\n    >\n      <div class=\"card-header separator grid__col--fullspan\">\n        <h4>{{ cardHeader | translate }}</h4>\n      </div>\n      <div class=\"inner-scroll split-view__list\">\n        <div class=\"bg-gray-white flex-grow\">\n          <c8y-list-group class=\"nav c8y-nav-stacked\">\n            <c8y-li\n              class=\"c8y-stacked-item p-0\"\n              [class.active]=\"connection.name === connection.name\"\n              *ngFor=\"let connection of connections; let index = index\"\n              (click)=\"setModel(connection)\"\n            >\n              <c8y-li-icon [icon]=\"'plug'\"></c8y-li-icon>\n              <span title=\"{{ connection.name }}\">\n                {{ connection.name }}\n              </span>\n            </c8y-li>\n\n            <c8y-li\n              *ngIf=\"state === 'addConnections'\"\n              class=\"c8y-nav-stacked active\"\n              (click)=\"addConnection()\"\n            >\n              <c8y-li-icon [icon]=\"'plug'\"></c8y-li-icon>\n              {{ 'New connection' | translate }}\n            </c8y-li>\n          </c8y-list-group>\n        </div>\n        <div class=\"card-footer separator-top\">\n          <button\n            [disabled]=\"state === 'addConnections'\"\n            title=\"{{ 'Add connection' | translate }}\"\n            class=\"btn btn-default\"\n            (click)=\"addConnection()\"\n          >\n            <i [c8yIcon]=\"'plus-circle'\"></i>\n            {{ 'Add connection' | translate }}\n          </button>\n        </div>\n      </div>\n\n      <!-- 'split-view__detail--selected' condition needs to be fixed. this is needed so that both columns are visible in tablet format -->\n\n      <div\n        class=\"inner-scroll split-view__detail\"\n        ng-class=\"{ 'split-view__detail--selected': vm.selected && vm.jsonSchemaObjects }\"\n      >\n        <div class=\"card-header separator visible-sm visible-xs fit-w sticky-top\">\n          <button\n            title=\"{{ 'Back' | translate }}\"\n            class=\"btn btn-clean text-primary\"\n            ng-click=\"vm.deselect()\"\n          >\n            <i [c8yIcon]=\"'chevron-left'\"></i>\n            <span>{{ 'Back' | translate }}</span>\n          </button>\n        </div>\n        <form #connectorsForm=\"ngForm\" class=\"d-contents\">\n          <div class=\"flex-grow\">\n            <div class=\"card-block large-padding\">\n              <c8y-form-group>\n                <label for=\"name\">\n                  {{ 'Name' | translate }}\n                </label>\n                <input\n                  type=\"text\"\n                  class=\"form-control\"\n                  [placeholder]=\"'e.g. Actility connection' | translate\"                  \n                  id=\"name\"\n                  name=\"name\"\n                  [(ngModel)]=\"connection.name\"\n                  required\n                />\n              </c8y-form-group>\n\n              <c8y-form-group>\n                <label for=\"description\">\n                  {{ 'Description' | translate }}\n                </label>\n                <input\n                  type=\"text\"\n                  class=\"form-control\"\n                  [placeholder]=\"'e.g. This connection has a built-in functionality to detect...' | translate\"\n                  id=\"description\"\n                  name=\"description\"\n                  [(ngModel)]=\"connection.description\"                  \n                />\n              </c8y-form-group>\n\n              <c8y-form-group>\n                <label for=\"baseUrl\">\n                  {{ 'URL' | translate }}\n                </label>\n                <input\n                  type=\"text\"\n                  class=\"form-control\"\n                  [placeholder]=\"\n                    'e.g. {{ example }}' | translate: { example: 'https://dx-api.thingpark.io' }\n                  \"\n                  id=\"baseUrl\"\n                  name=\"baseUrl\"\n                  [(ngModel)]=\"connection.baseUrl\"\n                  required\n                />\n              </c8y-form-group>\n              <c8y-form-group>\n                <label for=\"profileId\">\n                  {{ 'Profile ID' | translate }}\n                </label>\n                <input\n                  type=\"text\"\n                  class=\"form-control\"\n                  [placeholder]=\"'e.g. {{ example }}' | translate: { example: 'dev1-api' }\"\n                  id=\"profileId\"\n                  name=\"profileId\"\n                  [(ngModel)]=\"connection.profileId\"\n                  required\n                />\n              </c8y-form-group>\n              <!-- DM-1171 start-->\n              <c8y-form-group>\n                <label for=\"applicationServerId\">\n                  {{ 'Application server ID' | translate }}\n                </label>\n                <input\n                  type=\"text\"\n                  class=\"form-control\"\n                  [placeholder]=\"'e.g. Application Server' | translate\"\n                  id=\"applicationServerId\"\n                  name=\"applicationServerId\"\n                  [(ngModel)]=\"connection.routeApplicationServerId\"\n                  [required]=\"connection.routeApplicationServerKey ? 'required' : null\"                  \n                />\n              </c8y-form-group>\n              <c8y-form-group>\n                <label for=\"applicationServerKey\">\n                  {{ 'Application server key' | translate }}\n                </label>\n                <input\n                  type=\"text\"\n                  class=\"form-control\"\n                  [placeholder]=\"'e.g. {{ example }}' | translate: { example: '0011AEDF0011AEDF0011AEDF0011AEDF' }\"\n                  id=\"applicationServerKey\"\n                  name=\"applicationServerKey\"\n                  [(ngModel)]=\"connection.routeApplicationServerKey\"\n                  [required]=\"connection.routeApplicationServerId ? 'required' : null\"\n                  pattern=\"[A-Fa-f0-9]{32}\"\n                />\n                <c8y-messages>\n                  <c8y-message\n                    name=\"pattern\"\n                    text=\"{{ 'Must be a valid server key' | translate }}\"\n                  ></c8y-message>\n                </c8y-messages>\n              </c8y-form-group>\n              <c8y-form-group>\n                <label for=\"adminApiVersion\">\n                  {{ 'Admin API version' | translate }}\n                </label>\n                <input\n                  type=\"text\"\n                  class=\"form-control\"\n                  [placeholder]=\"'e.g. {{ example }}' | translate: { example: 'v102' }\"\n                  id=\"adminApiVersion\"\n                  name=\"adminApiVersion\"\n                  [(ngModel)]=\"connection.adminApiVersion\"\n                  required\n                  pattern=\"^v\\d+$|latest\"\n                />\n                <c8y-messages>\n                  <c8y-message\n                    name=\"pattern\"\n                    text=\"{{ 'Must be a valid API version' | translate }}\"\n                  ></c8y-message>\n                </c8y-messages>\n              </c8y-form-group>\n              \n              <c8y-form-group>\n                <label for=\"coreApiVersion\">\n                  {{ 'Core API version' | translate }}\n                </label>                \n                <input\n                  type=\"text\"\n                  class=\"form-control\"\n                  [placeholder]=\"'e.g. {{ example }}' | translate: { example: 'v121' }\"\n                  id=\"coreApiVersion\"\n                  name=\"coreApiVersion\"\n                  [(ngModel)]=\"connection.coreApiVersion\"\n                  required\n                  pattern=\"^v\\d+$|latest\"\n                />\n                <c8y-messages>\n                  <c8y-message\n                    name=\"pattern\"\n                    text=\"{{ 'Must be a valid API version' | translate }}\"\n                  ></c8y-message>\n                </c8y-messages>\n              </c8y-form-group>\n              <!-- DM-1171 end-->\n              <c8y-form-group>\n                <label for=\"username\">\n                  {{ 'Username' | translate }}\n                </label>\n                <input\n                  type=\"text\"\n                  class=\"form-control\"\n                  placeholder=\"{{ 'e.g. joe`LOCALIZE`' | translate }}\"\n                  id=\"username\"\n                  name=\"username\"\n                  [(ngModel)]=\"connection.username\"\n                  required\n                />\n              </c8y-form-group>\n\n              <c8y-form-group *ngIf=\"showPassword\">\n                <label for=\"password\">\n                  {{ 'Password' | translate }}\n                </label>\n                <input\n                  type=\"password\"\n                  class=\"form-control\"\n                  placeholder=\"{{ 'e.g. my_password' | translate }}\"\n                  id=\"password\"\n                  name=\"password\"\n                  [(ngModel)]=\"connection.password\"\n                  [required]=\"state === 'addConnections'\"\n                />\n              </c8y-form-group>\n              <button\n                *ngIf=\"state === 'updateConnection'\"\n                type=\"button\"\n                class=\"btn btn-default\"\n                name=\"changePassword\"\n                (click)=\"changePassword()\"\n              >\n                <span title=\"{{ 'Change password' | translate }}\" *ngIf=\"!showPassword\">{{\n                  'Change password' | translate\n                }}</span>\n                <span title=\"{{ 'Cancel password change' | translate }}\" *ngIf=\"showPassword\">{{\n                  'Cancel password change' | translate\n                }}</span>\n              </button>\n            </div>\n          </div>\n\n          <div class=\"card-footer separator-top\">\n            <button\n              title=\"{{ 'Cancel' | translate }}\"\n              class=\"btn btn-default\"\n              (click)=\"setModel()\"\n              translate\n              type=\"button\"\n            >\n              Cancel\n            </button>\n            <button\n              *ngIf=\"state === 'updateConnection'\"\n              title=\"{{ 'Delete' | translate }}\"\n              class=\"btn btn-danger\"\n              (click)=\"deleteConnection(connection)\"\n              translate\n              type=\"button\"\n            >\n              Delete\n            </button>\n            <button\n              [disabled]=\"!this.connectorsForm.form.valid || this.connectorsForm.form.pristine\"\n              title=\"{{ 'Save' | translate }}\"\n              class=\"btn btn-primary\"\n              (click)=\"save()\"\n              translate\n              type=\"submit\"\n            >\n              Save\n            </button>\n          </div>\n        </form>\n      </div>\n    </div>\n  </div>\n</ng-template>\n"
            },] }
];
ActilityMultipleLnsConnectorComponent.ctorParameters = () => [
    { type: MultipleLnsConnectorService },
    { type: AlertService },
    { type: TranslateService },
    { type: ModalService },
    { type: BsModalService }
];
ActilityMultipleLnsConnectorComponent.propDecorators = {
    connectorsForm: [{ type: ViewChild, args: ['connectorsForm', { static: false },] }]
};

const settingsRoutes = [
    {
        path: 'connectivitySettings/multiple_lns_connectors_sigfox',
        component: SigfoxMultipleLnsConnectorComponent
    },
    {
        path: 'connectivitySettings/multiple_lns_connectors_actility',
        component: ActilityMultipleLnsConnectorComponent
    }
];
class MultipleLnsConnectorsModule {
}
MultipleLnsConnectorsModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    SigfoxMultipleLnsConnectorComponent,
                    NoConnectionsFoundComponent,
                    ActilityMultipleLnsConnectorComponent,
                    ConnectionInfoWithDownloadCsvComponent
                ],
                imports: [
                    CoreModule,
                    CommonModule,
                    FormsModule,
                    RouterModule.forChild(settingsRoutes)
                ],
                providers: [
                    MultipleLnsConnectorService
                ]
            },] }
];

class LpwanSetDeviceProtocolService {
    constructor(inventoryService, client, identityService, lnsService) {
        this.inventoryService = inventoryService;
        this.client = client;
        this.identityService = identityService;
        this.lnsService = lnsService;
        this.supportedDevicesCfgs = [
            {
                name: 'lora',
                match: device => get(device, 'c8y_LpwanDevice.lpwanDeviceType') === 'Lora',
                protocolTypes: ['c8y_ActilityDeviceType', 'c8y_LoraDeviceType', 'c8y_LpwanDeviceType'],
                externalIdTypes: ['c8y_LoriotEUI', 'c8y_Serial'],
                connectionType: ConnectionType.ACTILITY
            },
            {
                name: 'sigfox',
                match: device => get(device, 'c8y_LpwanDevice.serviceProvider') === 'Sigfox',
                protocolTypes: ['c8y_SigfoxDeviceType', 'c8y_LpwanDeviceType'],
                externalIdTypes: ['com.sigfox.deviceId'],
                connectionType: ConnectionType.SIGFOX
            }
        ];
        this.header = { 'Content-Type': 'application/json' };
    }
    refreshCache(device) {
        return __awaiter(this, void 0, void 0, function* () {
            const externalId = yield this.getExternalId(device);
            if (externalId) {
                const url = `${this.getMicroserviceUrl(device)}/refreshCache/${externalId}`;
                const options = {
                    method: 'POST',
                    headers: this.header,
                    body: JSON.stringify({})
                };
                return this.client.fetch(url, options);
            }
        });
    }
    getMicroserviceUrl(device) {
        const { serviceProvider } = device.c8y_LpwanDevice;
        let serviceName = serviceProvider.toLowerCase();
        if (serviceProvider === 'Sigfox') {
            serviceName = 'sigfox-agent';
        }
        return `/service/${serviceName}`;
    }
    isSupportedDevice(device) {
        return this.supportedDevicesCfgs.some(({ match }) => match(device));
    }
    getCurrentProtocol(device) {
        return __awaiter(this, void 0, void 0, function* () {
            const lpwanDevice = device.c8y_LpwanDevice;
            let protocolId;
            if (lpwanDevice.typeExternalId) {
                const externalId = (yield this.identityService.detail(lpwanDevice.typeExternalId)).data;
                protocolId = externalId.managedObject.id;
            }
            if (!protocolId && lpwanDevice.type) {
                protocolId = lpwanDevice.type.split('/')[2];
            }
            if (!protocolId) {
                return null;
            }
            return (yield this.inventoryService.detail(protocolId)).data;
        });
    }
    applyProtocol(device, selectedProtocol) {
        return __awaiter(this, void 0, void 0, function* () {
            const [protocolExternalId] = (yield this.identityService.list(selectedProtocol.id)).data;
            const { externalId, type } = protocolExternalId;
            device.c8y_LpwanDevice.typeExternalId = { externalId, type };
            device.c8y_LpwanDevice.type = 'inventory/managedObjects/' + selectedProtocol.id;
            device.type = selectedProtocol.name;
            return this.inventoryService.update(device);
        });
    }
    getAvailableProtocols(device) {
        return __awaiter(this, void 0, void 0, function* () {
            const query = {
                __filter: {
                    type: { __in: this.getProtocolTypesMatchingDevice(device) }
                },
                __orderby: [{ name: 1 }]
            };
            return this.inventoryService.listQuery(query, { withTotalPages: true, pageSize: 5 });
        });
    }
    getAvailableConnections(device) {
        return __awaiter(this, void 0, void 0, function* () {
            let list;
            const matchingCfg = this.supportedDevicesCfgs.find(({ match }) => match(device));
            const response = yield this.lnsService.list(matchingCfg.connectionType);
            if (response && response.status === 200) {
                list = yield response.json();
                list = orderBy(list, ['name'], ['asc']);
                return { res: response, data: list };
            }
        });
    }
    getProtocolTypesMatchingDevice(device) {
        const matchingCfg = this.supportedDevicesCfgs.find(({ match }) => match(device));
        return matchingCfg ? matchingCfg.protocolTypes : [];
    }
    getExternalId(device) {
        return __awaiter(this, void 0, void 0, function* () {
            const matchingCfg = this.supportedDevicesCfgs.find(({ match }) => match(device));
            const externalIds = (yield this.identityService.list(device.id)).data;
            const externalId = externalIds.find(({ type }) => matchingCfg.externalIdTypes.includes(type));
            return externalId ? externalId.externalId : null;
        });
    }
}
LpwanSetDeviceProtocolService.decorators = [
    { type: Injectable }
];
LpwanSetDeviceProtocolService.ctorParameters = () => [
    { type: InventoryService },
    { type: FetchClient },
    { type: IdentityService },
    { type: MultipleLnsConnectorService }
];

class LpwanAssignDeviceProtocolComponent {
    constructor(lpwanService, alertService, router, inventoryService) {
        this.lpwanService = lpwanService;
        this.alertService = alertService;
        this.router = router;
        this.inventoryService = inventoryService;
        this.filterProtocols = pipe();
        this.pattern = '';
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.reload();
            this.setPipe('');
        });
    }
    setPipe(filterStr) {
        this.pattern = filterStr;
        this.filterProtocols = pipe(map((protocols) => protocols.filter(protocol => (!this.currentProtocol || this.currentProtocol.id !== protocol.id) &&
            (!filterStr || protocol.name.toLowerCase().indexOf(filterStr.toLowerCase()) > -1))));
    }
    reload() {
        return __awaiter(this, void 0, void 0, function* () {
            this.loading = true;
            this.newProtocol = null;
            try {
                yield this.loadDevice();
                this.availableProtocols = yield this.lpwanService.getAvailableProtocols(this.device);
                this.currentProtocol = yield this.lpwanService.getCurrentProtocol(this.device);
            }
            catch (ex) {
                this.alertService.addServerFailure(ex);
            }
            finally {
                this.loading = false;
            }
        });
    }
    loadDevice() {
        return __awaiter(this, void 0, void 0, function* () {
            const deviceId = this.router.routerState.snapshot.url.match(/\d+/)[0];
            const { data } = yield this.inventoryService.detail(deviceId);
            this.device = data;
        });
    }
    apply(selectedProtocol) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const moUpdated = (yield this.lpwanService.applyProtocol(this.device, selectedProtocol))
                    .res.status === 200;
                yield this.reload();
                this.alertService.success(gettext('Device protocol set.'));
                this.lpwanSetDeviceProtocolForm.reset('dirty');
                if (moUpdated) {
                    this.refreshCache();
                }
            }
            catch (ex) {
                this.alertService.danger(gettext('Could not set device protocol.'));
            }
        });
    }
    refreshCache() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.lpwanService.refreshCache(this.device);
            }
            catch (ex) {
                // do nothing (refreshing is an optional step)
            }
        });
    }
}
LpwanAssignDeviceProtocolComponent.decorators = [
    { type: Component, args: [{
                selector: 'set-device-protocol',
                template: "<form #lpwanSetDeviceProtocolForm=\"ngForm\">\n  <div class=\"row\">\n    <div class=\"col-md-9\">\n      <div class=\"card card--fullpage\">\n        <div class=\"card-header separator\">\n          <h4 class=\"card-title\">\n            {{ 'LPWAN configuration' | translate }}\n          </h4>\n        </div>\n\n        <div class=\"card-block p-t-24 p-b-8 overflow-visible\">\n          <div *ngIf=\"loading\">\n            <c8y-loading></c8y-loading>\n          </div>\n\n          <div *ngIf=\"!loading\">\n            <div class=\"col-md-6\">\n              <div class=\"form-group\">\n                <label translate>Current device protocol</label>\n                <p class=\"form-control-static\" *ngIf=\"!currentProtocol\">\n                  {{ device.type }}\n                </p>\n                <p\n                  class=\"form-control-static text-truncate\"\n                  *ngIf=\"currentProtocol\"\n                  [title]=\"currentProtocol.name\"\n                >\n                  {{ currentProtocol.name }}\n                </p>\n              </div>\n              <c8y-form-group>\n                <c8y-typeahead\n                  [(ngModel)]=\"newProtocol\"\n                  placeholder=\"{{ 'Select new device protocol' | translate }}\"\n                  (onSearch)=\"setPipe($event)\"\n                  name=\"newProtocol\"\n                  [allowFreeEntries]=\"false\"\n                >\n                  <c8y-li\n                    *c8yFor=\"\n                      let protocol of availableProtocols;\n                      loadMore: 'hidden';\n                      pipe: filterProtocols\n                    \"\n                    class=\"p-l-8 p-r-8 c8y-list__item--link\"\n                    (click)=\"newProtocol = protocol; setPipe('')\"\n                  >\n                    <c8y-highlight [text]=\"protocol.name\" [pattern]=\"pattern\"></c8y-highlight>\n                  </c8y-li>\n                </c8y-typeahead>\n                <c8y-messages>\n                  <c8y-message\n                    name=\"notExisting\"\n                    [text]=\"'Select one of the protocols.' | translate\"\n                  ></c8y-message>\n                </c8y-messages>\n              </c8y-form-group>\n            </div>\n            <set-lns-connections\n              *ngIf=\"device.c8y_LpwanDevice.serviceProvider != 'Loriot'\"\n              [device]=\"device\"\n            ></set-lns-connections>\n          </div>\n        </div>\n\n        <div class=\"card-footer separator\">\n          <button\n            title=\"{{ 'Save' | translate }}\"\n            class=\"btn btn-primary\"\n            (click)=\"apply(newProtocol)\"\n            [disabled]=\"!newProtocol\"\n          >\n            {{ 'Save' | translate }}\n          </button>\n        </div>\n      </div>\n    </div>\n  </div>\n</form>\n\u200C\n"
            },] }
];
LpwanAssignDeviceProtocolComponent.ctorParameters = () => [
    { type: LpwanSetDeviceProtocolService },
    { type: AlertService },
    { type: Router },
    { type: InventoryService }
];
LpwanAssignDeviceProtocolComponent.propDecorators = {
    lpwanSetDeviceProtocolForm: [{ type: ViewChild, args: ['lpwanSetDeviceProtocolForm', { static: false },] }]
};

class LpwanAgentGuard {
    constructor(lpwanService) {
        this.lpwanService = lpwanService;
    }
    canActivate(route) {
        const device = route.data.contextData || route.parent.data.contextData;
        return this.lpwanService.isSupportedDevice(device);
    }
}
LpwanAgentGuard.decorators = [
    { type: Injectable }
];
LpwanAgentGuard.ctorParameters = () => [
    { type: LpwanSetDeviceProtocolService }
];

class LpwanAssignLnsConnectionsComponent {
    constructor(lpwanService, alertService) {
        this.lpwanService = lpwanService;
        this.alertService = alertService;
        this.buttons = [
            { label: gettext('Cancel'), action: () => Promise.reject() },
            { label: gettext('Re-register'), action: () => this.deviceReregister(), status: 'default' }
        ];
        this.reRegisterMsg = gettext('To change provider connection, you need to re-register device first.');
        this.filterConnection = pipe();
        this.pattern = '';
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.reload();
            this.setConnectionPipe('');
        });
    }
    setConnectionPipe(filterStr) {
        this.pattern = filterStr;
        this.filterConnection = pipe(map((connections) => connections.filter(connection => (!this.currentConnection || this.currentConnection.name !== connection.name) &&
            (!filterStr || connection.name.toLowerCase().indexOf(filterStr.toLowerCase()) > -1))));
    }
    reload() {
        return __awaiter(this, void 0, void 0, function* () {
            this.loading = true;
            this.newConnection = null;
            try {
                this.availableConnections = yield this.lpwanService.getAvailableConnections(this.device);
                this.currentConnection = find(this.availableConnections.data, {
                    name: this.device.c8y_LpwanDevice.lnsConnectionName
                });
            }
            catch (ex) {
                this.alertService.addServerFailure(ex);
            }
            finally {
                this.loading = false;
            }
        });
    }
    togglePopover(popoverCfrm) {
        popoverCfrm.show();
        this.setConnectionPipe('');
    }
    deviceReregister() {
        return new Promise((resolve, reject) => {
            window.location.href = `#/deviceregistration`;
            resolve(true);
        });
    }
}
LpwanAssignLnsConnectionsComponent.decorators = [
    { type: Component, args: [{
                selector: 'set-lns-connections',
                template: "<div class=\"col-md-6\">\n  <div class=\"form-group\">\n    <label translate>Current connection</label>\n    <p class=\"form-control-static\" *ngIf=\"!currentConnection\">\n      {{ 'Connection is not set. Select connection for this device' | translate }}\n    </p>\n    <p class=\"form-control-static  text-truncate\" *ngIf=\"currentConnection\" title=\"{{ currentConnection.name }}\">\n      {{ currentConnection.name }}\n    </p>\n  </div>\n\n  <c8y-form-group>\n    <c8y-popover-confirm\n      outsideClick=\"true\"\n      containerClass=\"lns-connection-popover\"\n      [message]=\"reRegisterMsg\"\n      [buttons]=\"buttons\"\n      [placement]=\"'bottom'\"\n    ></c8y-popover-confirm>\n    <c8y-typeahead\n      *ngIf=\"!loading\"\n      [(ngModel)]=\"newConnection\"\n      placeholder=\"{{ 'Select new connection' | translate }}\"\n      name=\"newConnection\"\n      (onSearch)=\"setConnectionPipe($event)\"\n      [allowFreeEntries]=\"false\"\n    >\n      <c8y-li\n        *c8yFor=\"let connection of availableConnections; loadMore: 'hidden'; pipe: filterConnection\"\n        class=\"p-l-8 p-r-8 c8y-list__item--link\"\n        (click)=\"togglePopover(popoverConfirm)\"\n      >\n        <c8y-highlight [text]=\"connection.name\" [pattern]=\"pattern\"></c8y-highlight>\n      </c8y-li>\n    </c8y-typeahead>\n    <c8y-messages\n      ><c8y-message\n        name=\"notExisting\"\n        [text]=\"'Select one of the connections.' | translate\"\n      ></c8y-message>\n    </c8y-messages>\n  </c8y-form-group>\n</div>\n"
            },] }
];
LpwanAssignLnsConnectionsComponent.ctorParameters = () => [
    { type: LpwanSetDeviceProtocolService },
    { type: AlertService }
];
LpwanAssignLnsConnectionsComponent.propDecorators = {
    device: [{ type: Input }],
    popoverConfirm: [{ type: ViewChild, args: [PopoverConfirmComponent, { static: true },] }]
};

const routes = [
    {
        context: ViewContext.Device,
        path: 'assign-protocol',
        component: LpwanAssignDeviceProtocolComponent,
        label: gettext('LPWAN'),
        icon: 'c8y-device-protocols',
        canActivate: [LpwanAgentGuard]
    }
];
const ɵ0 = routes;
class LpwanProtocolModule {
}
LpwanProtocolModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    LpwanAssignDeviceProtocolComponent,
                    LpwanAssignLnsConnectionsComponent
                ],
                imports: [
                    CoreModule,
                    FormsModule
                ],
                entryComponents: [LpwanAssignDeviceProtocolComponent, LpwanAssignLnsConnectionsComponent],
                providers: [
                    LpwanAgentGuard,
                    LpwanSetDeviceProtocolService,
                    {
                        provide: HOOK_ROUTE,
                        useValue: ɵ0,
                        multi: true
                    }
                ]
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { LpwanAssignDeviceProtocolComponent, LpwanProtocolModule, MultipleLnsConnectorsModule, ɵ0, LpwanSetDeviceProtocolService as ɵa, MultipleLnsConnectorService as ɵb, LpwanAssignLnsConnectionsComponent as ɵc, LpwanAgentGuard as ɵd, SigfoxMultipleLnsConnectorComponent as ɵe, MultipleLnsConnectorService as ɵf, NoConnectionsFoundComponent as ɵg, ActilityMultipleLnsConnectorComponent as ɵh, ConnectionInfoWithDownloadCsvComponent as ɵi };
//# sourceMappingURL=c8y-ngx-components-protocol-lpwan.js.map
