import { EventEmitter, Component, Directive, ElementRef, Injector, Output, NgModule, Injectable } from '@angular/core';
import { BsModalRef, BsModalService } from 'ngx-bootstrap/modal';
import { UpgradeComponent } from '@angular/upgrade/static';
import { gettext, OptionsService, OperationRealtimeService, ManagedObjectRealtimeService, AlertService, CoreModule, ViewContext, HOOK_ROUTE } from '@c8y/ngx-components';
import { __awaiter } from 'tslib';
import { ActivatedRoute } from '@angular/router';
import { OperationService } from '@c8y/client';
import { isEmpty, includes } from 'lodash-es';
import { of, BehaviorSubject, pipe, Subject } from 'rxjs';
import { map, startWith, takeUntil, filter } from 'rxjs/operators';
import { CommonModule } from '@angular/common';
import { OperationsTimelineModule } from '@c8y/ngx-components/operations/operations-timeline';

/* https://stackoverflow.com/a/65290658 */
function rootScopeFactory($injector) {
    return $injector.get('$rootScope').$new();
}
class CommandTemplatesComponent {
    constructor(modalRef) {
        this.modalRef = modalRef;
        this.onTemplateSelected = new EventEmitter();
    }
}
CommandTemplatesComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-command-templates',
                template: `<c8y-command-templates-directive
    (close)="modalRef.hide(); onTemplateSelected.next($event)"
    (dismiss)="modalRef.hide()"
  ></c8y-command-templates-directive>`,
                providers: [
                    {
                        deps: ['$injector'],
                        provide: '$scope',
                        useFactory: rootScopeFactory
                    }
                ]
            },] }
];
CommandTemplatesComponent.ctorParameters = () => [
    { type: BsModalRef }
];

class CommandTemplates extends UpgradeComponent {
    constructor(elementRef, injector) {
        super('c8yCommandTemplates', elementRef, injector);
    }
}
CommandTemplates.decorators = [
    { type: Directive, args: [{
                selector: 'c8y-command-templates-directive'
            },] }
];
CommandTemplates.ctorParameters = () => [
    { type: ElementRef },
    { type: Injector }
];
CommandTemplates.propDecorators = {
    close: [{ type: Output }],
    dismiss: [{ type: Output }]
};

class CommandTemplatesModule {
}
CommandTemplatesModule.decorators = [
    { type: NgModule, args: [{
                declarations: [CommandTemplates, CommandTemplatesComponent],
                exports: [CommandTemplatesComponent]
            },] }
];

class DeviceShellGuard {
    constructor() {
        this.operation = 'c8y_Command';
    }
    canActivate(route) {
        const device = route.data.contextData || route.parent.data.contextData;
        const supportedOperations = (device && device.c8y_SupportedOperations) || [];
        return supportedOperations.indexOf(this.operation) >= 0;
    }
}
DeviceShellGuard.decorators = [
    { type: Injectable }
];

var CommandDeliveryType;
(function (CommandDeliveryType) {
    CommandDeliveryType["DEFAULT"] = "Default";
    CommandDeliveryType["SMS"] = "SMS";
})(CommandDeliveryType || (CommandDeliveryType = {}));

class DeviceShellService {
    constructor(optionsService, operationService) {
        this.optionsService = optionsService;
        this.operationService = operationService;
    }
    getDeliveryTypes() {
        return [
            {
                name: gettext(CommandDeliveryType.DEFAULT),
                default: true
            },
            {
                name: gettext(CommandDeliveryType.SMS)
            }
        ];
    }
    canSendCommandsViaSMS() {
        return this.optionsService.getSystemOption('messaging', 'provider', false);
    }
    createCommandOperation(deviceId, command, deliveryType) {
        const operation = {
            deviceId,
            description: gettext('Execute shell command') + (command.name ? `: ${command.name}` : ''),
            deliveryType: deliveryType === CommandDeliveryType.SMS ? CommandDeliveryType.SMS : undefined,
            c8y_Command: {
                text: command.text
            }
        };
        return this.operationService.create(operation);
    }
}
DeviceShellService.decorators = [
    { type: Injectable }
];
DeviceShellService.ctorParameters = () => [
    { type: OptionsService },
    { type: OperationService }
];

class DeviceShellSharedModule {
}
DeviceShellSharedModule.decorators = [
    { type: NgModule, args: [{
                providers: [DeviceShellService]
            },] }
];

class DeviceShellComponent {
    constructor(service, operationRealtime, moRealtime, operationService, route, modalService, alertService) {
        this.service = service;
        this.operationRealtime = operationRealtime;
        this.moRealtime = moRealtime;
        this.operationService = operationService;
        this.route = route;
        this.modalService = modalService;
        this.alertService = alertService;
        this.device = this.route.snapshot.parent.data.contextData;
        this.device$ = of({});
        this.deliveryTypes = (this.service.getDeliveryTypes() || []).map(deliveryType => (Object.assign(Object.assign({}, deliveryType), { isSupportedByCommand: true })));
        this.command = {};
        this.smsEnabled = false;
        this.sendingCommand$ = new BehaviorSubject(false);
        this.filterPipe = pipe(map((operations) => (operations || []).filter((operation) => !!operation.c8y_Command)));
        this.executeViaLabel = gettext('Execute via ({{deliveryType}})');
        this.destroyed$ = new Subject();
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.smsEnabled = yield this.service.canSendCommandsViaSMS();
            this.device$ = this.moRealtime.onUpdate$(this.device.id).pipe(startWith(this.device));
            this.operations = yield this.operationService.list({
                deviceId: this.device.id,
                fragmentType: 'c8y_Command',
                dateFrom: new Date(0).toISOString(),
                dateTo: new Date().toISOString(),
                pageSize: 50,
                withTotalPages: true,
                revert: true
            });
            this.operationRealtime
                .onCreate$(this.device.id)
                .pipe(takeUntil(this.destroyed$))
                .subscribe(() => this.alertService.success(gettext('Command sent.')));
            this.operationRealtime
                .onUpdate$(this.device.id)
                .pipe(filter(op => op.failureReason !== 'Operation cancelled by user.'), // avoid duplicate alerts
            takeUntil(this.destroyed$))
                .subscribe(() => this.alertService.success(gettext('Command status updated.')));
        });
    }
    getPredefinedCommand() {
        const modal = this.modalService.show(CommandTemplatesComponent);
        modal.content.onTemplateSelected.pipe(takeUntil(this.destroyed$)).subscribe(result => {
            this.command = Object.assign({}, result.commandTemplate);
            this.deliveryTypes = this.deliveryTypes.map(deliveryType => (Object.assign(Object.assign({}, deliveryType), { isSupportedByCommand: isEmpty(this.command.deliveryTypes) ||
                    includes(this.command.deliveryTypes, deliveryType.name) })));
        });
    }
    resetSupportedDeliveryTypes() {
        this.deliveryTypes = (this.service.getDeliveryTypes() || []).map(deliveryType => (Object.assign(Object.assign({}, deliveryType), { isSupportedByCommand: true })));
    }
    execute(commandDeliveryType) {
        return __awaiter(this, void 0, void 0, function* () {
            const useSMS = commandDeliveryType === CommandDeliveryType.SMS;
            if (useSMS && !this.smsEnabled) {
                this.alertService.warning(gettext('SMS transport is not configured.'));
                return;
            }
            this.sendingCommand$.next(true);
            yield this.service.createCommandOperation(this.device.id, this.command, commandDeliveryType);
            this.command.text = '';
            this.resetSupportedDeliveryTypes();
            this.sendingCommand$.next(false);
        });
    }
    ngOnDestroy() {
        this.destroyed$.next();
        this.destroyed$.complete();
    }
}
DeviceShellComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-device-shell',
                template: "<c8y-action-bar-item [placement]=\"'right'\">\n  <c8y-realtime-btn [service]=\"operationRealtime\"></c8y-realtime-btn>\n</c8y-action-bar-item>\n\n<div class=\"card content-fullpage d-grid grid__col--6-6--md\">\n  <div class=\"inner-scroll d-flex d-col bg-white\">\n    <div class=\"card-header large-padding separator sticky-top\">\n      <h4 class=\"card-title\">\n        {{ 'Command' | translate }}\n      </h4>\n    </div>\n\n    <div class=\"card-block d-flex d-col flex-grow large-padding\">\n      <div class=\"flex-row p-b-16\">\n        <button\n          class=\"btn btn-default btn-sm\"\n          type=\"button\"\n          (click)=\"getPredefinedCommand()\"\n          [title]=\"'Display a list of predefined commands' | translate\"\n        >\n          {{ 'Predefined commands' | translate }}\n        </button>\n\n        <div class=\"flex-item-right\">\n          <device-status [mo]=\"device$ | async\"></device-status>\n        </div>\n      </div>\n      <textarea\n        class=\"form-control inner-scroll flex-grow bg-gray-lighter\"\n        [(ngModel)]=\"command.text\"\n        (ngModelChange)=\"$event || resetSupportedDeliveryTypes()\"\n      >\n      </textarea>\n    </div>\n\n    <div class=\"card-footer large-padding separator\">\n      <ng-container *ngFor=\"let deliveryType of deliveryTypes\">\n        <button\n          class=\"btn btn-primary\"\n          type=\"button\"\n          *ngIf=\"deliveryType.isSupportedByCommand\"\n          [disabled]=\"!command?.text || (sendingCommand$ | async)\"\n          (click)=\"execute(deliveryType.name)\"\n        >\n          <span\n            [title]=\"\n              deliveryType.default\n                ? ('Execute' | translate)\n                : (executeViaLabel | translate: { deliveryType: deliveryType.name })\n            \"\n          >\n            {{\n              deliveryType.default\n                ? ('Execute' | translate)\n                : (executeViaLabel | translate: { deliveryType: deliveryType.name })\n            }}\n          </span>\n        </button>\n      </ng-container>\n    </div>\n  </div>\n  <div class=\"inner-scroll bg-gray-white\">\n    <div class=\"card-header large-padding separator sticky-top\">\n      <h4 class=\"card-title\">\n        {{ 'Operations' | translate }}\n      </h4>\n    </div>\n    <div class=\"card-block large-padding\">\n      <c8y-operations-timeline\n        [operations]=\"operations\"\n        [sourceId]=\"device.id\"\n        [filterPipe]=\"filterPipe\"\n        [bodyTemplate]=\"timelineItemBody\"\n        [footerTemplates]=\"[timelineItemFooter]\"\n        [propertiesToHide]=\"['c8y_Command']\"\n      ></c8y-operations-timeline>\n      <ng-template #timelineItemBody let-operation>\n        <small>{{ operation.c8y_Command?.text || operation.description }}</small>\n      </ng-template>\n      <ng-template #timelineItemFooter let-operation>\n        <div *ngIf=\"operation.c8y_Command?.text\">\n          <div class=\"legend form-block\" translate>Command</div>\n          <pre class=\"text-pre-normal\">\n              <code>{{operation.c8y_Command.text}}</code>\n          </pre>\n        </div>\n        <div *ngIf=\"operation.c8y_Command?.result\">\n          <div class=\"legend form-block\" translate>Response</div>\n          <pre class=\"text-pre-normal\">\n              <code>{{operation.c8y_Command.result}}</code>\n          </pre>\n        </div>\n      </ng-template>\n    </div>\n  </div>\n</div>\n",
                providers: [OperationRealtimeService, ManagedObjectRealtimeService]
            },] }
];
DeviceShellComponent.ctorParameters = () => [
    { type: DeviceShellService },
    { type: OperationRealtimeService },
    { type: ManagedObjectRealtimeService },
    { type: OperationService },
    { type: ActivatedRoute },
    { type: BsModalService },
    { type: AlertService }
];

class ShellModule {
}
ShellModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    CoreModule,
                    OperationsTimelineModule,
                    CommandTemplatesModule,
                    DeviceShellSharedModule
                ],
                declarations: [DeviceShellComponent],
                exports: [DeviceShellComponent]
            },] }
];

const DEVICE_SHELL_ROUTE = {
    path: 'shell',
    context: ViewContext.Device,
    component: DeviceShellComponent,
    label: gettext('Shell'),
    icon: 'terminal',
    canActivate: [DeviceShellGuard]
};
const ɵ0 = DEVICE_SHELL_ROUTE;
class DeviceShellModule {
}
DeviceShellModule.decorators = [
    { type: NgModule, args: [{
                imports: [ShellModule],
                providers: [
                    DeviceShellGuard,
                    {
                        provide: HOOK_ROUTE,
                        useValue: ɵ0,
                        multi: true
                    }
                ]
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { CommandDeliveryType, CommandTemplates, CommandTemplatesComponent, CommandTemplatesModule, DeviceShellComponent, DeviceShellGuard, DeviceShellModule, DeviceShellService, DeviceShellSharedModule, ShellModule, rootScopeFactory, ɵ0, ShellModule as ɵa, DeviceShellComponent as ɵb };
//# sourceMappingURL=c8y-ngx-components-device-shell.js.map
