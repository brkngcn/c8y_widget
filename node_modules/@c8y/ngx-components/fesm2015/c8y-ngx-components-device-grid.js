import * as i4 from '@c8y/ngx-components';
import { FilteringFormRendererContext, C8yJSONSchema, gettext, getBasicInputArrayFormFieldConfig, CellRendererContext, SendStatus, PushStatus, Status, AlertService, ModalService, UserPreferencesService, GainsightService, FilteringActionType, DataGridComponent, CommonModule, FormsModule, DeviceStatusModule, DataGridModule, DynamicFormsModule } from '@c8y/ngx-components';
import * as i0 from '@angular/core';
import { Component, HostListener, Injectable, ViewChild, ElementRef, Optional, EventEmitter, Input, Output, NgModule } from '@angular/core';
import { cloneDeep, map, sortBy, remove, transform, identity, get, assign, forEach, isEmpty, omitBy, isNil } from 'lodash-es';
import { FormGroup } from '@angular/forms';
import * as i1 from '@ngx-translate/core';
import { TranslateService } from '@ngx-translate/core';
import { isObservable, of, from, combineLatest, BehaviorSubject, Subject } from 'rxjs';
import { withLatestFrom, map as map$1, take, share, concatMap, tap, takeUntil, filter, switchMap, first } from 'rxjs/operators';
import { __awaiter, __decorate } from 'tslib';
import { QueriesUtil, InventoryService, UserService } from '@c8y/client';
import * as i1$1 from '@c8y/client';
import * as i2 from '@c8y/client';
import { RouterModule } from '@angular/router';
import { AssetSelectorModule } from '@c8y/ngx-components/assets-navigator';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@c8y/ngx-components';
import * as ɵngcc2 from '@ngx-formly/core';
import * as ɵngcc3 from '@ngx-translate/core';
import * as ɵngcc4 from '@c8y/ngx-components/assets-navigator';
import * as ɵngcc5 from '@angular/common';
import * as ɵngcc6 from '@c8y/client';

const _c0 = ["assetSelector"];
const _c1 = function (a0) { return { selected: a0, groupsOnly: true, multi: true, groupsSelectable: true }; };
function AlarmsCellRendererComponent_small_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "small", 5);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelement(2, "i", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r0.context.item.c8y_ActiveAlarmsStatus == null ? null : ctx_r0.context.item.c8y_ActiveAlarmsStatus.critical, " ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("c8yIcon", "warning");
} }
function AlarmsCellRendererComponent_small_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "small", 7);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelement(2, "i", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1.context.item.c8y_ActiveAlarmsStatus == null ? null : ctx_r1.context.item.c8y_ActiveAlarmsStatus.major, " ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("c8yIcon", "exclamation-circle");
} }
function AlarmsCellRendererComponent_small_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "small", 8);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelement(2, "i", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r2.context.item.c8y_ActiveAlarmsStatus == null ? null : ctx_r2.context.item.c8y_ActiveAlarmsStatus.minor, " ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("c8yIcon", "exclamation-circle");
} }
function AlarmsCellRendererComponent_small_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "small", 9);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelement(2, "i", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r3.context.item.c8y_ActiveAlarmsStatus == null ? null : ctx_r3.context.item.c8y_ActiveAlarmsStatus.warning, " ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("c8yIcon", "circle");
} }
function DeviceGridComponent_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "c8y-column", 3);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const column_r1 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("name", column_r1.name);
} }
class BaseFilteringFormRendererComponent {
    constructor(context, jsonschema) {
        this.context = context;
        this.jsonschema = jsonschema;
    }
    onEnterKeyDown(event) {
        event.stopPropagation();
        this.applyFilter();
    }
    onEscapeKeyDown(event) {
        event.stopPropagation();
        this.resetFilter();
    }
    ngOnInit() {
        const column = this.context.property;
        if (column.filteringConfig.fields) {
            this.fields = cloneDeep(column.filteringConfig.fields);
        }
        else if (!column.filteringConfig.fields && column.filteringConfig.schema) {
            this.schema = cloneDeep(column.filteringConfig.schema);
            this.fields = [this.jsonschema.toFieldConfig(this.schema)];
        }
        else {
            throw new Error(`Neither fields nor schema configuration provided for Formly.`);
        }
        this.form = column.filteringConfig.formGroup || new FormGroup({});
        this.model = column.externalFilterQuery || column.filteringConfig.model || {};
        this.options = { formDefaults: { ngModelOptions: { debounce: 100 } } };
    }
    applyFilter() {
        this.context.applyFilter({
            externalFilterQuery: this.form.value
        });
    }
    resetFilter() {
        this.context.resetFilter();
    }
}
BaseFilteringFormRendererComponent.ɵfac = function BaseFilteringFormRendererComponent_Factory(t) { return new (t || BaseFilteringFormRendererComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.FilteringFormRendererContext), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.C8yJSONSchema)); };
BaseFilteringFormRendererComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: BaseFilteringFormRendererComponent, selectors: [["ng-component"]], hostBindings: function BaseFilteringFormRendererComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown.enter", function BaseFilteringFormRendererComponent_keydown_enter_HostBindingHandler($event) { return ctx.onEnterKeyDown($event); })("keydown.escape", function BaseFilteringFormRendererComponent_keydown_escape_HostBindingHandler($event) { return ctx.onEscapeKeyDown($event); });
    } }, decls: 8, vars: 10, consts: [[3, "form", "fields", "model"], [1, "data-grid__dropdown__footer", "d-flex", "separator-top"], ["translate", "", 1, "btn", "btn-default", "btn-sm", "m-r-8", "flex-grow", 3, "title", "click"], ["translate", "", 1, "btn", "btn-primary", "btn-sm", "flex-grow", 3, "disabled", "title", "click"]], template: function BaseFilteringFormRendererComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "formly-form", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "button", 2);
        ɵngcc0.ɵɵlistener("click", function BaseFilteringFormRendererComponent_Template_button_click_2_listener() { return ctx.resetFilter(); });
        ɵngcc0.ɵɵpipe(3, "translate");
        ɵngcc0.ɵɵtext(4, " Reset ");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "button", 3);
        ɵngcc0.ɵɵlistener("click", function BaseFilteringFormRendererComponent_Template_button_click_5_listener() { return ctx.applyFilter(); });
        ɵngcc0.ɵɵpipe(6, "translate");
        ɵngcc0.ɵɵtext(7, " Apply ");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("form", ctx.form)("fields", ctx.fields)("model", ctx.model);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵpropertyInterpolate("title", ɵngcc0.ɵɵpipeBind1(3, 6, "Reset"));
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵpropertyInterpolate("title", ɵngcc0.ɵɵpipeBind1(6, 8, "Apply"));
        ɵngcc0.ɵɵproperty("disabled", ctx.form.pristine && ctx.form.untouched || ctx.form.invalid);
    } }, directives: [ɵngcc2.FormlyForm, ɵngcc1.C8yTranslateDirective], pipes: [ɵngcc1.C8yTranslatePipe], encapsulation: 2 });
BaseFilteringFormRendererComponent.ctorParameters = () => [
    { type: FilteringFormRendererContext },
    { type: C8yJSONSchema }
];
BaseFilteringFormRendererComponent.propDecorators = {
    onEnterKeyDown: [{ type: HostListener, args: ['keydown.enter', ['$event'],] }],
    onEscapeKeyDown: [{ type: HostListener, args: ['keydown.escape', ['$event'],] }]
};

class BaseDeviceGridColumn {
    constructor(config = {}) {
        this.filteringFormRendererComponent = BaseFilteringFormRendererComponent;
        Object.assign(this, config);
    }
    /**
     * Gets a label template to be used in the schema-form's `type: 'template'` form item.
     * @param label The label to be displayed.
     * @param options Additional options:
     *   - `showWildcardTooltip`: `boolean` - appends a tooltip explaining wildcard usage
     * @returns The string with the template.
     */
    getLabelTemplate(label, options = {}) {
        const wildcardTooltip = `
      <i
        class="text-info"
        c8y-icon="info-circle"
        title="{{ 'Use * as a wildcard character' | translate }}"
      ></i>
    `;
        return `
      <label>
        <span>
          {{ '${label}' | translate }}
        </span>
        ${options.showWildcardTooltip ? wildcardTooltip : ''}
      </label>
    `;
    }
}

class CustomDeviceGridColumn extends BaseDeviceGridColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        const self = this;
        this.name = this.name || 'custom';
        this.header = this.header || gettext('Custom');
        this.filterable = true;
        this.filteringConfig = {
            fields: [
                {
                    key: 'exists',
                    type: 'switch',
                    defaultValue: false,
                    templateOptions: {
                        label: gettext('Only rows where value is defined')
                    }
                },
                ...getBasicInputArrayFormFieldConfig({
                    key: 'equals',
                    label: gettext('Only rows where value equals to'),
                    addText: gettext('Add next`value`'),
                    tooltip: gettext('Use * as a wildcard character'),
                    placeholder: '10300',
                    optional: true
                })
            ],
            getFilter(model) {
                const filter = {};
                if (model.exists) {
                    filter.__has = self.path;
                }
                if (model.equals) {
                    filter[self.path] = { __in: model.equals };
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: this.path }]
        };
    }
}

class RegistrationDateCellRendererComponent {
    constructor(context) {
        this.context = context;
    }
}
RegistrationDateCellRendererComponent.ɵfac = function RegistrationDateCellRendererComponent_Factory(t) { return new (t || RegistrationDateCellRendererComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.CellRendererContext)); };
RegistrationDateCellRendererComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: RegistrationDateCellRendererComponent, selectors: [["ng-component"]], decls: 2, vars: 3, template: function RegistrationDateCellRendererComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtext(0);
        ɵngcc0.ɵɵpipe(1, "c8yDate");
    } if (rf & 2) {
        ɵngcc0.ɵɵtextInterpolate1(" ", ɵngcc0.ɵɵpipeBind1(1, 1, ctx.context.value), " ");
    } }, pipes: [ɵngcc1.DatePipe], encapsulation: 2 });
RegistrationDateCellRendererComponent.ctorParameters = () => [
    { type: CellRendererContext }
];

class RegistrationDateDeviceGridColumn extends BaseDeviceGridColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        const self = this;
        this.path = 'creationTime';
        this.name = 'registrationDate';
        this.header = gettext('Registration date');
        this.cellRendererComponent = RegistrationDateCellRendererComponent;
        this.filterable = true;
        this.filteringConfig = {
            fields: [
                {
                    type: 'object',
                    key: 'registrationDate',
                    fieldGroup: [
                        {
                            type: 'date-time',
                            key: 'after',
                            templateOptions: {
                                label: gettext('Show items registered after')
                            },
                            expressionProperties: {
                                'templateOptions.maxDate': (model) => model === null || model === void 0 ? void 0 : model.before
                            }
                        },
                        {
                            type: 'date-time',
                            key: 'before',
                            templateOptions: {
                                label: gettext('And before`date`')
                            },
                            expressionProperties: {
                                'templateOptions.minDate': (model) => model === null || model === void 0 ? void 0 : model.after
                            }
                        }
                    ]
                }
            ],
            formGroup: new FormGroup({}),
            getFilter(model) {
                const filter = {};
                const dates = model && model.registrationDate;
                if (dates && (dates.after || dates.before)) {
                    filter.__and = [];
                    if (dates.after) {
                        const after = self.formatDate(dates.after);
                        filter.__and.push({
                            __or: {
                                [self.path]: { __gt: after },
                                [`${self.path}.date`]: { __gt: after }
                            }
                        });
                    }
                    if (dates.before) {
                        const before = self.formatDate(dates.before);
                        filter.__and.push({
                            __or: {
                                [self.path]: { __lt: before },
                                [`${self.path}.date`]: { __lt: before }
                            }
                        });
                    }
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: `${this.path}.date` }, { path: this.path }]
        };
    }
    formatDate(dateToFormat) {
        return new Date(dateToFormat).toISOString();
    }
}

class StatusCellRendererComponent {
    constructor(context) {
        this.context = context;
    }
}
StatusCellRendererComponent.ɵfac = function StatusCellRendererComponent_Factory(t) { return new (t || StatusCellRendererComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.CellRendererContext)); };
StatusCellRendererComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: StatusCellRendererComponent, selectors: [["ng-component"]], decls: 1, vars: 1, consts: [[3, "mo"]], template: function StatusCellRendererComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "device-status", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("mo", ctx.context.item);
    } }, directives: [ɵngcc1.DeviceStatusComponent], encapsulation: 2 });
StatusCellRendererComponent.ctorParameters = () => [
    { type: CellRendererContext }
];

class StatusDeviceGridColumn extends BaseDeviceGridColumn {
    constructor() {
        super();
        const responseIntervalPath = 'c8y_RequiredAvailability.responseInterval';
        const responseIntervalLessThanOrEqualTo0 = { [responseIntervalPath]: { __le: 0 } };
        const responseIntervalNotDefined = { __not: { __has: responseIntervalPath } };
        const availabilityStatusPath = 'c8y_Availability.status';
        const availabilityStatusAvailable = { [availabilityStatusPath]: SendStatus.AVAILABLE };
        const availabilityStatusUnavailable = { [availabilityStatusPath]: SendStatus.UNAVAILABLE };
        const availabilityStatusMaintenance = { [availabilityStatusPath]: SendStatus.MAINTENANCE };
        const availabilityStatusNotDefined = { __not: { __has: availabilityStatusPath } };
        const connectionStatusPath = 'c8y_Connection.status';
        const connectionStatusConnected = { [connectionStatusPath]: PushStatus.CONNECTED };
        const connectionStatusDisconnected = { [connectionStatusPath]: PushStatus.DISCONNECTED };
        const connectionStatusMaintenance = { [connectionStatusPath]: PushStatus.MAINTENANCE };
        const deviceUnderMaintenance = {
            __or: [
                responseIntervalLessThanOrEqualTo0,
                availabilityStatusMaintenance,
                connectionStatusMaintenance
            ]
        };
        const deviceNotUnderMaintenance = {
            // using __and of __nots because backend does not support __not with __ors
            __and: [
                { __not: responseIntervalLessThanOrEqualTo0 },
                { __not: availabilityStatusMaintenance },
                { __not: connectionStatusMaintenance }
            ]
        };
        this.name = 'status';
        this.header = gettext('Status');
        this.dataType = "icon" /* Icon */;
        this.cellRendererComponent = StatusCellRendererComponent;
        this.resizable = false;
        this.filterable = true;
        this.filteringConfig = {
            schema: {
                type: 'object',
                properties: {
                    sendStatus: {
                        title: gettext('Show devices with send status'),
                        type: 'object',
                        properties: {
                            sendOnline: {
                                type: 'switch',
                                title: gettext('Online')
                            },
                            sendOffline: {
                                type: 'switch',
                                title: gettext('Offline')
                            },
                            sendUnknown: {
                                type: 'switch',
                                title: gettext('Unknown')
                            },
                            sendNotMonitored: {
                                type: 'switch',
                                title: gettext('Not monitored')
                            },
                        }
                    },
                    pushStatus: {
                        title: gettext('Show devices with push status'),
                        type: 'object',
                        properties: {
                            pushOnline: {
                                type: 'switch',
                                title: gettext('Online')
                            },
                            pushOffline: {
                                type: 'switch',
                                title: gettext('Offline')
                            },
                            pushNotMonitored: {
                                type: 'switch',
                                title: gettext('Not monitored')
                            },
                        }
                    },
                    maintenanceStatus: {
                        title: gettext('Show devices with maintenance status'),
                        type: 'object',
                        properties: {
                            maintenance: {
                                type: 'switch',
                                title: gettext('Device is under maintenance')
                            }
                        }
                    }
                }
            },
            formGroup: new FormGroup({}),
            getFilter(model) {
                var _a, _b, _c, _d, _e, _f, _g, _h;
                const filter = {};
                const ors = [];
                if ((_a = model === null || model === void 0 ? void 0 : model.sendStatus) === null || _a === void 0 ? void 0 : _a.sendOnline) {
                    ors.push({
                        __and: [deviceNotUnderMaintenance, availabilityStatusAvailable]
                    });
                }
                if ((_b = model === null || model === void 0 ? void 0 : model.sendStatus) === null || _b === void 0 ? void 0 : _b.sendOffline) {
                    ors.push({
                        __and: [deviceNotUnderMaintenance, availabilityStatusUnavailable]
                    });
                }
                if ((_c = model === null || model === void 0 ? void 0 : model.sendStatus) === null || _c === void 0 ? void 0 : _c.sendUnknown) {
                    ors.push({
                        __and: [deviceNotUnderMaintenance, availabilityStatusNotDefined]
                    });
                }
                if (((_d = model === null || model === void 0 ? void 0 : model.sendStatus) === null || _d === void 0 ? void 0 : _d.sendNotMonitored) || ((_e = model === null || model === void 0 ? void 0 : model.pushStatus) === null || _e === void 0 ? void 0 : _e.pushNotMonitored)) {
                    ors.push(responseIntervalNotDefined);
                }
                if ((_f = model === null || model === void 0 ? void 0 : model.pushStatus) === null || _f === void 0 ? void 0 : _f.pushOnline) {
                    ors.push({
                        __and: [deviceNotUnderMaintenance, connectionStatusConnected]
                    });
                }
                if ((_g = model === null || model === void 0 ? void 0 : model.pushStatus) === null || _g === void 0 ? void 0 : _g.pushOffline) {
                    ors.push({
                        __and: [deviceNotUnderMaintenance, connectionStatusDisconnected]
                    });
                }
                if ((_h = model === null || model === void 0 ? void 0 : model.maintenanceStatus) === null || _h === void 0 ? void 0 : _h.maintenance) {
                    ors.push(deviceUnderMaintenance);
                }
                if (ors.length) {
                    filter.__or = ors;
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: availabilityStatusPath }]
        };
    }
}

/**
 * Service contains logic extracted from the device-grid service to avoid circular dependency MTM-40239.
 */
class ColumnUtilService {
    constructor(translateService) {
        this.translateService = translateService;
    }
    getAlarmsHref(device) {
        return `${this.getHref(device)}/alarms`;
    }
    getHref(groupOrDevice, prefix = '#/') {
        if (groupOrDevice.c8y_IsDeviceGroup || groupOrDevice.c8y_IsDynamicGroup) {
            return `${prefix}group/${groupOrDevice.id}`;
        }
        return `${prefix}device/${groupOrDevice.id}`;
    }
    getParentsNames(device, featuredParentId) {
        const assetParentsReferences = device.assetParents.references;
        const assetParents = map(assetParentsReferences, 'managedObject');
        const sortedByName = sortBy(assetParents, ['name']);
        const featuredItems = remove(sortedByName, { id: featuredParentId });
        const items = featuredItems.concat(sortedByName);
        const names = map(items, 'name');
        return names.join(', ');
    }
    getModel(device) {
        const hardware = this.getHardware(device);
        return hardware && hardware.model;
    }
    getProperName(device) {
        const { id, name } = device;
        return name ? name : this.translateService.instant('Device {{id}}', { id });
    }
    getSerialNumber(device) {
        const hardware = this.getHardware(device);
        const serialPropertyName = this.isVendme(device) ? 'serial' : 'serialNumber';
        return hardware && hardware[serialPropertyName];
    }
    getHardware(device) {
        const hardwarePropertyName = this.isVendme(device)
            ? 'com_nsn_startups_vendme_fragments_VendingMachineTypeInfo'
            : 'c8y_Hardware';
        return device && device[hardwarePropertyName];
    }
    isVendme(device) {
        return device.type === 'com_nsn_startups_vendme_VendingMachine';
    }
}
ColumnUtilService.ɵfac = function ColumnUtilService_Factory(t) { return new (t || ColumnUtilService)(ɵngcc0.ɵɵinject(ɵngcc3.TranslateService)); };
ColumnUtilService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ColumnUtilService_Factory() { return new ColumnUtilService(i0.ɵɵinject(i1.TranslateService)); }, token: ColumnUtilService, providedIn: "root" });
ColumnUtilService.ctorParameters = () => [
    { type: TranslateService }
];

class GroupCellRendererComponent {
    constructor(context, columnUtilService) {
        this.context = context;
        this.columnUtilService = columnUtilService;
    }
}
GroupCellRendererComponent.ɵfac = function GroupCellRendererComponent_Factory(t) { return new (t || GroupCellRendererComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.CellRendererContext), ɵngcc0.ɵɵdirectiveInject(ColumnUtilService)); };
GroupCellRendererComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: GroupCellRendererComponent, selectors: [["ng-component"]], decls: 2, vars: 2, consts: [[1, "text-truncate", 3, "title"]], template: function GroupCellRendererComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵpropertyInterpolate("title", ctx.columnUtilService.getParentsNames(ctx.context.item, ctx.context.property.externalFilterQuery == null ? null : ctx.context.property.externalFilterQuery.deviceGroupId));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.columnUtilService.getParentsNames(ctx.context.item, ctx.context.property.externalFilterQuery == null ? null : ctx.context.property.externalFilterQuery.deviceGroupId), "\n");
    } }, encapsulation: 2 });
GroupCellRendererComponent.ctorParameters = () => [
    { type: CellRendererContext },
    { type: ColumnUtilService }
];

class GroupFilteringFormRendererComponent {
    constructor(context) {
        this.context = context;
        this.preselected = [];
    }
    onEnterKeyDown(event) {
        event.stopPropagation();
        this.applyFilter();
    }
    onEscapeKeyDown(event) {
        event.stopPropagation();
        this.resetFilter();
    }
    ngOnInit() {
        const column = this.context.property;
        this.model = cloneDeep(column.externalFilterQuery || {});
        this.preselected = this.model.selectedNodes || [];
    }
    ngAfterViewInit() {
        setTimeout(() => {
            try {
                this.assetSelector.nativeElement.querySelector('input').focus();
            }
            catch (ex) {
                // intended empty
            }
        }, 250);
    }
    applyFilter() {
        this.context.applyFilter({
            externalFilterQuery: this.model
        });
    }
    resetFilter() {
        this.context.resetFilter();
    }
    selectionChanged(nodes) {
        this.model.selectedNodes = nodes.items;
    }
}
GroupFilteringFormRendererComponent.ɵfac = function GroupFilteringFormRendererComponent_Factory(t) { return new (t || GroupFilteringFormRendererComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.FilteringFormRendererContext)); };
GroupFilteringFormRendererComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: GroupFilteringFormRendererComponent, selectors: [["ng-component"]], viewQuery: function GroupFilteringFormRendererComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, 5, ElementRef);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.assetSelector = _t.first);
    } }, hostBindings: function GroupFilteringFormRendererComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown.enter", function GroupFilteringFormRendererComponent_keydown_enter_HostBindingHandler($event) { return ctx.onEnterKeyDown($event); })("keydown.escape", function GroupFilteringFormRendererComponent_keydown_escape_HostBindingHandler($event) { return ctx.onEscapeKeyDown($event); });
    } }, decls: 9, vars: 9, consts: [[3, "config", "onSelected"], ["assetSelector", ""], [1, "data-grid__dropdown__footer", "d-flex", "separator-top"], ["translate", "", 1, "btn", "btn-default", "btn-sm", "m-r-8", "flex-grow", 3, "title", "click"], ["translate", "", 1, "btn", "btn-primary", "btn-sm", "flex-grow", 3, "title", "click"]], template: function GroupFilteringFormRendererComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "c8y-asset-selector", 0, 1);
        ɵngcc0.ɵɵlistener("onSelected", function GroupFilteringFormRendererComponent_Template_c8y_asset_selector_onSelected_0_listener($event) { return ctx.selectionChanged($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵelementStart(3, "button", 3);
        ɵngcc0.ɵɵlistener("click", function GroupFilteringFormRendererComponent_Template_button_click_3_listener() { return ctx.resetFilter(); });
        ɵngcc0.ɵɵpipe(4, "translate");
        ɵngcc0.ɵɵtext(5, " Reset ");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "button", 4);
        ɵngcc0.ɵɵlistener("click", function GroupFilteringFormRendererComponent_Template_button_click_6_listener() { return ctx.applyFilter(); });
        ɵngcc0.ɵɵpipe(7, "translate");
        ɵngcc0.ɵɵtext(8, " Apply ");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("config", ɵngcc0.ɵɵpureFunction1(7, _c1, ctx.preselected));
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵpropertyInterpolate("title", ɵngcc0.ɵɵpipeBind1(4, 3, "Reset"));
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵpropertyInterpolate("title", ɵngcc0.ɵɵpipeBind1(7, 5, "Apply"));
    } }, directives: [ɵngcc4.AssetSelectorComponent, ɵngcc1.C8yTranslateDirective], pipes: [ɵngcc1.C8yTranslatePipe], encapsulation: 2 });
GroupFilteringFormRendererComponent.ctorParameters = () => [
    { type: FilteringFormRendererContext }
];
GroupFilteringFormRendererComponent.propDecorators = {
    assetSelector: [{ type: ViewChild, args: ['assetSelector', { static: false, read: ElementRef },] }],
    onEnterKeyDown: [{ type: HostListener, args: ['keydown.enter', ['$event'],] }],
    onEscapeKeyDown: [{ type: HostListener, args: ['keydown.escape', ['$event'],] }]
};

class GroupDeviceGridColumn extends BaseDeviceGridColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        this.name = 'group';
        this.header = gettext('Group');
        this.cellRendererComponent = GroupCellRendererComponent;
        this.filteringFormRendererComponent = GroupFilteringFormRendererComponent;
        this.filterable = true;
        this.filteringConfig = {
            getFilter(model) {
                const filter = {};
                if (model.selectedNodes) {
                    filter.__or = model.selectedNodes.map((mo) => {
                        if (mo.c8y_DeviceQueryString) {
                            return { __useFilterQueryString: mo.c8y_DeviceQueryString };
                        }
                        return { __bygroupid: mo.id };
                    });
                }
                return filter;
            }
        };
        this.sortable = false;
    }
}

class NameCellRendererComponent {
    constructor(context, columnUtilService) {
        this.context = context;
        this.columnUtilService = columnUtilService;
    }
}
NameCellRendererComponent.ɵfac = function NameCellRendererComponent_Factory(t) { return new (t || NameCellRendererComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.CellRendererContext), ɵngcc0.ɵɵdirectiveInject(ColumnUtilService)); };
NameCellRendererComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NameCellRendererComponent, selectors: [["ng-component"]], decls: 2, vars: 3, consts: [[1, "interact", 3, "href", "title"]], template: function NameCellRendererComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "a", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵpropertyInterpolate("title", ctx.columnUtilService.getProperName(ctx.context.item));
        ɵngcc0.ɵɵproperty("href", ctx.columnUtilService.getHref(ctx.context.item), ɵngcc0.ɵɵsanitizeUrl);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.columnUtilService.getProperName(ctx.context.item), " ");
    } }, encapsulation: 2 });
NameCellRendererComponent.ctorParameters = () => [
    { type: CellRendererContext },
    { type: ColumnUtilService }
];

class SystemIdDeviceGridColumn extends BaseDeviceGridColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        const self = this;
        this.path = 'id';
        this.name = 'systemId';
        this.header = gettext('System ID');
        this.filterable = true;
        this.filteringConfig = {
            fields: getBasicInputArrayFormFieldConfig({
                key: 'ids',
                label: gettext('Show items with system ID'),
                addText: gettext('Add next`id`'),
                tooltip: gettext('Use * as a wildcard character'),
                placeholder: '10300'
            }),
            getFilter(model) {
                const filter = {};
                if (model.ids.length) {
                    filter[self.path] = { __in: model.ids };
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: this.path }]
        };
    }
}

class ModelCellRendererComponent {
    constructor(context, columnUtilService) {
        this.context = context;
        this.columnUtilService = columnUtilService;
    }
}
ModelCellRendererComponent.ɵfac = function ModelCellRendererComponent_Factory(t) { return new (t || ModelCellRendererComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.CellRendererContext), ɵngcc0.ɵɵdirectiveInject(ColumnUtilService)); };
ModelCellRendererComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ModelCellRendererComponent, selectors: [["ng-component"]], decls: 1, vars: 1, template: function ModelCellRendererComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtext(0);
    } if (rf & 2) {
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.columnUtilService.getModel(ctx.context.item), " ");
    } }, encapsulation: 2 });
ModelCellRendererComponent.ctorParameters = () => [
    { type: CellRendererContext },
    { type: ColumnUtilService }
];

class TypeDeviceGridColumn extends BaseDeviceGridColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        this.name = 'type';
        this.path = 'type';
        this.header = gettext('Type');
        this.filterable = true;
        this.filteringConfig = {
            fields: getBasicInputArrayFormFieldConfig({
                key: 'types',
                label: gettext('Show devices with type'),
                addText: gettext('Add next`type`'),
                tooltip: gettext('Use * as a wildcard character'),
                placeholder: gettext('MyType`DEVICE_TYPE`')
            }),
            getFilter(model) {
                const filter = {};
                if (model.types.length) {
                    filter.type = { __in: model.types };
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = { pathSortingConfigs: [{ path: 'type' }] };
    }
}

class ImeiDeviceGridColumn extends BaseDeviceGridColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        const self = this;
        this.path = 'c8y_Mobile.imei';
        this.name = 'imei';
        this.header = gettext('IMEI');
        this.filterable = true;
        this.filteringConfig = {
            fields: getBasicInputArrayFormFieldConfig({
                key: 'imeis',
                label: gettext('Show items with IMEI'),
                addText: gettext('Add next`IMEI`'),
                tooltip: gettext('Use * as a wildcard character'),
                placeholder: '46543432321'
            }),
            getFilter(model) {
                const filter = {};
                if (model.imeis.length) {
                    filter[self.path] = { __in: model.imeis };
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: this.path }]
        };
    }
}

class NameDeviceGridColumn extends BaseDeviceGridColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        this.name = 'name';
        this.path = 'name';
        this.header = gettext('Name');
        this.cellCSSClassName = "data-record-header" /* Header */;
        this.cellRendererComponent = NameCellRendererComponent;
        this.filterable = true;
        this.filteringConfig = {
            fields: getBasicInputArrayFormFieldConfig({
                key: 'names',
                label: gettext('Show items with name'),
                addText: gettext('Add next`name`'),
                tooltip: gettext('Use * as a wildcard character'),
                placeholder: gettext('My device`DEVICE_NAME`')
            }),
            getFilter(model) {
                const filter = {};
                if (model.names.length) {
                    filter.name = { __in: model.names };
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: this.path }]
        };
    }
}

class ModelDeviceGridColumn extends BaseDeviceGridColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        const hardwareModelPath = 'c8y_Hardware.model';
        const vendingModelPath = 'com_nsn_startups_vendme_fragments_VendingMachineTypeInfo.model';
        this.name = 'model';
        this.header = gettext('Model');
        this.cellRendererComponent = ModelCellRendererComponent;
        this.filterable = true;
        this.filteringConfig = {
            fields: getBasicInputArrayFormFieldConfig({
                key: 'models',
                label: gettext('Show items with model'),
                addText: gettext('Add next`model`'),
                tooltip: gettext('Use * as a wildcard character'),
                placeholder: 'NTC-220'
            }),
            getFilter(model) {
                const filter = {};
                if (model.models.length) {
                    filter.__or = {
                        [hardwareModelPath]: { __in: model.models },
                        [vendingModelPath]: { __in: model.models }
                    };
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: hardwareModelPath }, { path: vendingModelPath }]
        };
    }
}

class AlarmsCellRendererComponent {
    constructor(context, columnUtilService) {
        this.context = context;
        this.columnUtilService = columnUtilService;
    }
}
AlarmsCellRendererComponent.ɵfac = function AlarmsCellRendererComponent_Factory(t) { return new (t || AlarmsCellRendererComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.CellRendererContext), ɵngcc0.ɵɵdirectiveInject(ColumnUtilService)); };
AlarmsCellRendererComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: AlarmsCellRendererComponent, selectors: [["ng-component"]], decls: 5, vars: 5, consts: [[1, "listLink", 3, "href"], ["class", "status critical text-nowrap", 4, "ngIf"], ["class", "status major text-nowrap", 4, "ngIf"], ["class", "status minor text-nowrap", 4, "ngIf"], ["class", "status warning text-nowrap", 4, "ngIf"], [1, "status", "critical", "text-nowrap"], [3, "c8yIcon"], [1, "status", "major", "text-nowrap"], [1, "status", "minor", "text-nowrap"], [1, "status", "warning", "text-nowrap"]], template: function AlarmsCellRendererComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "a", 0);
        ɵngcc0.ɵɵtemplate(1, AlarmsCellRendererComponent_small_1_Template, 3, 2, "small", 1);
        ɵngcc0.ɵɵtemplate(2, AlarmsCellRendererComponent_small_2_Template, 3, 2, "small", 2);
        ɵngcc0.ɵɵtemplate(3, AlarmsCellRendererComponent_small_3_Template, 3, 2, "small", 3);
        ɵngcc0.ɵɵtemplate(4, AlarmsCellRendererComponent_small_4_Template, 3, 2, "small", 4);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("href", ctx.columnUtilService.getAlarmsHref(ctx.context.item), ɵngcc0.ɵɵsanitizeUrl);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.context.item.c8y_ActiveAlarmsStatus == null ? null : ctx.context.item.c8y_ActiveAlarmsStatus.critical);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.context.item.c8y_ActiveAlarmsStatus == null ? null : ctx.context.item.c8y_ActiveAlarmsStatus.major);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.context.item.c8y_ActiveAlarmsStatus == null ? null : ctx.context.item.c8y_ActiveAlarmsStatus.minor);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.context.item.c8y_ActiveAlarmsStatus == null ? null : ctx.context.item.c8y_ActiveAlarmsStatus.warning);
    } }, directives: [ɵngcc5.NgIf, ɵngcc1.IconDirective], encapsulation: 2 });
AlarmsCellRendererComponent.ctorParameters = () => [
    { type: CellRendererContext },
    { type: ColumnUtilService }
];

class AlarmsDeviceGridColumn extends BaseDeviceGridColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        this.name = 'alarms';
        this.header = gettext('Alarms');
        this.cellRendererComponent = AlarmsCellRendererComponent;
        this.filterable = true;
        this.filteringConfig = {
            schema: {
                type: 'object',
                properties: {
                    alarm: {
                        type: 'object',
                        title: gettext('Show items'),
                        properties: {
                            critical: {
                                type: 'switch',
                                title: gettext('With active critical alarms')
                            },
                            major: {
                                type: 'switch',
                                title: gettext('With active major alarms')
                            },
                            minor: {
                                type: 'switch',
                                title: gettext('With active minor alarms')
                            },
                            warning: {
                                type: 'switch',
                                title: gettext('With active warnings')
                            },
                            none: {
                                type: 'switch',
                                title: gettext('With no active alarms or warnings')
                            }
                        }
                    },
                }
            },
            getFilter(model) {
                const filter = {};
                const ors = [];
                if (model.alarm.critical) {
                    ors.push({ 'c8y_ActiveAlarmsStatus.critical': { __gt: 0 } });
                }
                if (model.alarm.major) {
                    ors.push({ 'c8y_ActiveAlarmsStatus.major': { __gt: 0 } });
                }
                if (model.alarm.minor) {
                    ors.push({ 'c8y_ActiveAlarmsStatus.minor': { __gt: 0 } });
                }
                if (model.alarm.warning) {
                    ors.push({ 'c8y_ActiveAlarmsStatus.warning': { __gt: 0 } });
                }
                if (model.alarm.none) {
                    ors.push({ __not: { __has: 'c8y_ActiveAlarmsStatus' } });
                    ors.push({
                        __and: map(['critical', 'major', 'minor', 'warning'], sev => {
                            const zero = {};
                            const has = { __not: { __has: undefined } };
                            const key = `c8y_ActiveAlarmsStatus.${sev}`;
                            zero[key] = 0;
                            has.__not.__has = key;
                            return { __or: [zero, has] };
                        })
                    });
                }
                if (ors.length) {
                    filter.__or = ors;
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [
                { path: 'c8y_ActiveAlarmsStatus.critical' },
                { path: 'c8y_ActiveAlarmsStatus.major' },
                { path: 'c8y_ActiveAlarmsStatus.minor' },
                { path: 'c8y_ActiveAlarmsStatus.warning' }
            ]
        };
    }
}

class SerialNumberCellRendererComponent {
    constructor(context, columnUtilService) {
        this.context = context;
        this.columnUtilService = columnUtilService;
    }
}
SerialNumberCellRendererComponent.ɵfac = function SerialNumberCellRendererComponent_Factory(t) { return new (t || SerialNumberCellRendererComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.CellRendererContext), ɵngcc0.ɵɵdirectiveInject(ColumnUtilService)); };
SerialNumberCellRendererComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: SerialNumberCellRendererComponent, selectors: [["ng-component"]], decls: 1, vars: 1, template: function SerialNumberCellRendererComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtext(0);
    } if (rf & 2) {
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.columnUtilService.getSerialNumber(ctx.context.item), " ");
    } }, encapsulation: 2 });
SerialNumberCellRendererComponent.ctorParameters = () => [
    { type: CellRendererContext },
    { type: ColumnUtilService }
];

class SerialNumberDeviceGridColumn extends BaseDeviceGridColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        const hardwareSerialNumberPath = 'c8y_Hardware.serialNumber';
        const vendingSerialNumberPath = 'com_nsn_startups_vendme_fragments_VendingMachineTypeInfo.serial';
        this.name = 'serialNumber';
        this.header = gettext('Serial number');
        this.cellRendererComponent = SerialNumberCellRendererComponent;
        this.filterable = true;
        this.filteringConfig = {
            fields: getBasicInputArrayFormFieldConfig({
                key: 'serialNumbers',
                label: gettext('Show items with serial number'),
                addText: gettext('Add next`serial number`'),
                tooltip: gettext('Use * as a wildcard character'),
                placeholder: '54321-123'
            }),
            getFilter(model) {
                const filter = {};
                if (model.serialNumbers.length) {
                    filter.__or = {
                        [hardwareSerialNumberPath]: { __in: model.serialNumbers },
                        [vendingSerialNumberPath]: { __in: model.serialNumbers }
                    };
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: hardwareSerialNumberPath }, { path: vendingSerialNumberPath }]
        };
    }
}

class DecoratorService {
    constructor(service) {
        DecoratorService.mapperService = service;
    }
    static getMapperService() {
        if (!DecoratorService.mapperService) {
            throw new Error('DecoratorService not initialized');
        }
        return DecoratorService.mapperService;
    }
}
DecoratorService.ɵfac = function DecoratorService_Factory(t) { return new (t || DecoratorService)(ɵngcc0.ɵɵinject(DeviceGridConfigMapperService)); };
DecoratorService.mapperService = undefined;
DecoratorService.ɵprov = i0.ɵɵdefineInjectable({ factory: function DecoratorService_Factory() { return new DecoratorService(i0.ɵɵinject(DeviceGridConfigMapperService)); }, token: DecoratorService, providedIn: "root" });
DecoratorService.ctorParameters = () => [
    { type: DeviceGridConfigMapperService }
];

function mapLegacyGridConfiguration() {
    return (target, key, descriptor) => {
        descriptor.value = (...args) => {
            const mapperService = DecoratorService.getMapperService();
            return mapperService.getMappedGridConfig(args[0]);
        };
        return descriptor;
    };
}

class DeviceGridService {
    constructor(inventoryService, userService, translateService, alertService, modal, columnUtilService, userPreferencesService, gainsightService) {
        this.inventoryService = inventoryService;
        this.userService = userService;
        this.translateService = translateService;
        this.alertService = alertService;
        this.modal = modal;
        this.columnUtilService = columnUtilService;
        this.userPreferencesService = userPreferencesService;
        this.gainsightService = gainsightService;
        this.GRID_CONFIG_DEFAULT_STORAGE_KEY = 'device-grid-config';
        this.DEFAULT_PAGE_SIZE = 20;
        this.queriesUtil = new QueriesUtil();
    }
    getDefaultColumns() {
        const defaultColumns = [
            new StatusDeviceGridColumn(),
            new NameDeviceGridColumn(),
            new ModelDeviceGridColumn(),
            new SerialNumberDeviceGridColumn(),
            new GroupDeviceGridColumn(),
            new RegistrationDateDeviceGridColumn(),
            new SystemIdDeviceGridColumn(),
            new ImeiDeviceGridColumn(),
            new AlarmsDeviceGridColumn()
        ];
        return defaultColumns;
    }
    getChildDeviceGridColumns() {
        const childDeviceGridColumn = [
            new StatusDeviceGridColumn(),
            new NameDeviceGridColumn(),
            new ModelDeviceGridColumn(),
            new SerialNumberDeviceGridColumn(),
            new RegistrationDateDeviceGridColumn(),
            new SystemIdDeviceGridColumn(),
            new ImeiDeviceGridColumn(),
            new AlarmsDeviceGridColumn()
        ];
        return childDeviceGridColumn;
    }
    getDefaultPagination() {
        return {
            pageSize: 10,
            currentPage: 1
        };
    }
    getInfiniteScrollPagination() {
        return {
            pageSize: 50,
            currentPage: 1
        };
    }
    getDefaultActionControls() {
        return [
            {
                type: "DELETE" /* Delete */,
                callback: (item) => this.delete(item)
            }
        ];
    }
    getDefaultBulkActionControls() {
        return [];
    }
    getDefaultHeaderActionControls() {
        return [];
    }
    getProperName(device) {
        return this.columnUtilService.getProperName(device);
    }
    getModel(device) {
        return this.columnUtilService.getModel(device);
    }
    getSerialNumber(device) {
        return this.columnUtilService.getSerialNumber(device);
    }
    getParentsNames(device, featuredParentId) {
        return this.columnUtilService.getParentsNames(device, featuredParentId);
    }
    getHref(groupOrDevice, prefix = '#/') {
        return this.columnUtilService.getHref(groupOrDevice, prefix);
    }
    getAlarmsHref(device) {
        return this.columnUtilService.getAlarmsHref(device);
    }
    /**
     * @deprecated Use getUserConfiguredColumns$(Column[] | Observable<Column[]>, string) instead.
     */
    getUserConfiguredColumns(columns, storageKey) {
        return this.applyConfigToColumns(this.getConfig2(storageKey), columns, storageKey);
    }
    getUserConfiguredColumns$(columns, storageKey) {
        return this.getConfig$(storageKey).pipe(withLatestFrom(isObservable(columns) ? columns : of(columns)), map$1(([config, cols]) => this.applyConfigToColumns(config, cols, storageKey)), take(1), share());
    }
    delete(device) {
        var _a, _b, _c, _d, _e, _f;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const deviceWithChildren = yield (yield this.inventoryService.detail(device, { withChildren: true })).data;
                const hasChildDevices = ((_b = (_a = deviceWithChildren.childDevices) === null || _a === void 0 ? void 0 : _a.references) === null || _b === void 0 ? void 0 : _b.length) > 0;
                const hasChildAdditions = ((_d = (_c = deviceWithChildren.childAdditions) === null || _c === void 0 ? void 0 : _c.references) === null || _d === void 0 ? void 0 : _d.length) > 0;
                const hasChildAssets = ((_f = (_e = deviceWithChildren.childAssets) === null || _e === void 0 ? void 0 : _e.references) === null || _f === void 0 ? void 0 : _f.length) > 0;
                const showDeleteChildren = () => hasChildAdditions || hasChildDevices || hasChildAssets;
                const modalResult = yield this.modal.confirm(gettext('Delete device'), this.translateService.instant(gettext(`You are about to delete device "{{ name }}". Do you want to proceed?`), device), Status.DANGER, { ok: gettext('Delete'), cancel: gettext('Cancel') }, {
                    cascade: {
                        text: gettext('Also delete child hierarchy of this device.'),
                        checked: showDeleteChildren(),
                        showIf: showDeleteChildren,
                        disabledByKey: 'withDeviceUser'
                    },
                    withDeviceUser: {
                        text: this.translateService.instant(gettext('Also delete associated device owner "{{ owner }}".'), device),
                        checked: false,
                        showIf: () => {
                            const isRootDevice = device.c8y_IsDevice;
                            const hasDeviceUserAsOwner = device.owner &&
                                this.userService.isDeviceUser({ id: device.owner });
                            return Boolean(isRootDevice && hasDeviceUserAsOwner);
                        },
                        disabledByKey: 'cascade'
                    }
                });
                yield this.inventoryService.delete(device, modalResult.confirmOptions);
                this.alertService.success(gettext('Device deleted.'));
                if (this.gainsightService) {
                    this.gainsightService.triggerEvent('deviceGrid:EntryDeleted');
                }
                return Promise.resolve();
            }
            catch (ex) {
                // only if not cancel from modal
                if (this.gainsightService && !ex) {
                    this.gainsightService.triggerEvent('deviceGrid:EntryDeletionCancelled');
                }
                if (ex) {
                    this.alertService.addServerFailure(ex);
                }
                return Promise.reject();
            }
        });
    }
    getData(columns, pagination, query = {}, withChildren = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const filters = Object.assign(Object.assign({}, this.getDevicesFilters(columns, pagination, query)), { withGroups: true, withChildren });
            return this.inventoryService.list(filters);
        });
    }
    getChildDeviceData(columns, pagination, query = {}, withChildren = false, id) {
        return __awaiter(this, void 0, void 0, function* () {
            const childDeviceFilters = true;
            const filters = Object.assign(Object.assign({}, this.getDevicesFilters(columns, pagination, query, childDeviceFilters)), { withGroups: true, withChildren });
            return this.inventoryService.childDevicesList(id, filters);
        });
    }
    getCount(columns, pagination, query = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const filters = Object.assign(Object.assign({}, this.getDevicesFilters(columns, pagination, query)), { pageSize: 1, currentPage: 1 });
            return (yield this.inventoryService.list(filters)).paging.totalPages;
        });
    }
    getCountChildDevices(columns, pagination, query = {}, id) {
        return __awaiter(this, void 0, void 0, function* () {
            const childDeviceFilters = true;
            const filters = Object.assign(Object.assign({}, this.getDevicesFilters(columns, pagination, query, childDeviceFilters)), { pageSize: 1, currentPage: 1 });
            return (yield this.inventoryService.childDevicesList(id, filters)).paging.totalPages;
        });
    }
    getTotalChildDevices(query = {}, id) {
        return __awaiter(this, void 0, void 0, function* () {
            const filters = {
                q: this.queriesUtil.buildQuery(query),
                pageSize: 1,
                withTotalPages: true
            };
            return (yield this.inventoryService.childDevicesList(id, filters)).paging.totalPages;
        });
    }
    getTotal(query = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const filters = {
                q: this.queriesUtil.buildQuery(query),
                pageSize: 1,
                withTotalPages: true
            };
            return (yield this.inventoryService.list(filters)).paging.totalPages;
        });
    }
    getDeviceQueryString(columns, query) {
        let fullQuery = this.getQueryObj(columns);
        fullQuery = this.queriesUtil.addAndFilter(fullQuery, query);
        return this.queriesUtil.buildQuery(fullQuery);
    }
    getQueryObj(columns, defaultFilter = {}) {
        return transform(columns, (query, column) => this.extendQueryByColumn(query, column), Object.assign({ __filter: {}, __orderby: [] }, defaultFilter));
    }
    /**
     * @deprecated Use getConfig$(key: string): Observable<GridConfig> instead.
     */
    getConfig(key = this.GRID_CONFIG_DEFAULT_STORAGE_KEY) {
        return this.getConfig2(key);
    }
    /**
     * @deprecated Use saveConfig$(config: GridConfig, key: string): Promise<GridConfig> instead.
     */
    saveConfig(config, key = this.GRID_CONFIG_DEFAULT_STORAGE_KEY) {
        localStorage.setItem(key, JSON.stringify(config));
    }
    clearConfig(key = this.GRID_CONFIG_DEFAULT_STORAGE_KEY) {
        localStorage.removeItem(key);
    }
    getConfig$(key = this.GRID_CONFIG_DEFAULT_STORAGE_KEY) {
        return this.userPreferencesService.get(key).pipe(map$1(config => config || {
            columns: [],
            pagination: { pageSize: this.DEFAULT_PAGE_SIZE, currentPage: 1 }
        }));
    }
    saveConfig$(config, key = this.GRID_CONFIG_DEFAULT_STORAGE_KEY) {
        return from(this.userPreferencesService.set(key, config));
    }
    applyConfigToColumns(config, columns, storageKey) {
        if (config.columns.length > 0) {
            const reOrderedColumns = [];
            let noConfigColumns = [];
            try {
                const customColumns = config.columns
                    .filter(col => col.custom)
                    .map((col) => new CustomDeviceGridColumn(col));
                const allColumns = [...columns, ...customColumns];
                noConfigColumns = allColumns.filter(col => !config.columns.some(configCol => col.name === configCol.name));
                config.columns.forEach(({ visible, name, sortOrder, filter }) => {
                    const columnToReorder = allColumns.find(col => col.name === name);
                    if (columnToReorder) {
                        columnToReorder.visible = visible;
                        columnToReorder.sortOrder = sortOrder;
                        columnToReorder.externalFilterQuery = filter === null || filter === void 0 ? void 0 : filter.externalFilterQuery;
                        reOrderedColumns.push(columnToReorder);
                    }
                });
            }
            catch (ex) {
                this.clearConfig(storageKey);
            }
            return [...reOrderedColumns, ...noConfigColumns];
        }
        return columns;
    }
    // TODO: REMOVE ME
    // Added because usage of getConfig breaks JSdoc deprecations, otherwise compodoc build fails
    getConfig2(key = this.GRID_CONFIG_DEFAULT_STORAGE_KEY) {
        const config = JSON.parse(localStorage.getItem(key));
        if (config === null) {
            return { columns: [], pagination: { pageSize: this.DEFAULT_PAGE_SIZE, currentPage: 1 } };
        }
        return config;
    }
    getHardware(device) {
        const hardwarePropertyName = this.isVendme(device)
            ? 'com_nsn_startups_vendme_fragments_VendingMachineTypeInfo'
            : 'c8y_Hardware';
        return device && device[hardwarePropertyName];
    }
    isVendme(device) {
        return device.type === 'com_nsn_startups_vendme_VendingMachine';
    }
    getDevicesFilters(columns, pagination, query, childDeviceFilters) {
        return Object.assign(Object.assign({}, (childDeviceFilters
            ? { query: this.getDeviceQueryString(columns, query) }
            : { q: this.getDeviceQueryString(columns, query) })), { pageSize: pagination.pageSize, currentPage: pagination.currentPage, withChildren: false, withTotalPages: true });
    }
    extendQueryByColumn(query, column) {
        if (column.filterable && column.externalFilterQuery) {
            const getFilter = column.filteringConfig.getFilter || identity;
            const queryObj = getFilter(column.externalFilterQuery);
            if (queryObj.__or) {
                query.__filter.__and = query.__filter.__and || [];
                query.__filter.__and.push(queryObj);
            }
            else if (queryObj.__and && get(query, '__filter.__and')) {
                queryObj.__and.map(obj => query.__filter.__and.push(obj));
            }
            else {
                assign(query.__filter, queryObj);
            }
        }
        if (column.sortable && column.sortOrder) {
            const cs = {};
            forEach(column.sortingConfig.pathSortingConfigs, pathSortingConfig => {
                cs[pathSortingConfig.path] =
                    (column.sortOrder === 'asc' ? 1 : -1) * (pathSortingConfig.sortOrderModifier || 1);
            });
            query.__orderby.push(cs);
        }
        return query;
    }
}
DeviceGridService.ɵfac = function DeviceGridService_Factory(t) { return new (t || DeviceGridService)(ɵngcc0.ɵɵinject(ɵngcc6.InventoryService), ɵngcc0.ɵɵinject(ɵngcc6.UserService), ɵngcc0.ɵɵinject(ɵngcc3.TranslateService), ɵngcc0.ɵɵinject(ɵngcc1.AlertService), ɵngcc0.ɵɵinject(ɵngcc1.ModalService), ɵngcc0.ɵɵinject(ColumnUtilService), ɵngcc0.ɵɵinject(ɵngcc1.UserPreferencesService), ɵngcc0.ɵɵinject(ɵngcc1.GainsightService, 8)); };
DeviceGridService.ɵprov = i0.ɵɵdefineInjectable({ factory: function DeviceGridService_Factory() { return new DeviceGridService(i0.ɵɵinject(i1$1.InventoryService), i0.ɵɵinject(i2.UserService), i0.ɵɵinject(i1.TranslateService), i0.ɵɵinject(i4.AlertService), i0.ɵɵinject(i4.ModalService), i0.ɵɵinject(ColumnUtilService), i0.ɵɵinject(i4.UserPreferencesService), i0.ɵɵinject(i4.GainsightService, 8)); }, token: DeviceGridService, providedIn: "root" });
DeviceGridService.ctorParameters = () => [
    { type: InventoryService },
    { type: UserService },
    { type: TranslateService },
    { type: AlertService },
    { type: ModalService },
    { type: ColumnUtilService },
    { type: UserPreferencesService },
    { type: GainsightService, decorators: [{ type: Optional }] }
];
__decorate([
    mapLegacyGridConfiguration()
], DeviceGridService.prototype, "getConfig$", null);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BaseFilteringFormRendererComponent, [{
        type: Component,
        args: [{
                template: "<formly-form [form]=\"form\" [fields]=\"fields\" [model]=\"model\"></formly-form>\n<div class=\"data-grid__dropdown__footer d-flex separator-top\">\n  <button\n    class=\"btn btn-default btn-sm m-r-8 flex-grow\"\n    (click)=\"resetFilter()\"\n    title=\"{{ 'Reset' | translate }}\"\n    translate\n  >\n    Reset\n  </button>\n\n  <button\n    class=\"btn btn-primary btn-sm flex-grow\"\n    (click)=\"applyFilter()\"\n    [disabled]=\"(form.pristine && form.untouched) || form.invalid\"\n    title=\"{{ 'Apply' | translate }}\"\n    translate\n  >\n    Apply\n  </button>\n</div>\n"
            }]
    }], function () { return [{ type: ɵngcc1.FilteringFormRendererContext }, { type: ɵngcc1.C8yJSONSchema }]; }, { onEnterKeyDown: [{
            type: HostListener,
            args: ['keydown.enter', ['$event']]
        }], onEscapeKeyDown: [{
            type: HostListener,
            args: ['keydown.escape', ['$event']]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RegistrationDateCellRendererComponent, [{
        type: Component,
        args: [{
                template: `
    {{ context.value | c8yDate }}
  `
            }]
    }], function () { return [{ type: ɵngcc1.CellRendererContext }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(StatusCellRendererComponent, [{
        type: Component,
        args: [{
                template: `
    <device-status [mo]="context.item"></device-status>
  `
            }]
    }], function () { return [{ type: ɵngcc1.CellRendererContext }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ColumnUtilService, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: ɵngcc3.TranslateService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GroupCellRendererComponent, [{
        type: Component,
        args: [{
                template: "<span\n  title=\"{{\n    columnUtilService.getParentsNames(\n      context.item,\n      context.property.externalFilterQuery?.deviceGroupId\n    )\n  }}\"\n  class=\"text-truncate\"\n>\n  {{\n    columnUtilService.getParentsNames(\n      context.item,\n      context.property.externalFilterQuery?.deviceGroupId\n    )\n  }}\n</span>\n"
            }]
    }], function () { return [{ type: ɵngcc1.CellRendererContext }, { type: ColumnUtilService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GroupFilteringFormRendererComponent, [{
        type: Component,
        args: [{
                template: "<c8y-asset-selector\n  #assetSelector\n  [config]=\"{ selected: preselected, groupsOnly: true, multi: true, groupsSelectable: true }\"\n  (onSelected)=\"selectionChanged($event)\"\n></c8y-asset-selector>\n\n<div class=\"data-grid__dropdown__footer d-flex separator-top\">\n  <button\n    class=\"btn btn-default btn-sm m-r-8 flex-grow\"\n    (click)=\"resetFilter()\"\n    title=\"{{ 'Reset' | translate }}\"\n    translate\n  >\n    Reset\n  </button>\n\n  <button\n    class=\"btn btn-primary btn-sm flex-grow\"\n    (click)=\"applyFilter()\"\n    title=\"{{ 'Apply' | translate }}\"\n    translate\n  >\n    Apply\n  </button>\n</div>\n"
            }]
    }], function () { return [{ type: ɵngcc1.FilteringFormRendererContext }]; }, { onEnterKeyDown: [{
            type: HostListener,
            args: ['keydown.enter', ['$event']]
        }], onEscapeKeyDown: [{
            type: HostListener,
            args: ['keydown.escape', ['$event']]
        }], assetSelector: [{
            type: ViewChild,
            args: ['assetSelector', { static: false, read: ElementRef }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NameCellRendererComponent, [{
        type: Component,
        args: [{
                template: `
    <a
      [href]="columnUtilService.getHref(context.item)"
      title="{{ columnUtilService.getProperName(context.item) }}"
      class="interact"
    >
      {{ columnUtilService.getProperName(context.item) }}
    </a>
  `
            }]
    }], function () { return [{ type: ɵngcc1.CellRendererContext }, { type: ColumnUtilService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ModelCellRendererComponent, [{
        type: Component,
        args: [{
                template: `
    {{ columnUtilService.getModel(context.item) }}
  `
            }]
    }], function () { return [{ type: ɵngcc1.CellRendererContext }, { type: ColumnUtilService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AlarmsCellRendererComponent, [{
        type: Component,
        args: [{
                template: "<a class=\"listLink\" [href]=\"columnUtilService.getAlarmsHref(context.item)\">\n  <small class=\"status critical text-nowrap\" *ngIf=\"context.item.c8y_ActiveAlarmsStatus?.critical\">\n    {{ context.item.c8y_ActiveAlarmsStatus?.critical }}\n    <i [c8yIcon]=\"'warning'\"></i>\n  </small>\n  <small class=\"status major text-nowrap\" *ngIf=\"context.item.c8y_ActiveAlarmsStatus?.major\">\n    {{ context.item.c8y_ActiveAlarmsStatus?.major }}\n    <i [c8yIcon]=\"'exclamation-circle'\"></i>\n  </small>\n  <small class=\"status minor text-nowrap\" *ngIf=\"context.item.c8y_ActiveAlarmsStatus?.minor\">\n    {{ context.item.c8y_ActiveAlarmsStatus?.minor }}\n    <i [c8yIcon]=\"'exclamation-circle'\"></i>\n  </small>\n  <small class=\"status warning text-nowrap\" *ngIf=\"context.item.c8y_ActiveAlarmsStatus?.warning\">\n    {{ context.item.c8y_ActiveAlarmsStatus?.warning }}\n    <i [c8yIcon]=\"'circle'\"></i>\n  </small>\n</a>\n"
            }]
    }], function () { return [{ type: ɵngcc1.CellRendererContext }, { type: ColumnUtilService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SerialNumberCellRendererComponent, [{
        type: Component,
        args: [{
                template: `
    {{ columnUtilService.getSerialNumber(context.item) }}
  `
            }]
    }], function () { return [{ type: ɵngcc1.CellRendererContext }, { type: ColumnUtilService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DecoratorService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: DeviceGridConfigMapperService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DeviceGridService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc6.InventoryService }, { type: ɵngcc6.UserService }, { type: ɵngcc3.TranslateService }, { type: ɵngcc1.AlertService }, { type: ɵngcc1.ModalService }, { type: ColumnUtilService }, { type: ɵngcc1.UserPreferencesService }, { type: ɵngcc1.GainsightService, decorators: [{
                type: Optional
            }] }]; }, null); })();

class DeviceGridConfigMapperService {
    constructor(userPreferencesService, deviceGridService) {
        this.userPreferencesService = userPreferencesService;
        this.deviceGridService = deviceGridService;
    }
    getMappedGridConfig(key) {
        key = key || this.deviceGridService.GRID_CONFIG_DEFAULT_STORAGE_KEY;
        const legacyAllDevicesGridKey = 'all-devices-columns-meta_';
        const legacyAllDevicesGridFilterKey = 'all-devices-columns-config';
        return combineLatest([
            this.userPreferencesService.get(legacyAllDevicesGridKey),
            this.userPreferencesService.get(legacyAllDevicesGridFilterKey)
        ]).pipe(map$1(([legacyConfig, legacyFilterConfig]) => this.mapLegacyToDeviceGridConfig(legacyConfig, legacyFilterConfig)), concatMap(mappedLegacyConfig => {
            if (mappedLegacyConfig) {
                return Promise.all([
                    this.userPreferencesService.set(legacyAllDevicesGridKey, null),
                    this.userPreferencesService.set(legacyAllDevicesGridFilterKey, null)
                ]).then(() => mappedLegacyConfig);
            }
            else {
                return of(null);
            }
        }), concatMap(mappedLegacyConfig => mappedLegacyConfig
            ? this.userPreferencesService.set(key, mappedLegacyConfig).then(() => mappedLegacyConfig)
            : this.userPreferencesService.get(key)), map$1(config => config || {
            columns: [],
            pagination: {
                pageSize: this.deviceGridService.DEFAULT_PAGE_SIZE,
                currentPage: 1
            }
        }));
    }
    mapLegacyToDeviceGridConfig(legacyConfig, legacyFilterConfig) {
        if (Array.isArray(legacyConfig) || !isEmpty(legacyFilterConfig)) {
            return {
                columns: this.getConfigColumns(legacyConfig, legacyFilterConfig),
                pagination: {
                    pageSize: this.deviceGridService.DEFAULT_PAGE_SIZE,
                    currentPage: 1
                }
            };
        }
    }
    getConfigColumns(legacyConfig, legacyFilterConfig) {
        const legacyFilterConfigArray = legacyFilterConfig
            ? Object.keys(legacyFilterConfig).map(key => ({
                key,
                filter: {
                    externalFilterQuery: legacyFilterConfig[key].filtering
                },
                sorting: legacyFilterConfig[key].sorting
            }))
            : [];
        const config = this.mergeLegacyConfigs(legacyConfig ||
            this.deviceGridService.getDefaultColumns().map(column => ({ key: column.name })), legacyFilterConfigArray);
        return config
            .filter(column => column.key !== 'removalColumn')
            .map(this.mapLegacyColumnConfig.bind(this));
    }
    mergeLegacyConfigs(columnConfig, filterConfig) {
        return columnConfig.map(column => (Object.assign(Object.assign({}, filterConfig.find(item => item.key === column.key)), column)));
    }
    mapLegacyColumnConfig(legacy) {
        const { active, key, custom, headerName, fragmentPath, filter, sorting } = legacy;
        const sortOrder = sorting ? this.migrateSortOrder(sorting) : '';
        return omitBy({
            visible: active !== null && active !== void 0 ? active : true,
            name: DeviceGridConfigMapperService.deviceGridLegacyKeyToName[key] || key,
            sortOrder,
            custom,
            header: custom ? headerName : null,
            path: fragmentPath,
            filter
        }, isNil);
    }
    migrateSortOrder(sorting) {
        switch (sorting.order) {
            case 0:
                return '';
            case -1:
                return 'desc';
            case 1:
                return 'asc';
        }
    }
}
DeviceGridConfigMapperService.ɵfac = function DeviceGridConfigMapperService_Factory(t) { return new (t || DeviceGridConfigMapperService)(ɵngcc0.ɵɵinject(ɵngcc1.UserPreferencesService), ɵngcc0.ɵɵinject(DeviceGridService)); };
DeviceGridConfigMapperService.deviceGridLegacyKeyToName = {
    status: 'status',
    name: 'name',
    model: 'model',
    serialNumber: 'serialNumber',
    group: 'group',
    registrationDate: 'registrationDate',
    systemId: 'systemId',
    imei: 'imei',
    alarms: 'alarms'
};
DeviceGridConfigMapperService.ɵprov = i0.ɵɵdefineInjectable({ factory: function DeviceGridConfigMapperService_Factory() { return new DeviceGridConfigMapperService(i0.ɵɵinject(i4.UserPreferencesService), i0.ɵɵinject(DeviceGridService)); }, token: DeviceGridConfigMapperService, providedIn: "root" });
DeviceGridConfigMapperService.ctorParameters = () => [
    { type: UserPreferencesService },
    { type: DeviceGridService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DeviceGridConfigMapperService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc1.UserPreferencesService }, { type: DeviceGridService }]; }, null); })();

class DeviceGridComponent {
    constructor(deviceGridService) {
        this.deviceGridService = deviceGridService;
        /** Takes an event emitter. When an event is emitted, the grid will be reloaded. */
        this.refresh = new EventEmitter();
        /** The title for the data grid, it's displayed in the grid's header. */
        this.title = gettext('Devices');
        /** The label for load more button. */
        this.loadMoreItemsLabel = gettext('Load more devices');
        /** The label for loading indicator. */
        this.loadingItemsLabel = gettext('Loading devices…');
        /** Determines whether items can be selected by clicking a checkbox in the first column. */
        this.selectable = false;
        /** Sets the base query which is appended to the request for data. */
        this.baseQuery = {};
        this.childDeviceGrid = false;
        /** Sets the withChildren query which is appended to the request. */
        this.withChildren = false;
        /** Emits an event when columns configuration changes. */
        this.onColumnsChange = new EventEmitter();
        this.onFilterChange = new EventEmitter();
        this.onDeviceQueryStringChange = new EventEmitter();
        /** Emits an event when items selection changes. The array contains ids of selected items. */
        this.itemsSelect = new EventEmitter();
        this.configureColumnsEnabled = true;
        this.actionControls = [];
        this.columns$ = of(this.deviceGridService.getDefaultColumns());
        this.appliedFilters = [];
        this.pagination = this.deviceGridService.getDefaultPagination();
        this.bulkActionControls = this.deviceGridService.getDefaultBulkActionControls();
        this.headerActionControls = this.deviceGridService.getDefaultHeaderActionControls();
        /**
         * Manages the requests to the DeviceGridService.saveConfig$() method:
         * 0 - Semaphore is in initial state, request can be executed;
         * 1 - Semaphore is blocked, further requests need to wait for lock to get released;
         * 2 - Semaphore is "green", requests can be done;
         */
        this.saveGridConfigSemaphore$ = new BehaviorSubject(0);
        this.destroyed$ = new Subject();
        this.serverSideDataCallback = this.onDataSourceModifier.bind(this);
    }
    /** Pagination settings, e.g. allows for setting current page or page size. If not given, defaults to standard settings. */
    set _pagination(value) {
        if (value) {
            this.pagination = value;
        }
        else {
            this.pagination = this.deviceGridService.getDefaultPagination();
        }
    }
    /** Sets load more mode. */
    set _infiniteScroll(infiniteScroll) {
        this.infiniteScroll = infiniteScroll;
        if (infiniteScroll) {
            this.pagination = this.deviceGridService.getInfiniteScrollPagination();
        }
    }
    /** Sets action controls (actions available for individual items). If not given, it defaults to standard actions. */
    set _actionControls(value) {
        if (value) {
            this.actionControls = value;
        }
        else {
            this.actionControls = this.deviceGridService.getDefaultActionControls();
        }
    }
    /** Sets bulk action controls (actions available for items selected by user). If not given, it defaults to standard bulk actions. */
    set _bulkActionControls(value) {
        if (value) {
            this.bulkActionControls = value;
        }
        else {
            this.bulkActionControls = this.deviceGridService.getDefaultBulkActionControls();
        }
    }
    /** Sets header action controls (actions available from the grid header). If not given, it defaults to empty list of actions. */
    set _headerActionControls(value) {
        if (value) {
            this.headerActionControls = value;
        }
        else {
            this.headerActionControls = this.deviceGridService.getDefaultHeaderActionControls();
        }
    }
    ngOnInit() {
        this.setActionControls();
        if (this.columnsConfig && !this.columnsConfigKey) {
            this.columns$ = of(this.columnsConfig);
            this.configureColumnsEnabled = false;
            console.warn('Device grid expects columnsConfigKey to be set if setting customized columns list. Without it the changes to the grid wll not be saved anywhere.');
        }
        else {
            this.columns$ = this.deviceGridService.getUserConfiguredColumns$(this.columnsConfig ? this.columnsConfig : this.deviceGridService.getDefaultColumns(), this.columnsConfigKey);
        }
    }
    ngOnDestroy() {
        this.destroyed$.next();
        this.destroyed$.complete();
    }
    trackByName(_index, column) {
        return column.name;
    }
    onDataSourceModifier(dataSourceModifier) {
        return __awaiter(this, void 0, void 0, function* () {
            let serverSideDataResult;
            let filteredSize;
            let size;
            if (this.childDeviceGrid) {
                const { res, data, paging } = yield this.deviceGridService.getChildDeviceData(dataSourceModifier.columns, dataSourceModifier.pagination, this.baseQuery, this.withChildren, this.parentDeviceId);
                filteredSize = yield this.deviceGridService.getCountChildDevices(dataSourceModifier.columns, dataSourceModifier.pagination, this.baseQuery, this.parentDeviceId);
                size = yield this.deviceGridService.getTotalChildDevices(this.baseQuery, this.parentDeviceId);
                serverSideDataResult = {
                    res,
                    data,
                    paging,
                    filteredSize,
                    size
                };
            }
            else {
                const { res, data, paging } = yield this.deviceGridService.getData(dataSourceModifier.columns, dataSourceModifier.pagination, this.baseQuery, this.withChildren);
                filteredSize = yield this.deviceGridService.getCount(dataSourceModifier.columns, dataSourceModifier.pagination, this.baseQuery);
                size = yield this.deviceGridService.getTotal(this.baseQuery);
                serverSideDataResult = {
                    res,
                    data,
                    paging,
                    filteredSize,
                    size
                };
            }
            this.onColumnsChange.emit(dataSourceModifier.columns);
            this.onDeviceQueryStringChange.emit(this.deviceGridService.getDeviceQueryString(dataSourceModifier.columns, this.baseQuery));
            if (this.dataCallback) {
                serverSideDataResult = this.dataCallback(serverSideDataResult);
            }
            return serverSideDataResult;
        });
    }
    filterChange({ columnName, filteringModifier }) {
        const index = this.appliedFilters.findIndex(el => el.columnName === columnName);
        if (index > -1) {
            this.appliedFilters[index].filteringModifier = filteringModifier;
        }
        else {
            this.appliedFilters.push({ columnName, filteringModifier });
        }
        this.onFilterChange.emit(this.appliedFilters);
        this.updateFilterConfig(columnName, filteringModifier);
    }
    updateFilterConfig(columnName, filteringModifier) {
        // Here I needed to take the current columns because if there isn't any stored config
        // and custom columns are provided through parent element we need to use them.
        combineLatest([this.deviceGridService.getConfig$(this.columnsConfigKey), this.columns$])
            .pipe(tap(([config, columns]) => {
            var _a;
            const columnsConfig = (((_a = config === null || config === void 0 ? void 0 : config.columns) === null || _a === void 0 ? void 0 : _a.length) > 0 ? config.columns : columns).map(({ name, visible, sortOrder, filter, custom, header, path }) => ({
                name,
                visible: visible !== null && visible !== void 0 ? visible : true,
                sortOrder,
                custom,
                header,
                path,
                filter: columnName && columnName !== name ? filter : filteringModifier
            }));
            if (!columnsConfig.filter) {
                delete columnsConfig.filter;
            }
            this.configChange({ columns: columnsConfig, pagination: config.pagination });
        }), take(1), takeUntil(this.destroyed$))
            .subscribe();
    }
    setActionControls() {
        return __awaiter(this, void 0, void 0, function* () {
            const deleteAction = {
                type: "DELETE" /* Delete */,
                callback: (device) => this.onDeleteDevice(device)
            };
            this.actionControls.push(deleteAction);
        });
    }
    onDeleteDevice(device) {
        this.deviceGridService
            .delete(device)
            .then(() => this.refresh.emit())
            .catch(() => ({}));
    }
    updateFiltering(columnNames, action) {
        const { type } = action;
        if (type === FilteringActionType.ResetFilter) {
            this.dataGrid.clearFilters();
        }
        else {
            this.dataGrid.updateFiltering(columnNames, action);
        }
    }
    configChange(config) {
        /* Semaphore ensures that the first request to DeviceGridService.saveConfig$() is completed
         * before the next requests are sent out. This prevents multiple configuration objects to be
         * created in Inventory in case a config does not yet exist.
         */
        this.saveGridConfigSemaphore$
            .pipe(filter(semaphore => semaphore !== 1), tap(() => {
            if (this.saveGridConfigSemaphore$.value < 1) {
                this.saveGridConfigSemaphore$.next(this.saveGridConfigSemaphore$.value + 1);
            }
        }), concatMap(() => this.deviceGridService.saveConfig$(config, this.columnsConfigKey)), tap(() => {
            if (this.saveGridConfigSemaphore$.value < 2) {
                this.saveGridConfigSemaphore$.next(this.saveGridConfigSemaphore$.value + 1);
            }
        }), take(1), takeUntil(this.destroyed$))
            .subscribe();
    }
    addCustomColumn(columnConfig) {
        this.deviceGridService
            .getConfig$(this.columnsConfigKey)
            .pipe(tap(config => (config.columns = [
            ...(config.columns.length === 0 ? this.getDefalultConfigColumns() : config.columns),
            columnConfig
        ])), concatMap(config => this.deviceGridService.saveConfig$(config, this.columnsConfigKey)), switchMap(() => this.deviceGridService.getUserConfiguredColumns$(this.columns$, this.columnsConfigKey)), 
        // Let data-grid re-render with new columns;
        // Columns are set in a separate step in the pipe to avoid flickering
        // in the grid in the time where get config request is executing
        tap(columns => (this.columns$ = of(columns))), take(1), takeUntil(this.destroyed$))
            .subscribe();
    }
    removeCustomColumn(columnToRemove) {
        this.deviceGridService
            .getConfig$(this.columnsConfigKey)
            .pipe(first(), tap(config => (config.columns = config.columns.filter(column => column.name !== columnToRemove.name))), concatMap(config => this.deviceGridService.saveConfig$(config, this.columnsConfigKey)), switchMap(() => this.deviceGridService.getUserConfiguredColumns$(this.columns$.pipe(map$1(columns => columns.filter(column => column.name !== columnToRemove.name))), this.columnsConfigKey)), 
        // Let data-grid re-render with new columns;
        // Columns are set in a separate step in the pipe to avoid flickering
        // in the grid in the time where get config request is executing
        tap(columns => (this.columns$ = of(columns))), take(1), takeUntil(this.destroyed$))
            .subscribe();
    }
    getDefalultConfigColumns() {
        return this.deviceGridService
            .getDefaultColumns()
            .map(column => ({ name: column.name, visible: true }));
    }
}
DeviceGridComponent.ɵfac = function DeviceGridComponent_Factory(t) { return new (t || DeviceGridComponent)(ɵngcc0.ɵɵdirectiveInject(DeviceGridService)); };
DeviceGridComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: DeviceGridComponent, selectors: [["c8y-device-grid"]], viewQuery: function DeviceGridComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(DataGridComponent, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dataGrid = _t.first);
    } }, inputs: { refresh: "refresh", title: "title", loadMoreItemsLabel: "loadMoreItemsLabel", loadingItemsLabel: "loadingItemsLabel", selectable: "selectable", baseQuery: "baseQuery", childDeviceGrid: "childDeviceGrid", withChildren: "withChildren", _pagination: ["pagination", "_pagination"], _infiniteScroll: ["infiniteScroll", "_infiniteScroll"], _actionControls: ["actionControls", "_actionControls"], _bulkActionControls: ["bulkActionControls", "_bulkActionControls"], _headerActionControls: ["headerActionControls", "_headerActionControls"], dataCallback: "dataCallback", columnsConfigKey: "columnsConfigKey", columnsConfig: ["columns", "columnsConfig"], parentDeviceId: "parentDeviceId" }, outputs: { onColumnsChange: "onColumnsChange", onFilterChange: "onFilterChange", onDeviceQueryStringChange: "onDeviceQueryStringChange", itemsSelect: "itemsSelect" }, decls: 7, vars: 27, consts: [[3, "title", "loadMoreItemsLabel", "loadingItemsLabel", "columns", "pagination", "infiniteScroll", "actionControls", "selectable", "bulkActionControls", "serverSideDataCallback", "refresh", "headerActionControls", "configureColumnsEnabled", "itemsSelect", "onConfigChange", "onAddCustomColumn", "onRemoveCustomColumn", "onFilter"], [3, "icon", "title", "subtitle", "horizontal"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "name"]], template: function DeviceGridComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "c8y-data-grid", 0);
        ɵngcc0.ɵɵlistener("itemsSelect", function DeviceGridComponent_Template_c8y_data_grid_itemsSelect_0_listener($event) { return ctx.itemsSelect.emit($event); })("onConfigChange", function DeviceGridComponent_Template_c8y_data_grid_onConfigChange_0_listener($event) { return ctx.configChange($event); })("onAddCustomColumn", function DeviceGridComponent_Template_c8y_data_grid_onAddCustomColumn_0_listener($event) { return ctx.addCustomColumn($event); })("onRemoveCustomColumn", function DeviceGridComponent_Template_c8y_data_grid_onRemoveCustomColumn_0_listener($event) { return ctx.removeCustomColumn($event); })("onFilter", function DeviceGridComponent_Template_c8y_data_grid_onFilter_0_listener($event) { return ctx.filterChange($event); });
        ɵngcc0.ɵɵpipe(1, "async");
        ɵngcc0.ɵɵelement(2, "c8y-ui-empty-state", 1);
        ɵngcc0.ɵɵpipe(3, "translate");
        ɵngcc0.ɵɵpipe(4, "translate");
        ɵngcc0.ɵɵtemplate(5, DeviceGridComponent_ng_container_5_Template, 2, 1, "ng-container", 2);
        ɵngcc0.ɵɵpipe(6, "async");
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("title", ctx.title)("loadMoreItemsLabel", ctx.loadMoreItemsLabel)("loadingItemsLabel", ctx.loadingItemsLabel)("columns", ɵngcc0.ɵɵpipeBind1(1, 19, ctx.columns$))("pagination", ctx.pagination)("infiniteScroll", ctx.infiniteScroll)("actionControls", ctx.actionControls)("selectable", ctx.selectable)("bulkActionControls", ctx.bulkActionControls)("serverSideDataCallback", ctx.serverSideDataCallback)("refresh", ctx.refresh)("headerActionControls", ctx.headerActionControls)("configureColumnsEnabled", ctx.configureColumnsEnabled);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("icon", "search")("title", ɵngcc0.ɵɵpipeBind1(3, 21, "No matching devices."))("subtitle", ɵngcc0.ɵɵpipeBind1(4, 23, "Refine your search terms"))("horizontal", true);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind1(6, 25, ctx.columns$))("ngForTrackBy", ctx.trackByName);
    } }, directives: [ɵngcc1.DataGridComponent, ɵngcc1.EmptyStateComponent, ɵngcc5.NgForOf, ɵngcc1.ColumnDirective], pipes: [ɵngcc5.AsyncPipe, ɵngcc1.C8yTranslatePipe], encapsulation: 2 });
DeviceGridComponent.ctorParameters = () => [
    { type: DeviceGridService }
];
DeviceGridComponent.propDecorators = {
    dataCallback: [{ type: Input }],
    refresh: [{ type: Input }],
    title: [{ type: Input }],
    loadMoreItemsLabel: [{ type: Input }],
    loadingItemsLabel: [{ type: Input }],
    columnsConfigKey: [{ type: Input }],
    columnsConfig: [{ type: Input, args: ['columns',] }],
    _pagination: [{ type: Input, args: ['pagination',] }],
    _infiniteScroll: [{ type: Input, args: ['infiniteScroll',] }],
    _actionControls: [{ type: Input, args: ['actionControls',] }],
    selectable: [{ type: Input }],
    baseQuery: [{ type: Input }],
    _bulkActionControls: [{ type: Input, args: ['bulkActionControls',] }],
    _headerActionControls: [{ type: Input, args: ['headerActionControls',] }],
    childDeviceGrid: [{ type: Input }],
    parentDeviceId: [{ type: Input }],
    withChildren: [{ type: Input }],
    onColumnsChange: [{ type: Output }],
    onFilterChange: [{ type: Output }],
    onDeviceQueryStringChange: [{ type: Output }],
    itemsSelect: [{ type: Output }],
    dataGrid: [{ type: ViewChild, args: [DataGridComponent, { static: true },] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DeviceGridComponent, [{
        type: Component,
        args: [{
                selector: 'c8y-device-grid',
                template: "<c8y-data-grid\n  [title]=\"title\"\n  [loadMoreItemsLabel]=\"loadMoreItemsLabel\"\n  [loadingItemsLabel]=\"loadingItemsLabel\"\n  [columns]=\"columns$ | async\"\n  [pagination]=\"pagination\"\n  [infiniteScroll]=\"infiniteScroll\"\n  [actionControls]=\"actionControls\"\n  [selectable]=\"selectable\"\n  [bulkActionControls]=\"bulkActionControls\"\n  [serverSideDataCallback]=\"serverSideDataCallback\"\n  (itemsSelect)=\"itemsSelect.emit($event)\"\n  (onConfigChange)=\"configChange($event)\"\n  (onAddCustomColumn)=\"addCustomColumn($event)\"\n  (onRemoveCustomColumn)=\"removeCustomColumn($event)\"\n  (onFilter)=\"filterChange($event)\"\n  [refresh]=\"refresh\"\n  [headerActionControls]=\"headerActionControls\"\n  [configureColumnsEnabled]=\"configureColumnsEnabled\"\n>\n  <c8y-ui-empty-state\n    [icon]=\"'search'\"\n    [title]=\"'No matching devices.' | translate\"\n    [subtitle]=\"'Refine your search terms' | translate\"\n    [horizontal]=\"true\"\n  >\n  </c8y-ui-empty-state>\n\n  <ng-container *ngFor=\"let column of columns$ | async; trackBy: trackByName\">\n    <c8y-column [name]=\"column.name\"></c8y-column>\n  </ng-container>\n</c8y-data-grid>\n"
            }]
    }], function () { return [{ type: DeviceGridService }]; }, { refresh: [{
            type: Input
        }], title: [{
            type: Input
        }], loadMoreItemsLabel: [{
            type: Input
        }], loadingItemsLabel: [{
            type: Input
        }], selectable: [{
            type: Input
        }], baseQuery: [{
            type: Input
        }], childDeviceGrid: [{
            type: Input
        }], withChildren: [{
            type: Input
        }], onColumnsChange: [{
            type: Output
        }], onFilterChange: [{
            type: Output
        }], onDeviceQueryStringChange: [{
            type: Output
        }], itemsSelect: [{
            type: Output
        }], _pagination: [{
            type: Input,
            args: ['pagination']
        }], _infiniteScroll: [{
            type: Input,
            args: ['infiniteScroll']
        }], _actionControls: [{
            type: Input,
            args: ['actionControls']
        }], _bulkActionControls: [{
            type: Input,
            args: ['bulkActionControls']
        }], _headerActionControls: [{
            type: Input,
            args: ['headerActionControls']
        }], dataCallback: [{
            type: Input
        }], columnsConfigKey: [{
            type: Input
        }], columnsConfig: [{
            type: Input,
            args: ['columns']
        }], parentDeviceId: [{
            type: Input
        }], dataGrid: [{
            type: ViewChild,
            args: [DataGridComponent, { static: true }]
        }] }); })();

class DeviceGridModule {
    constructor(service) {
        this.service = service;
    }
}
DeviceGridModule.ɵfac = function DeviceGridModule_Factory(t) { return new (t || DeviceGridModule)(ɵngcc0.ɵɵinject(DecoratorService)); };
DeviceGridModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: DeviceGridModule });
DeviceGridModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            FormsModule,
            DeviceStatusModule,
            DataGridModule,
            AssetSelectorModule,
            DynamicFormsModule,
            RouterModule
        ]] });
DeviceGridModule.ctorParameters = () => [
    { type: DecoratorService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DeviceGridModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    DeviceStatusModule,
                    DataGridModule,
                    AssetSelectorModule,
                    DynamicFormsModule,
                    RouterModule
                ],
                declarations: [
                    DeviceGridComponent,
                    BaseFilteringFormRendererComponent,
                    GroupFilteringFormRendererComponent,
                    StatusCellRendererComponent,
                    NameCellRendererComponent,
                    ModelCellRendererComponent,
                    SerialNumberCellRendererComponent,
                    GroupCellRendererComponent,
                    RegistrationDateCellRendererComponent,
                    AlarmsCellRendererComponent
                ],
                exports: [
                    DeviceGridComponent,
                    BaseFilteringFormRendererComponent,
                    GroupFilteringFormRendererComponent,
                    StatusCellRendererComponent,
                    NameCellRendererComponent,
                    ModelCellRendererComponent,
                    SerialNumberCellRendererComponent,
                    GroupCellRendererComponent,
                    RegistrationDateCellRendererComponent,
                    AlarmsCellRendererComponent
                ],
                entryComponents: [
                    DeviceGridComponent,
                    BaseFilteringFormRendererComponent,
                    GroupFilteringFormRendererComponent,
                    StatusCellRendererComponent,
                    NameCellRendererComponent,
                    ModelCellRendererComponent,
                    SerialNumberCellRendererComponent,
                    GroupCellRendererComponent,
                    RegistrationDateCellRendererComponent,
                    AlarmsCellRendererComponent
                ]
            }]
    }], function () { return [{ type: DecoratorService }]; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DeviceGridModule, { declarations: function () { return [DeviceGridComponent, BaseFilteringFormRendererComponent, GroupFilteringFormRendererComponent, StatusCellRendererComponent, NameCellRendererComponent, ModelCellRendererComponent, SerialNumberCellRendererComponent, GroupCellRendererComponent, RegistrationDateCellRendererComponent, AlarmsCellRendererComponent]; }, imports: function () { return [CommonModule,
        FormsModule,
        DeviceStatusModule,
        DataGridModule,
        AssetSelectorModule,
        DynamicFormsModule,
        RouterModule]; }, exports: function () { return [DeviceGridComponent, BaseFilteringFormRendererComponent, GroupFilteringFormRendererComponent, StatusCellRendererComponent, NameCellRendererComponent, ModelCellRendererComponent, SerialNumberCellRendererComponent, GroupCellRendererComponent, RegistrationDateCellRendererComponent, AlarmsCellRendererComponent]; } }); })();

/**
 * Generated bundle index. Do not edit.
 */

export { AlarmsCellRendererComponent, AlarmsDeviceGridColumn, BaseDeviceGridColumn, BaseFilteringFormRendererComponent, ColumnUtilService, CustomDeviceGridColumn, DeviceGridComponent, DeviceGridConfigMapperService, DeviceGridModule, DeviceGridService, GroupCellRendererComponent, GroupDeviceGridColumn, GroupFilteringFormRendererComponent, ImeiDeviceGridColumn, ModelCellRendererComponent, ModelDeviceGridColumn, NameCellRendererComponent, NameDeviceGridColumn, RegistrationDateCellRendererComponent, RegistrationDateDeviceGridColumn, SerialNumberCellRendererComponent, SerialNumberDeviceGridColumn, StatusCellRendererComponent, StatusDeviceGridColumn, SystemIdDeviceGridColumn, TypeDeviceGridColumn, mapLegacyGridConfiguration, ColumnUtilService as ɵa, BaseFilteringFormRendererComponent as ɵb, GroupFilteringFormRendererComponent as ɵc, StatusCellRendererComponent as ɵd, NameCellRendererComponent as ɵe, ModelCellRendererComponent as ɵf, SerialNumberCellRendererComponent as ɵg, GroupCellRendererComponent as ɵh, RegistrationDateCellRendererComponent as ɵi, AlarmsCellRendererComponent as ɵj, DecoratorService as ɵk };

//# sourceMappingURL=c8y-ngx-components-device-grid.js.map