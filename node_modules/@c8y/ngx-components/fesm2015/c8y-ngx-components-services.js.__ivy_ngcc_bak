import * as i0 from '@angular/core';
import { Component, InjectionToken, Injectable, Optional, Inject, EventEmitter, NgModule } from '@angular/core';
import { CellRendererContext, gettext, getBasicInputArrayFormFieldConfig, ViewContext, CoreModule, HOOK_ROUTE, HOOK_BREADCRUMB } from '@c8y/ngx-components';
import { BaseDeviceGridColumn, DeviceGridService } from '@c8y/ngx-components/device-grid';
import { FormGroup } from '@angular/forms';
import { flatten, entries, get } from 'lodash-es';
import { __awaiter } from 'tslib';
import { ActivatedRoute, RouterModule } from '@angular/router';
import { QueriesUtil, InventoryService } from '@c8y/client';
import { TooltipModule } from 'ngx-bootstrap/tooltip';

class LastUpdatedDateCellRendererComponent {
    constructor(context) {
        this.context = context;
    }
}
LastUpdatedDateCellRendererComponent.decorators = [
    { type: Component, args: [{
                template: `{{ context.value | c8yDate }}`
            },] }
];
LastUpdatedDateCellRendererComponent.ctorParameters = () => [
    { type: CellRendererContext }
];

class LastUpdatedDateGridColumn extends BaseDeviceGridColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        const self = this;
        this.path = 'lastUpdated';
        this.name = 'lastUpdatedDate';
        this.header = gettext('Last updated');
        this.cellRendererComponent = LastUpdatedDateCellRendererComponent;
        this.filterable = true;
        this.filteringConfig = {
            fields: [{
                    type: 'object',
                    key: 'lastUpdated',
                    fieldGroup: [
                        {
                            type: 'date-time',
                            key: 'after',
                            templateOptions: {
                                label: gettext('Show services updated after')
                            },
                            expressionProperties: {
                                'templateOptions.maxDate': (model) => model === null || model === void 0 ? void 0 : model.before,
                            },
                        },
                        {
                            type: 'date-time',
                            key: 'before',
                            templateOptions: {
                                label: gettext('And before`date`')
                            },
                            expressionProperties: {
                                'templateOptions.minDate': (model) => model === null || model === void 0 ? void 0 : model.after,
                            },
                        }
                    ]
                }],
            formGroup: new FormGroup({}),
            getFilter(model) {
                const filter = {};
                const dates = model && model.lastUpdated;
                if (dates && (dates.after || dates.before)) {
                    filter.__and = [];
                    if (dates.after) {
                        const after = self.formatDate(dates.after);
                        filter.__and.push({
                            __or: {
                                [self.path]: { __gt: after },
                                [`${self.path}.date`]: { __gt: after }
                            }
                        });
                    }
                    if (dates.before) {
                        const before = self.formatDate(dates.before);
                        filter.__and.push({
                            __or: {
                                [self.path]: { __lt: before },
                                [`${self.path}.date`]: { __lt: before }
                            }
                        });
                    }
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: `${this.path}.date` }, { path: this.path }]
        };
    }
    formatDate(dateToFormat) {
        return new Date(dateToFormat).toISOString();
    }
}

class NameCellRendererComponent {
    constructor(context) {
        this.context = context;
    }
}
NameCellRendererComponent.decorators = [
    { type: Component, args: [{
                template: `
    <a [routerLink]="['/service', context.item.id]" [title]="context.item.name" class="interact">
      {{ context.item.name }}
    </a>
  `
            },] }
];
NameCellRendererComponent.ctorParameters = () => [
    { type: CellRendererContext }
];

class ServiceNameGridColumn extends BaseDeviceGridColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        this.name = 'name';
        this.path = 'name';
        this.header = gettext('Name');
        this.cellRendererComponent = NameCellRendererComponent;
        this.filterable = true;
        this.filteringConfig = {
            fields: getBasicInputArrayFormFieldConfig({
                key: 'names',
                label: gettext('Filter services by name'),
                addText: gettext('Add next`name`'),
                tooltip: gettext('Use * as a wildcard character'),
                placeholder: gettext('daemon`SERVICE_NAME`')
            }),
            getFilter(model) {
                const filter = {};
                if (model.names.length) {
                    filter.name = { __in: model.names };
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: this.path }]
        };
    }
}

class ServiceTypeGridColumn extends BaseDeviceGridColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        this.name = 'serviceType';
        this.path = 'serviceType';
        this.header = gettext('Type');
        this.filterable = true;
        this.filteringConfig = {
            fields: getBasicInputArrayFormFieldConfig({
                key: 'serviceTypes',
                label: gettext('Filter services by type'),
                addText: gettext('Add next`type`'),
                tooltip: gettext('Use * as a wildcard character'),
                placeholder: 'systemd'
            }),
            getFilter(model) {
                const filter = {};
                if (model.serviceTypes.length) {
                    filter.serviceType = { __in: model.serviceTypes };
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: this.path }]
        };
    }
}

/**
 * Extension hook allowing to register custom service statuses and configure their visual presentation.
 */
const HOOK_SERVICE_STATUS = new InjectionToken('SERVICE_STATUS');
/**
 * Standard status options supported by the platform.
 */
const SERVICE_STATUS_OPTIONS = [
    {
        key: 'up',
        label: gettext('Up'),
        icon: 'check-circle',
        class: 'text-success'
    },
    {
        key: 'down',
        label: gettext('Down'),
        icon: 'exclamation-circle',
        class: 'text-danger'
    },
    {
        key: 'unknown',
        label: gettext('Unknown'),
        icon: 'inactive-state'
    }
];

/**
 * The service for system wide registered service status options.
 * It provides the standard service statuses plus all custom status options
 * registered with the <code>HOOK_SERVICE_STATUS</code> extension hook.
 */
class StatusOptionsService {
    constructor(options) {
        this._options = [...SERVICE_STATUS_OPTIONS, ...flatten(options)];
    }
    get options() {
        return this._options;
    }
}
StatusOptionsService.ɵprov = i0.ɵɵdefineInjectable({ factory: function StatusOptionsService_Factory() { return new StatusOptionsService(i0.ɵɵinject(HOOK_SERVICE_STATUS, 8)); }, token: StatusOptionsService, providedIn: "root" });
StatusOptionsService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
StatusOptionsService.ctorParameters = () => [
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [HOOK_SERVICE_STATUS,] }] }
];

class StatusCellRendererComponent {
    constructor(context, statusOptionsService) {
        this.context = context;
        this.statusOptionsService = statusOptionsService;
    }
}
StatusCellRendererComponent.decorators = [
    { type: Component, args: [{
                template: "<span [ngSwitch]=\"context.item.status\">\n  <ng-container *ngFor=\"let option of statusOptionsService.options\">\n    <i\n      *ngSwitchCase=\"option.key\"\n      [c8yIcon]=\"option.icon\"\n      class=\"{{ option.class }}\"\n      [tooltip]=\"option.label | translate\"\n      container=\"body\"\n      placement=\"top\"\n    ></i>\n  </ng-container>\n  <i\n    *ngSwitchDefault\n    c8yIcon=\"job\"\n    class=\"text-primary\"\n    [tooltip]=\"context.item.status\"\n    container=\"body\"\n    placement=\"top\"\n  ></i>\n</span>\n"
            },] }
];
StatusCellRendererComponent.ctorParameters = () => [
    { type: CellRendererContext },
    { type: StatusOptionsService }
];

class StatusGridColumn extends BaseDeviceGridColumn {
    constructor(statusOptionsService, initialColumnConfig) {
        super(initialColumnConfig);
        this.name = 'status';
        this.path = 'status';
        this.header = gettext('Status');
        this.dataType = "icon" /* Icon */;
        this.cellRendererComponent = StatusCellRendererComponent;
        this.filterable = true;
        this.resizable = false;
        this.filteringConfig = {
            fields: [
                {
                    key: 'statusOptions',
                    type: 'object',
                    templateOptions: {
                        label: gettext('Show devices with status')
                    },
                    fieldGroup: [
                        ...statusOptionsService.options.map(option => ({
                            key: option.key,
                            type: 'switch',
                            templateOptions: {
                                label: option.label
                            }
                        }))
                    ]
                },
                ...getBasicInputArrayFormFieldConfig({
                    key: 'custom',
                    label: gettext('or filter by custom status'),
                    addText: gettext('Add next`custom status`'),
                    tooltip: gettext('Use * as a wildcard character'),
                    placeholder: gettext('restarting`SERVICE_STATUS`'),
                    optional: true
                })
            ],
            getFilter(model) {
                const filter = {};
                filter.status = {
                    __in: [
                        ...entries((model === null || model === void 0 ? void 0 : model.statusOptions) || {})
                            .filter(([_, value]) => !!value)
                            .map(([key, _]) => key),
                        ...model.custom.filter(c => !!c)
                    ]
                };
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: this.path }]
        };
    }
}

const SERVICE_FRAGMENT$1 = 'c8y_Service';
class ServicesDeviceTabComponent {
    constructor(route, inventoryService, gridService, statusOptionsService) {
        this.route = route;
        this.inventoryService = inventoryService;
        this.gridService = gridService;
        this.statusOptionsService = statusOptionsService;
        this.deviceId = this.route.snapshot.parent.data.contextData.id;
        this.sizeRequestDone = false;
        this.refresh$ = new EventEmitter();
        this.pagination = {
            pageSize: 50,
            currentPage: 1
        };
        this.columns = [
            new StatusGridColumn(this.statusOptionsService),
            new ServiceNameGridColumn(),
            new ServiceTypeGridColumn(),
            new LastUpdatedDateGridColumn()
        ];
        this.queriesUtil = new QueriesUtil();
        this.serverSideDataCallback = this.onDataSourceModifier.bind(this);
        this.sizeRequest = this.inventoryService
            .childAdditionsList(this.deviceId, {
            query: `type eq ${SERVICE_FRAGMENT$1}`,
            withTotalPages: true,
            pageSize: 1
        })
            .then(response => {
            var _a;
            this.sizeRequestDone = true;
            return (_a = response === null || response === void 0 ? void 0 : response.paging) === null || _a === void 0 ? void 0 : _a.totalPages;
        });
    }
    onDataSourceModifier(dataSourceModifier) {
        return __awaiter(this, void 0, void 0, function* () {
            let serverSideDataResult;
            const query = this.queriesUtil.buildQuery(this.queriesUtil.addAndFilter(this.gridService.getQueryObj(dataSourceModifier.columns), {
                type: SERVICE_FRAGMENT$1
            }));
            const dataRequest = this.inventoryService.childAdditionsList(this.deviceId, {
                query,
                withTotalPages: true,
                pageSize: dataSourceModifier.pagination.pageSize,
                currentPage: dataSourceModifier.pagination.currentPage
            });
            const filtererdSizeRequest = this.inventoryService
                .childAdditionsList(this.deviceId, {
                query,
                withTotalPages: true,
                pageSize: 1
            })
                .then(response => { var _a; return (_a = response === null || response === void 0 ? void 0 : response.paging) === null || _a === void 0 ? void 0 : _a.totalPages; });
            const [dataResponse, size, filteredSize] = yield Promise.all([
                dataRequest,
                this.sizeRequest,
                filtererdSizeRequest
            ]);
            const { res, data, paging } = dataResponse;
            serverSideDataResult = {
                res,
                data,
                paging,
                filteredSize,
                size
            };
            return serverSideDataResult;
        });
    }
    trackByName(_index, column) {
        return column.name;
    }
}
ServicesDeviceTabComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-services-device-tab',
                template: "<div class=\"content-fullpage\">\n  <c8y-data-grid\n    [title]=\"'Services' | translate\"\n    [refresh]=\"refresh$\"\n    [actionControls]=\"[]\"\n    [pagination]=\"pagination\"\n    [columns]=\"columns\"\n    [infiniteScroll]=\"'auto'\"\n    [serverSideDataCallback]=\"serverSideDataCallback\"\n  >\n    <div class=\"c8y-empty-state\">\n      <ng-container *ngIf=\"!sizeRequestDone\">\n        <c8y-loading></c8y-loading>\n      </ng-container>\n      <ng-container *ngIf=\"sizeRequestDone\">\n        <ng-container *ngIf=\"(sizeRequest | async) === 0; else noResults\">\n          <div class=\"text-center\">\n            <h1 class=\"c8y-icon-duocolor\" c8yIcon=\"c8y-tools\"></h1>\n            <h3 translate>No services to display.</h3>\n          </div>\n        </ng-container>\n        <ng-template #noResults>\n          <h1 c8yIcon=\"search\"></h1>\n          <div>\n            <p>\n              <strong>{{ 'No results to display.' | translate }}</strong>\n            </p>\n            <small>{{ 'Refine your search terms or check your spelling.' | translate }}</small>\n          </div>\n        </ng-template>\n      </ng-container>\n    </div>\n    <ng-container *ngFor=\"let column of columns; trackBy: trackByName\">\n      <c8y-column [name]=\"column.name\"></c8y-column>\n    </ng-container>\n  </c8y-data-grid>\n</div>\n"
            },] }
];
ServicesDeviceTabComponent.ctorParameters = () => [
    { type: ActivatedRoute },
    { type: InventoryService },
    { type: DeviceGridService },
    { type: StatusOptionsService }
];

const SERVICE_FRAGMENT = 'c8y_Service';
class ServicesDeviceTabGuard {
    constructor(inventoryService) {
        this.inventoryService = inventoryService;
    }
    canActivate(route) {
        const contextData = get(route, 'data.contextData') || get(route, 'parent.data.contextData');
        return this.inventoryService
            .childAdditionsList(contextData, { query: `type eq ${SERVICE_FRAGMENT}`, pageSize: 1 })
            .then(result => { var _a; return !!((_a = result === null || result === void 0 ? void 0 : result.data) === null || _a === void 0 ? void 0 : _a.length); });
    }
}
ServicesDeviceTabGuard.decorators = [
    { type: Injectable }
];
ServicesDeviceTabGuard.ctorParameters = () => [
    { type: InventoryService }
];

class ServicesBreadcrumbFactory {
    constructor(inventoryService) {
        this.inventoryService = inventoryService;
    }
    get(route) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            const { context, contextData } = route.snapshot.data;
            const { routeConfig } = route.snapshot;
            this.contextData = contextData || this.contextData;
            if ((context === ViewContext.Service || ((_a = routeConfig) === null || _a === void 0 ? void 0 : _a.context) === ViewContext.Service) &&
                !!this.contextData) {
                const serviceMO = (_b = (yield this.inventoryService.detail(this.contextData, { withParents: true }))) === null || _b === void 0 ? void 0 : _b.data;
                const breadcrumb = { items: [] };
                const breadcrumbItems = [];
                const device = (_d = (_c = serviceMO === null || serviceMO === void 0 ? void 0 : serviceMO.additionParents) === null || _c === void 0 ? void 0 : _c.references[0]) === null || _d === void 0 ? void 0 : _d.managedObject;
                if (device) {
                    breadcrumbItems.push({
                        label: device.name,
                        path: `/device/${device.id}`
                    });
                    breadcrumbItems.push({
                        label: gettext('Services'),
                        path: `/device/${device.id}/services`
                    });
                    breadcrumbItems.push({
                        label: serviceMO.name
                    });
                }
                breadcrumb.items = breadcrumbItems;
                return breadcrumb;
            }
        });
    }
}
ServicesBreadcrumbFactory.decorators = [
    { type: Injectable }
];
ServicesBreadcrumbFactory.ctorParameters = () => [
    { type: InventoryService }
];

const ɵ0 = [
    {
        context: ViewContext.Device,
        path: 'services',
        component: ServicesDeviceTabComponent,
        label: gettext('Services'),
        icon: 'statistics',
        priority: 500,
        canActivate: [ServicesDeviceTabGuard]
    }
];
class ServicesDeviceTabModule {
}
ServicesDeviceTabModule.decorators = [
    { type: NgModule, args: [{
                imports: [CoreModule, RouterModule, TooltipModule],
                declarations: [
                    ServicesDeviceTabComponent,
                    LastUpdatedDateCellRendererComponent,
                    NameCellRendererComponent,
                    StatusCellRendererComponent
                ],
                providers: [
                    ServicesDeviceTabGuard,
                    ServicesBreadcrumbFactory,
                    {
                        provide: HOOK_ROUTE,
                        useValue: ɵ0,
                        multi: true
                    },
                    { provide: HOOK_BREADCRUMB, useClass: ServicesBreadcrumbFactory, multi: true }
                ]
            },] }
];

class ServicesModule {
}
ServicesModule.decorators = [
    { type: NgModule, args: [{
                imports: [CoreModule, ServicesDeviceTabModule]
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { HOOK_SERVICE_STATUS, LastUpdatedDateCellRendererComponent, LastUpdatedDateGridColumn, NameCellRendererComponent, SERVICE_STATUS_OPTIONS, ServiceNameGridColumn, ServiceTypeGridColumn, ServicesDeviceTabComponent, ServicesDeviceTabGuard, ServicesDeviceTabModule, ServicesModule, StatusCellRendererComponent, StatusGridColumn, StatusOptionsService, ɵ0, ServicesDeviceTabModule as ɵa };
//# sourceMappingURL=c8y-ngx-components-services.js.map
