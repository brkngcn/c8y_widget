import { __awaiter } from 'tslib';
import { Component, Injectable, NgModule } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { ManagedObjectRealtimeService, ViewContext, gettext, CoreModule, HOOK_ROUTE } from '@c8y/ngx-components';
import { DeviceGridService, DeviceGridModule } from '@c8y/ngx-components/device-grid';
import { PopoverModule } from 'ngx-bootstrap/popover';
import { InventoryService } from '@c8y/client';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/router';
import * as ɵngcc2 from '@c8y/ngx-components/device-grid';
import * as ɵngcc3 from '@c8y/ngx-components';
import * as ɵngcc4 from '@c8y/client';
class ChildDevicesComponent {
    constructor(route, deviceGridService) {
        this.route = route;
        this.deviceGridService = deviceGridService;
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.getAllDevices();
            this.columns = this.deviceGridService.getChildDeviceGridColumns();
        });
    }
    getAllDevices() {
        return __awaiter(this, void 0, void 0, function* () {
            this.id = this.route.snapshot.parent.data.contextData;
        });
    }
}
ChildDevicesComponent.ɵfac = function ChildDevicesComponent_Factory(t) { return new (t || ChildDevicesComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.ActivatedRoute), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.DeviceGridService)); };
ChildDevicesComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ChildDevicesComponent, selectors: [["c8y-child-devices"]], features: [ɵngcc0.ɵɵProvidersFeature([ManagedObjectRealtimeService])], decls: 2, vars: 6, consts: [[1, "flex-grow", "col-xs-12", "no-gutter", 3, "title", "childDeviceGrid", "columns", "parentDeviceId"]], template: function ChildDevicesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "c8y-device-grid", 0);
        ɵngcc0.ɵɵpipe(1, "translate");
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("title", ɵngcc0.ɵɵpipeBind1(1, 4, "Child devices"))("childDeviceGrid", true)("columns", ctx.columns)("parentDeviceId", ctx.id);
    } }, directives: [ɵngcc2.DeviceGridComponent], pipes: [ɵngcc3.C8yTranslatePipe], encapsulation: 2 });
ChildDevicesComponent.ctorParameters = () => [
    { type: ActivatedRoute },
    { type: DeviceGridService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ChildDevicesComponent, [{
        type: Component,
        args: [{
                selector: 'c8y-child-devices',
                template: "<c8y-device-grid\n  [title]=\"'Child devices' | translate\"\n  class=\"flex-grow col-xs-12 no-gutter\"\n  [childDeviceGrid]=\"true\"\n  [columns]=\"columns\"\n  [parentDeviceId]=\"id\"\n>\n</c8y-device-grid>\n",
                providers: [ManagedObjectRealtimeService]
            }]
    }], function () { return [{ type: ɵngcc1.ActivatedRoute }, { type: ɵngcc2.DeviceGridService }]; }, null); })();

class ChildDevicesTabGuard {
    constructor(inventory) {
        this.inventory = inventory;
    }
    canActivate(route) {
        return __awaiter(this, void 0, void 0, function* () {
            const contextData = route.data.contextData;
            const filter = {
                pageSize: 1
            };
            if (!contextData) {
                return true;
            }
            const device = yield this.inventory.childDevicesList(contextData.id, filter);
            const hasChildren = device.data.length;
            const isVendme = route.data.contextData.type === 'com_nsn_startups_vendme_VendingMachine';
            return hasChildren && !isVendme;
        });
    }
}
ChildDevicesTabGuard.ɵfac = function ChildDevicesTabGuard_Factory(t) { return new (t || ChildDevicesTabGuard)(ɵngcc0.ɵɵinject(ɵngcc4.InventoryService)); };
ChildDevicesTabGuard.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ChildDevicesTabGuard, factory: ChildDevicesTabGuard.ɵfac });
ChildDevicesTabGuard.ctorParameters = () => [
    { type: InventoryService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ChildDevicesTabGuard, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc4.InventoryService }]; }, null); })();

const ɵ0 = [
    {
        context: ViewContext.Device,
        path: 'child-devices',
        priority: 1000,
        icon: 'code-fork',
        label: gettext('Child devices'),
        component: ChildDevicesComponent,
        canActivate: [ChildDevicesTabGuard]
    }
];
class ChildDevicesModule {
}
ChildDevicesModule.ɵfac = function ChildDevicesModule_Factory(t) { return new (t || ChildDevicesModule)(); };
ChildDevicesModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: ChildDevicesModule });
ChildDevicesModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ providers: [
        ChildDevicesTabGuard,
        {
            provide: HOOK_ROUTE,
            useValue: ɵ0,
            multi: true
        }
    ], imports: [[CoreModule, DeviceGridModule, PopoverModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ChildDevicesModule, [{
        type: NgModule,
        args: [{
                declarations: [ChildDevicesComponent],
                imports: [CoreModule, DeviceGridModule, PopoverModule],
                entryComponents: [ChildDevicesComponent],
                providers: [
                    ChildDevicesTabGuard,
                    {
                        provide: HOOK_ROUTE,
                        useValue: ɵ0,
                        multi: true
                    }
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ChildDevicesModule, { declarations: function () { return [ChildDevicesComponent]; }, imports: function () { return [CoreModule, DeviceGridModule, PopoverModule]; } }); })();

/**
 * Generated bundle index. Do not edit.
 */

export { ChildDevicesComponent, ChildDevicesModule, ɵ0, ChildDevicesTabGuard as ɵa };

//# sourceMappingURL=c8y-ngx-components-child-devices.js.map