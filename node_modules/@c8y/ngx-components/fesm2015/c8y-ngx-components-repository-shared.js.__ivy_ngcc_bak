import { Injectable, Component, Input, EventEmitter, forwardRef, ChangeDetectorRef, ViewChild, Output, NgModule } from '@angular/core';
import { Service, FetchClient, ApplicationService, QueriesUtil, OperationStatus, InventoryService, InventoryBinaryService, OperationService, EventService, EventBinaryService } from '@c8y/client';
import { __awaiter, __decorate } from 'tslib';
import { gettext, AlertService, OperationRealtimeService, memoize, ModalSelectionMode, CoreModule, FormsModule } from '@c8y/ngx-components';
import { isNil, set, assign, isUndefined, get, isString, head, cloneDeep, map as map$1, omitBy, pick, remove, forEach, find, has, isEmpty, isEqual, uniqBy } from 'lodash-es';
import { of, from, defer, throwError, merge, Subject, BehaviorSubject, pipe } from 'rxjs';
import { map, take, switchMap, withLatestFrom, filter, takeWhile, mergeMap, tap, debounceTime, shareReplay } from 'rxjs/operators';
import { saveAs } from 'file-saver';
import { TranslateService } from '@ngx-translate/core';
import { NG_VALUE_ACCESSOR, NG_VALIDATORS } from '@angular/forms';
import { CommonModule } from '@angular/common';
import { PopoverModule } from 'ngx-bootstrap/popover';

class AdvancedSoftwareService extends Service {
    constructor(client, applicationService) {
        super(client);
        this.applicationService = applicationService;
        this.baseUrl = 'service/advanced-software-mgmt';
        this.listUrl = 'software';
        this.propertyName = 'softwareList';
    }
    list(filter = {}) {
        return super.list(filter);
    }
    isASMAvailable() {
        if (this.isAvailable === undefined) {
            this.isAvailable = this.applicationService
                .isAvailable(AdvancedSoftwareService.applicationName)
                .then(result => !!(result === null || result === void 0 ? void 0 : result.data));
        }
        return this.isAvailable;
    }
}
AdvancedSoftwareService.applicationName = 'advanced-software-mgmt';
AdvancedSoftwareService.decorators = [
    { type: Injectable }
];
AdvancedSoftwareService.ctorParameters = () => [
    { type: FetchClient },
    { type: ApplicationService }
];

var RepositoryType;
(function (RepositoryType) {
    RepositoryType["FIRMWARE"] = "c8y_Firmware";
    RepositoryType["SOFTWARE"] = "c8y_Software";
    RepositoryType["CONFIGURATION"] = "c8y_ConfigurationDump";
})(RepositoryType || (RepositoryType = {}));
const REPOSITORY_BINARY_TYPES = {
    [RepositoryType.SOFTWARE]: 'c8y_SoftwareBinary',
    [RepositoryType.FIRMWARE]: 'c8y_FirmwareBinary',
    [RepositoryType.CONFIGURATION]: 'c8y_ConfigurationDumpBinary'
};
var DeviceConfigurationOperation;
(function (DeviceConfigurationOperation) {
    DeviceConfigurationOperation["UPLOAD_CONFIG"] = "c8y_UploadConfigFile";
    DeviceConfigurationOperation["DOWNLOAD_CONFIG"] = "c8y_DownloadConfigFile";
    DeviceConfigurationOperation["CONFIG"] = "c8y_Configuration";
    DeviceConfigurationOperation["SEND_CONFIG"] = "c8y_SendConfiguration";
})(DeviceConfigurationOperation || (DeviceConfigurationOperation = {}));

class RepositoryService {
    constructor(inventory, inventoryBinary, operation, alert, event, operationRealtime, eventBinary, advancedSoftwareService) {
        this.inventory = inventory;
        this.inventoryBinary = inventoryBinary;
        this.operation = operation;
        this.alert = alert;
        this.event = event;
        this.operationRealtime = operationRealtime;
        this.eventBinary = eventBinary;
        this.advancedSoftwareService = advancedSoftwareService;
        this.dateFrom = new Date(0);
        this.dateTo = new Date(Date.now() + 86400000); // 1 day in the future
        this.queriesUtil = new QueriesUtil();
    }
    /**
     * Lists repository entries of given type.
     * @param type The type of repository entries to list.
     * @param options Extra listing options.
     */
    listRepositoryEntries(type, options) {
        const defaultOrder = [{ name: 1 }];
        const defaultFilters = { type };
        const legacyFilters = { __has: `url` };
        let filters = {};
        let fullQuery = (options && options.query) || {};
        if (!options || (options && !options.skipDefaultOrder)) {
            fullQuery = this.queriesUtil.addOrderbys(fullQuery, defaultOrder, 'prepend');
        }
        fullQuery = this.queriesUtil.addAndFilter(fullQuery, defaultFilters);
        if (options && options.partialTextFilter) {
            const { partialText, properties } = options.partialTextFilter;
            const orFilter = { __or: properties.map(property => ({ [property]: `*${partialText}*` })) };
            fullQuery = this.queriesUtil.addAndFilter(fullQuery, orFilter);
        }
        if (options && options.partialName) {
            // backwards compatibility if
            fullQuery = this.queriesUtil.addAndFilter(fullQuery, { name: `*${options.partialName}*` });
        }
        if (options && options.skipLegacy) {
            fullQuery = this.queriesUtil.addAndFilter(fullQuery, { __not: legacyFilters });
        }
        filters = Object.assign({ query: this.queriesUtil.buildQuery(fullQuery), pageSize: 50, withTotalPages: true }, ((options && options.params) || {}));
        return this.inventory.list(filters);
    }
    // TODO: merge with create()
    save(data, type, mo = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (type) {
                case RepositoryType.CONFIGURATION: {
                    Object.assign(mo, {
                        type: RepositoryType.CONFIGURATION,
                        configurationType: data.selected ? data.selected.configurationType : undefined,
                        name: data.version,
                        description: data.description,
                        deviceType: data.deviceType,
                        c8y_Global: {}
                    });
                    if (!data.deviceType && mo.id) {
                        mo.deviceType = null;
                    }
                    if (!data.selected && mo.id) {
                        mo.configurationType = null;
                    }
                    break;
                }
            }
            const existingUrl = mo.url;
            if (data.binary.url) {
                mo.url = data.binary.url;
            }
            else if (data.binary.file) {
                const response = yield this.inventoryBinary.create(data.binary.file, {
                    c8y_Global: {}
                });
                mo.url = response.data.self;
            }
            if (mo.id) {
                return this.updateEntry(mo, existingUrl);
            }
            return this.createEntry(mo);
        });
    }
    create(modal, type) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (type) {
                case RepositoryType.FIRMWARE:
                case RepositoryType.SOFTWARE:
                    return this.createFirmwareOrSoftware(modal, type);
            }
        });
    }
    createFirmwareOrSoftware(modal, type) {
        return __awaiter(this, void 0, void 0, function* () {
            let binary;
            let binaryURL;
            let repositoryEntry;
            let repositoryBinary;
            const mos = [];
            const { selected: { id: selectedId }, binary: { file, url } } = modal;
            try {
                if (file) {
                    ({ data: binary } = yield this.saveBinary(file));
                    ({ self: binaryURL } = binary);
                    mos.push(binary);
                }
                else {
                    binaryURL = url;
                }
                ({ data: repositoryEntry } = yield this.createOrUpdateRepositoryEntry(modal, type));
                if (isNil(selectedId)) {
                    mos.push(repositoryEntry);
                }
                ({ data: repositoryBinary } = yield this.createRepositoryBinary(modal, binaryURL, type, repositoryEntry));
                mos.push(repositoryBinary);
                if (file) {
                    yield this.linkBinary(repositoryBinary, binary);
                }
                return repositoryEntry;
            }
            catch (error) {
                this.cleanUp(mos);
                this.errorMsg();
                // Propagate error
                throw error;
            }
        });
    }
    saveBinary(file) {
        return this.inventoryBinary.create(file, { c8y_Global: {} });
    }
    createOrUpdateRepositoryEntry(modal, type) {
        const { selected: { id, name }, description, deviceType } = modal;
        const mo = {
            id,
            name: id ? undefined : name,
            description,
            type: id ? undefined : type,
            c8y_Global: {}
        };
        if (deviceType) {
            set(mo, 'c8y_Filter.type', deviceType);
        }
        if (modal.softwareType) {
            set(mo, 'softwareType', modal.softwareType.softwareType);
        }
        return id
            ? this.inventory.update(mo)
            : this.inventory.create(mo);
    }
    createRepositoryBinary(modal, binaryURL, type, parent) {
        const mo = this.prepareRepositoryBinaryMO(modal, binaryURL, type);
        return this.inventory.childAdditionsCreate(mo, parent);
    }
    prepareRepositoryBinaryMO(modal, binaryURL, type) {
        const { version, patchVersion, dependency } = modal;
        const result = {
            type: REPOSITORY_BINARY_TYPES[type],
            [type]: {
                url: binaryURL
            },
            c8y_Global: {}
        };
        if (dependency) {
            set(result, [type, 'version'], patchVersion);
            assign(result, {
                c8y_Patch: {
                    dependency: dependency.c8y_Firmware.version
                }
            });
        }
        else {
            set(result, [type, 'version'], version);
        }
        return result;
    }
    linkBinary(repositoryBinary, binary) {
        return __awaiter(this, void 0, void 0, function* () {
            const { id: repositoryBinaryId } = repositoryBinary;
            if (binary) {
                const { id: binaryId } = binary;
                return this.inventory.childAdditionsAdd(binaryId, repositoryBinaryId);
            }
        });
    }
    cleanUp(mosToDelete) {
        mosToDelete.forEach(mo => {
            const { c8y_IsBinary } = mo;
            isUndefined(c8y_IsBinary) ? this.delete(mo) : this.inventoryBinary.delete(mo);
        });
    }
    delete(entity) {
        return this.inventory.delete(entity, { forceCascade: true });
    }
    errorMsg() {
        const msg = gettext('Failed to save');
        this.alert.danger(msg);
    }
    getBaseVersionsCount$(entry) {
        if (this.isLegacyEntry(entry)) {
            return of(1);
        }
        return from(this.listBaseVersions(entry, { pageSize: 1, withTotalPages: true })).pipe(map(({ paging }) => paging.totalPages));
    }
    getBaseVersionFromMO(mo) {
        return this.isPatch(mo) ? get(mo, 'c8y_Patch.dependency') : get(mo, 'c8y_Firmware.version');
    }
    isPatch(mo) {
        return !!get(mo, 'c8y_Patch.dependency');
    }
    getPatchVersionsCount$(entry, baseVersion) {
        if (this.isLegacyEntry(baseVersion)) {
            return of(0);
        }
        return from(this.listPatchVersions(entry, baseVersion, { pageSize: 1, withTotalPages: true })).pipe(map(({ paging }) => paging.totalPages));
    }
    isLegacyEntry(entry) {
        return Boolean(entry.url);
    }
    /**
     * Lists all versions (base and patch ones) of given top level entry.
     * Versions are ordered by creation time (assuming the earlier created, the older the version).
     * @param entry Top level repository entry.
     * @param params Additional query params.
     */
    listAllVersions(entry, params = {}) {
        if (this.isLegacyEntry(entry)) {
            return this.getBaseVersionResultListForLegacyEntry(entry);
        }
        const VERSION_FILTER_ORDER = {
            __filter: {},
            __orderby: [{ 'creationTime.date': -1 }, { creationTime: -1 }]
        };
        return this.listChildren(entry, VERSION_FILTER_ORDER, params);
    }
    /**
     * Lists base versions of given top level entry.
     * Versions are ordered by creation time (assuming the earlier created, the older the version).
     * @param entry Top level repository entry.
     * @param params Additional query params.
     */
    listBaseVersions(entry, params = {}) {
        if (this.isLegacyEntry(entry)) {
            return this.getBaseVersionResultListForLegacyEntry(entry);
        }
        const NO_PATCH_FILTER_ORDER = {
            __filter: {
                __not: { __has: 'c8y_Patch' }
            },
            __orderby: [{ 'creationTime.date': -1 }, { creationTime: -1 }]
        };
        return this.listChildren(entry, NO_PATCH_FILTER_ORDER, params);
    }
    /**
     * Lists patch versions of given base version under the entry.
     * Versions are ordered by creation time (assuming the earlier created, the older the version).
     * @param entry Top level repository entry.
     * @param baseVersion Base version.
     * @param params Additional query params.
     */
    listPatchVersions(entry, baseVersion, params = {}) {
        const version = isString(baseVersion) ? baseVersion : get(baseVersion, 'c8y_Firmware.version');
        const PATCH_FILTER_ORDER = {
            __filter: {
                'c8y_Patch.dependency': version
            },
            __orderby: [{ 'creationTime.date': -1 }, { creationTime: -1 }]
        };
        return this.listChildren(entry, PATCH_FILTER_ORDER, params);
    }
    /**
     * Lists patch versions of given base version under the entry including the base version.
     * Versions are ordered by creation time (assuming the earlier created, the older the version).
     * In terms of legacy base version the entry gets transformed to fit the needed data model.
     * @param entry Top level repository entry.
     * @param baseVersion Base version.
     * @param params Additional query params.
     */
    listBaseVersionAndPatches(entry, baseVersion, params = {}) {
        if (this.isLegacyEntry(entry)) {
            return Promise.resolve({
                data: [
                    Object.assign({
                        c8y_Firmware: {
                            version: entry.version,
                            url: entry.url
                        }
                    }, entry)
                ]
            });
        }
        const PATCH_FILTER_ORDER = {
            __filter: {
                __or: {
                    'c8y_Patch.dependency': baseVersion.c8y_Firmware.version,
                    'c8y_Firmware.version': baseVersion.c8y_Firmware.version
                }
            },
            __orderby: [{ 'c8y_Patch.dependency': 1 }, { 'c8y_Firmware.version': 1 }]
        };
        return this.listChildren(entry, PATCH_FILTER_ORDER, params);
    }
    listChildren(entry, filters = {}, params = {}) {
        const childrenFilters = { __bygroupid: entry.id };
        const query = this.queriesUtil.addAndFilter(filters, childrenFilters);
        // FIXME: needed because of issue in forOf directive (...)
        params.withTotalPages = true;
        return this.inventory.listQuery(query, params);
    }
    /**
     * Fetches all items from the list starting with the provided page.
     * @param firstPage The first page of the list to fetch all items for.
     */
    fetchAllItemsFromList(firstPage) {
        return __awaiter(this, void 0, void 0, function* () {
            let allItems;
            if (!firstPage.then) {
                allItems = [...firstPage];
            }
            else {
                let { paging, data: items } = yield firstPage;
                allItems = [...items];
                while (paging && paging.nextPage) {
                    ({ paging, data: items } = yield paging.next());
                    allItems = [...allItems, ...items];
                }
            }
            return allItems;
        });
    }
    /**
     * Gets top level repository entry managed object for base or patch version.
     * @param mo Base or patch version managed object with parents.
     */
    getRepositoryEntryMO$(mo) {
        if (!mo) {
            return of(undefined);
        }
        const [reference] = get(mo, 'additionParents.references');
        const id = get(reference, 'managedObject.id');
        return id
            ? from(this.inventory.detail(id, { withChildren: false })).pipe(map(({ data }) => data))
            : of(undefined);
    }
    /**
     * Gets base or patch version managed object.
     * @param deviceRepositoryFragment Device repository fragment.
     * @param type Top level repository entry type.
     * @param configuration Configuration object with options:
     * - **skipLegacy** - `boolean` - Exclude legacy entries.
     * - **filters** - `object` - Filter object.
     *
     * @deprecated as it doesn't support 'missing url' case
     */
    getRepositoryBinaryMoByVersion(deviceRepositoryFragment, type, { skipLegacy = false, filters = {} } = {}) {
        const { version, url, name } = deviceRepositoryFragment;
        const repositoryBinaryType = REPOSITORY_BINARY_TYPES[type];
        let query;
        const newModelBaseVersionQuery = {
            [`${type}.version`]: version,
            [`${type}.url`]: url,
            type: repositoryBinaryType
        };
        const legacyVersionQuery = { url, type, name };
        filters = Object.assign({ withChildren: false, withParents: true }, filters);
        if (skipLegacy) {
            query = {
                __and: Object.assign({}, newModelBaseVersionQuery)
            };
        }
        else {
            query = {
                __or: [{ __and: Object.assign({}, newModelBaseVersionQuery) }, { __and: Object.assign({}, legacyVersionQuery) }]
            };
        }
        return this.inventory.listQuery(query, filters).then(({ data }) => head(data));
    }
    getBinaryName$(binaryUrl) {
        if (!binaryUrl) {
            return of('---');
        }
        const binaryId = this.inventoryBinary.getIdFromUrl(binaryUrl);
        if (!binaryId) {
            return of(binaryUrl);
        }
        return defer(() => this.inventory.detail(binaryId).then(result => result.data)).pipe(map(mo => mo.name));
    }
    /**
     * Generates an inventory query object which can be used to find
     * repository entries of specified type matching the type of provided device.
     * @param repositoryType The type of repository entries which will be queried with the generated query.
     * @param device The device for which matching repository entries will be queried with the generated query.
     */
    getDeviceTypeQuery(repositoryType, device) {
        let result = { type: repositoryType };
        if (repositoryType === RepositoryType.CONFIGURATION) {
            if (device.type) {
                result = this.queriesUtil.addAndFilter(result, {
                    __or: [{ deviceType: device.type }, { __not: { __has: `deviceType` } }]
                });
            }
        }
        else {
            result = this.queriesUtil.addAndFilter(result, {
                __or: [
                    { 'c8y_Filter.type': device.type },
                    { 'c8y_Filter.type': '' },
                    { __not: { __has: `c8y_Filter.type` } }
                ]
            });
        }
        return result;
    }
    /**
     * Generates an inventory query object which can be used to find
     * repository entries matching the predefined software types provided in the device.
     * @param device The device for which matching repository entries will be queried with the generated query.
     * @param query The query to which the software types filters will be attached. Default value is an object containg repository type software.
     */
    getSoftwareTypeQuery(device, query) {
        let result = Object.assign(Object.assign({}, (query || {})), { type: RepositoryType.SOFTWARE });
        if (device.c8y_SupportedSoftwareTypes) {
            result = this.queriesUtil.addAndFilter(result, {
                __or: [device.c8y_SupportedSoftwareTypes.map(type => ({ softwareType: type }))]
            });
        }
        return result;
    }
    /**
     * Generates an inventory query object which can be used to find configuration repository entries
     * matching the type of provided device and specified configuration type.
     * @param device The device for which matching repository entries will be queried with the generated query.
     * @param configurationType Configuration type for which matching repository entries will be queried with the generated query.
     */
    getConfigurationTypeQuery(device, configurationType) {
        const query = this.getDeviceTypeQuery(RepositoryType.CONFIGURATION, device);
        return this.queriesUtil.addAndFilter(query, {
            __or: [
                { configurationType },
                { configurationType: '' },
                { __not: { __has: `configurationType` } }
            ]
        });
    }
    /**
     * Gets the list of software installed in the device in the uniform format.
     * Supports c8y_SoftwareList and c8y_Software fragments.
     * @param device The device whose software list should be returned.
     */
    getDeviceSoftwareList(device) {
        if (device.c8y_SoftwareList) {
            return cloneDeep(device.c8y_SoftwareList);
        }
        if (device.c8y_Software) {
            return map$1(device.c8y_Software, (version, name) => ({ name, version }));
        }
        return [];
    }
    /**
     * Prepares a software update operation for given device and the list of changes, and sends it to the device.
     * @param device The device which the operation should be prepared for and sent to.
     * @param changes The list of software changes which should be applied.
     */
    createSoftwareUpdateOperation(device, changes) {
        return __awaiter(this, void 0, void 0, function* () {
            const operation = yield this.getSoftwareUpdateOperation(device, changes);
            return (yield this.operation.create(operation)).data;
        });
    }
    /**
     * Prepares a software update operation for given device and changes.
     * Returned operation type depends on device's supported operations.
     * Supports c8y_SoftwareUpdate, c8y_SoftwareList, and c8y_Software operations.
     * @param device The device for which operation should be prepared.
     * @param changes The list of software changes which should be applied.
     */
    getSoftwareUpdateOperation(device, changes) {
        return __awaiter(this, void 0, void 0, function* () {
            const operation = {
                deviceId: device.id,
                description: `Apply software changes: ${changes
                    .map(change => `${change.action} "${change.name}"${change.version ? ` (version: ${change.version})` : ''}`)
                    .join(', ')}`
            };
            if (device.c8y_SupportedOperations.includes('c8y_SoftwareUpdate')) {
                operation.c8y_SoftwareUpdate = (cloneDeep(changes) || []).map(change => omitBy(change, isNil));
            }
            else if (device.c8y_SupportedOperations.includes('c8y_SoftwareList')) {
                operation.c8y_SoftwareList = cloneDeep(yield this.getCurrentSoftware(device, 'c8y_SoftwareList', []));
                changes.forEach(change => {
                    const deviceSoftware = pick(omitBy(change, isNil), [
                        'name',
                        'version',
                        'url',
                        'softwareType'
                    ]);
                    if (change.action === 'delete') {
                        remove(operation.c8y_SoftwareList, deviceSoftware);
                    }
                    if (change.action === 'install') {
                        const softwareItemToUpdateIdx = operation.c8y_SoftwareList.findIndex(item => item.name === change.name);
                        if (softwareItemToUpdateIdx > -1) {
                            // update software
                            operation.c8y_SoftwareList.splice(softwareItemToUpdateIdx, 1, deviceSoftware);
                        }
                        else {
                            // install software
                            operation.c8y_SoftwareList.push(deviceSoftware);
                        }
                    }
                });
            }
            else if (device.c8y_SupportedOperations.includes('c8y_Software')) {
                operation.c8y_Software = cloneDeep(yield this.getCurrentSoftware(device, 'c8y_Software', {}));
                changes.forEach(change => {
                    if (change.action === 'delete') {
                        delete operation.c8y_Software[change.name];
                    }
                    if (change.action === 'install') {
                        operation.c8y_Software[change.name] = change.version;
                    }
                });
            }
            return operation;
        });
    }
    /**
     * Extracts the list of device software changes from given operation in the context of given device.
     * @param operation The operation from which the list should be extracted.
     * @param device The target device of the operation.
     */
    getDeviceSoftwareChangesFromOperation(operation, device) {
        return __awaiter(this, void 0, void 0, function* () {
            if (operation.c8y_SoftwareUpdate) {
                return cloneDeep(operation.c8y_SoftwareUpdate);
            }
            if (operation.c8y_SoftwareList) {
                return yield this.getDeviceSoftwareChangesFromSoftwareListOperation(operation, device);
            }
            if (operation.c8y_Software) {
                return yield this.getDeviceSoftwareChangesFromSoftwareOperation(operation, device);
            }
            return [];
        });
    }
    /**
     * Prepares a firmware update operation for given device and the selected repository binary, and sends it to the device.
     * @param device The device which the operation should be prepared for and sent to.
     * @param selectedOption The selected repository binary option.
     */
    createFirmwareUpdateOperation(device, selectedOption) {
        return __awaiter(this, void 0, void 0, function* () {
            const operation = this.getFirmwareUpdateOperation(device, selectedOption);
            return (yield this.operation.create(operation)).data;
        });
    }
    /**
     * Prepares a firmware update operation for given device and selected version.
     * Supports c8y_Firmware operation.
     * @param device The device for which operation should be prepared.
     * @param selectedOption Selected firmware version.
     */
    getFirmwareUpdateOperation(device, selectedOption) {
        delete selectedOption.id;
        const operation = {
            deviceId: device.id,
            description: `Update firmware to: "${selectedOption.name}"${selectedOption.version ? ` (version: ${selectedOption.version})` : ''}`,
            c8y_Firmware: Object.assign({}, selectedOption)
        };
        return operation;
    }
    /**
     * Prepares a configuration file upload operation for given device and configuration type.
     * @param device The device for which operation should be prepared.
     * @param configurationType Selected configuration type.
     * @param isLegacy  A legacy operation is created without a configurationType.
     */
    getUploadConfigurationFileOperation(device, configurationType, isLegacy = false) {
        if (isLegacy) {
            return {
                deviceId: device.id,
                description: `Retrieve configuration snapshot from device ${device.name}`,
                c8y_UploadConfigFile: {}
            };
        }
        return {
            deviceId: device.id,
            description: `Retrieve ${configurationType} configuration snapshot from device ${device.name}`,
            c8y_UploadConfigFile: {
                type: configurationType
            }
        };
    }
    /**
     * Prepares a configuration file download operation for given device and configuration type.
     * @param device The device for which operation should be prepared.
     * @param configurationType Selected configuration type.
     * @param binaryUrl The url of a binary to be downloaded.
     * @param isLegacy A legacy operation is created without a configurationType.
     */
    getDownloadConfigurationFileOperation(device, configurationType, configSnapshot, isLegacy = false) {
        if (isLegacy) {
            return {
                deviceId: device.id,
                description: `Send configuration snapshot ${configSnapshot.name} to device ${device.name}`,
                c8y_DownloadConfigFile: {
                    url: configSnapshot.binaryUrl,
                    c8y_ConfigurationDump: {
                        id: configSnapshot.id
                    }
                }
            };
        }
        return {
            deviceId: device.id,
            description: `Send configuration snapshot ${configSnapshot.name} of configuration type ${configurationType} to device ${device.name}`,
            c8y_DownloadConfigFile: {
                url: configSnapshot.binaryUrl,
                type: configurationType
            }
        };
    }
    /**
     * Gets the last firmware update operation for given device.
     * Looks for c8y_Firmware operations.
     * @param deviceId The ID of the device to find an operation for.
     */
    getLastFirmwareUpdateOperation(deviceId) {
        return __awaiter(this, void 0, void 0, function* () {
            const filters = {
                deviceId,
                dateFrom: new Date(0).toISOString(),
                dateTo: new Date(Date.now()).toISOString(),
                revert: true,
                pageSize: 1
            };
            return this.getFirstMatchingOperation([Object.assign(Object.assign({}, filters), { fragmentType: 'c8y_Firmware' })]);
        });
    }
    /**
     * Gets the last software update operation for given device.
     * Looks for c8y_SoftwareUpdate, c8y_SoftwareList, or c8y_Software operations.
     * @param deviceId The ID of the device to find an operation for.
     */
    getLastSoftwareUpdateOperation(deviceId) {
        return __awaiter(this, void 0, void 0, function* () {
            const filters = {
                deviceId,
                dateFrom: new Date(0).toISOString(),
                dateTo: new Date(Date.now()).toISOString(),
                revert: true,
                pageSize: 1
            };
            return this.getLatestMatchingOperation([
                Object.assign(Object.assign({}, filters), { fragmentType: 'c8y_SoftwareUpdate' }),
                Object.assign(Object.assign({}, filters), { fragmentType: 'c8y_SoftwareList' }),
                Object.assign(Object.assign({}, filters), { fragmentType: 'c8y_Software' })
            ]);
        });
    }
    /**
     * Iterates over the list of filters and queries the operations.
     * If a query returns at least one operation, the first one will be returned.
     * Otherwise the next query will be performed.
     * If none of the queries returns any operation, null will be returned.
     * @param filtersList The list of filters for the queries.
     */
    getFirstMatchingOperation(filtersList) {
        return __awaiter(this, void 0, void 0, function* () {
            let matchingOperation = null;
            for (const filters of filtersList) {
                const operations = (yield this.operation.list(filters)).data;
                if (operations.length) {
                    matchingOperation = operations[0];
                    break;
                }
            }
            return matchingOperation;
        });
    }
    /**
     * Iterates over the list of filters and queries the operations.
     * It compares the operations retrieved by the queries by 'creationTime'
     * and return the latest one.
     * If none of the queries returns any operation, null will be returned.
     * @param filtersList The list of filters for the queries.
     */
    getLatestMatchingOperation(filtersList) {
        return __awaiter(this, void 0, void 0, function* () {
            let matchingOperation = null;
            for (const filters of filtersList) {
                const operations = (yield this.operation.list(filters)).data;
                if (operations.length) {
                    if (matchingOperation) {
                        matchingOperation =
                            new Date(matchingOperation.creationTime).getTime() <
                                new Date(operations[0].creationTime).getTime()
                                ? operations[0]
                                : matchingOperation;
                    }
                    else {
                        matchingOperation = operations[0];
                    }
                }
            }
            return matchingOperation;
        });
    }
    /**
     * Creates the operation and returns an observable to track its progress.
     * Fails the observable when the operation returns FAILED status.
     * Completes the observable when the operation returns SUCCESSFUL status.
     * @param operation The operation to create and track.
     */
    createObservedOperation(operation) {
        return from(this.operation.create(operation)).pipe(map(({ data }) => data), take(1), switchMap(createdOperation => this.observeOperation(createdOperation)));
    }
    /**
     * Returns an observable to track progress of given operation.
     * Fails the observable when the operation returns FAILED status.
     * Completes the observable when the operation returns SUCCESSFUL status.
     * @param operation The operation to be observed.
     */
    observeOperation(operation) {
        const observedOperation$ = of(operation);
        const operationUpdates$ = observedOperation$.pipe(switchMap(observedOperation => this.operationRealtime.onAll$(observedOperation.deviceId)), map(({ data }) => data), withLatestFrom(observedOperation$), filter(([operationUpdate, observedOperation]) => operationUpdate.id === observedOperation.id), switchMap(([operationUpdate]) => {
            if (operationUpdate.status === OperationStatus.FAILED) {
                return throwError(operationUpdate);
            }
            return of(operationUpdate);
        }), takeWhile(operationUpdate => operationUpdate.status !== OperationStatus.SUCCESSFUL, true));
        return merge(observedOperation$, operationUpdates$);
    }
    /**
     * Gets a single event with latest creationTime for the given device Id and event type.
     * @param deviceId The device Id for which the events should be queried.
     * @param type Event type.
     */
    getLatestConfigurationEvent(deviceId, type) {
        return __awaiter(this, void 0, void 0, function* () {
            const eventFilter = {
                source: deviceId,
                type,
                dateFrom: this.dateFrom.toISOString(),
                dateTo: this.dateTo.toISOString(),
                pageSize: 1
            };
            const { data } = yield this.event.list(eventFilter);
            return data[0];
        });
    }
    /**
     * Gets a list of operations for the given device Id, and operation type.
     * @param deviceId The device Id for which the operation should be queried.
     * @param operationType Operation type fragment.
     */
    getConfigFileOperationList(deviceId, operationType) {
        return __awaiter(this, void 0, void 0, function* () {
            const operationFilter = {
                deviceId,
                fragmentType: operationType,
                dateFrom: this.dateFrom.toISOString(),
                dateTo: this.dateTo.toISOString(),
                revert: true,
                pageSize: 2000
            };
            return (yield this.operation.list(operationFilter)).data;
        });
    }
    /**
     * Gets latest uploaded configuration snapshot for the given device, and configuration type.
     * @param device The device for which the configuration snapshot was uploaded.
     * @param configurationType Selected configuration type.
     */
    getConfigSnapshot(device, configurationType) {
        return __awaiter(this, void 0, void 0, function* () {
            const event = yield this.getLatestConfigurationEvent(device.id, configurationType);
            let configSnapshot;
            if (event) {
                configSnapshot = {
                    time: event.time,
                    name: event.text,
                    deviceType: device.type,
                    configurationType
                };
                try {
                    configSnapshot.binary = yield (yield this.eventBinary.download(event)).text();
                    if (event.c8y_IsBinary) {
                        configSnapshot.binaryType = event.c8y_IsBinary.type;
                    }
                }
                catch (ex) {
                    const msg = gettext('Could not get the binary.');
                    this.alert.danger(msg);
                }
            }
            return configSnapshot;
        });
    }
    getLegacyConfigSnapshot(deviceId) {
        return __awaiter(this, void 0, void 0, function* () {
            let configSnapshot;
            let mo;
            const device = (yield this.inventory.detail(deviceId, { withChildren: false })).data;
            const snapshotId = device.c8y_ConfigurationDump && device.c8y_ConfigurationDump.id;
            if (!snapshotId) {
                return;
            }
            try {
                mo = (yield this.inventory.detail(snapshotId)).data;
            }
            catch (ex) {
                // do nothing
            }
            if (mo) {
                configSnapshot = {
                    time: mo.creationTime,
                    name: mo.name
                };
                configSnapshot.binary = yield this.getBinaryText(mo.url, { allowExternal: false });
            }
            return configSnapshot;
        });
    }
    /**
     * Returns a binary object as text.
     * @param binaryUrl The URL to find binary
     * @param options The object with additional options:
     * - **allowExternal** - `boolean` - allows downloading external binary file
     * - **noAlerts** - `boolean` - do not display an alert message; defaults to `false`
     */
    getBinaryText(binaryUrl, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const binaryId = this.inventoryBinary.getIdFromUrl(binaryUrl);
            let res;
            if (!binaryId) {
                if (options.allowExternal) {
                    res = yield this.getExternalBinaryResponse(binaryUrl, options);
                }
            }
            else {
                res = yield this.getInternalBinaryResponse(binaryId, options);
            }
            if (!res) {
                return null;
            }
            return res.text();
        });
    }
    /**
     * Returns a binary object as File.
     * @param binaryUrl The URL to find binary
     * @param options The object with additional options:
     * - **allowExternal** - `boolean` - allows downloading external binary file
     */
    getBinaryFile(binaryUrl, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const binaryId = this.inventoryBinary.getIdFromUrl(binaryUrl);
            if (!binaryId && !options.allowExternal) {
                return null;
            }
            // @TODO: note that it doesn't solve issue with external binary here, such url won't have binaryId, so we won't know the name or contentType to use in File constructor, let's add a @FIXME comment for now?
            const { name, contentType } = (yield this.inventory.detail(binaryId)).data;
            const res = !!binaryId
                ? yield this.getInternalBinaryResponse(binaryId)
                : yield this.getExternalBinaryResponse(binaryUrl);
            const arrayBuffer = yield res.arrayBuffer();
            return new File([arrayBuffer], name, { type: contentType });
        });
    }
    /**
     * Gets the last configuration update operation for given device.
     * Looks for c8y_Configuration and c8y_SendConfiguration operations.
     * @param deviceId The ID of the device to find an operation for.
     */
    getLastConfigUpdateOperation(deviceId) {
        return __awaiter(this, void 0, void 0, function* () {
            const filters = {
                deviceId,
                dateFrom: new Date(0).toISOString(),
                dateTo: new Date(Date.now()).toISOString(),
                revert: true,
                pageSize: 1
            };
            return this.getLatestMatchingOperation([
                Object.assign(Object.assign({}, filters), { fragmentType: 'c8y_Configuration' }),
                Object.assign(Object.assign({}, filters), { fragmentType: 'c8y_SendConfiguration' })
            ]);
        });
    }
    /**
     * Prepares a configuration download operation for given device and its current configuration.
     * Supports c8y_SendConfiguration operation.
     * @param device The device for which operation should be prepared.
     */
    createTextBasedConfigurationReloadOperation(device) {
        return {
            deviceId: device.id,
            description: gettext('Requested current configuration'),
            c8y_SendConfiguration: {}
        };
    }
    /**
     * Prepares a configuration update operation for the given device.
     * Supports c8y_Configuration operation.
     * @param device The device for which operation should be prepared.
     * @param config The configuration which will update the existing one.
     */
    createTextBasedConfigurationUpdateOperation(device, config) {
        return {
            deviceId: device.id,
            description: gettext('Configuration update'),
            c8y_Configuration: {
                config
            }
        };
    }
    getBinary(binaryId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.inventoryBinary.download(binaryId);
            }
            catch (ex) {
                const msg = gettext('Could not get the binary.');
                this.alert.danger(msg);
            }
        });
    }
    /**
     * Gets all available snapshots from the repository for the given device.
     * @param device The device for which the snapshots should be prepared.
     * @param configurationType Selected configuration type.
     */
    getSnapshotsFromRepository(device, configurationType) {
        return __awaiter(this, void 0, void 0, function* () {
            const searchQuery = this.getConfigurationTypeQuery(device, configurationType);
            const res = yield this.listRepositoryEntries(RepositoryType.CONFIGURATION, {
                query: searchQuery,
                params: { pageSize: 100 }
            });
            return res.data;
        });
    }
    /**
     * Checks if a device already have a given software installed
     * @param deviceId Id of the device to be checked
     * @param software The software to be checked
     */
    isSoftwareInstalledOnDevice(deviceId, software) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.advancedSoftwareService.isASMAvailable())) {
                return false;
            }
            const queryFilter = { deviceId };
            if (software === null || software === void 0 ? void 0 : software.name) {
                set(queryFilter, 'name', software.name);
            }
            if (software === null || software === void 0 ? void 0 : software.version) {
                set(queryFilter, 'version', software.version);
            }
            return this.advancedSoftwareService.list(queryFilter).then(result => { var _a; return !!((_a = result.data) === null || _a === void 0 ? void 0 : _a.length); });
        });
    }
    /**
     * Returns a binary object.
     * @param binaryId binary ID
     * @param options The object with additional options:
     * - **noAlerts** - `boolean` - do not display an alert message; defaults to `false`
     */
    getInternalBinaryResponse(binaryId, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            let res;
            try {
                res = yield this.inventoryBinary.download(binaryId);
            }
            catch (ex) {
                if (!options.noAlerts) {
                    const msg = gettext('Could not get the binary.');
                    this.alert.danger(msg);
                }
            }
            return res;
        });
    }
    /**
     * Returns a binary object.
     * @param binaryUrl The URL to find binary
     * @param options The object with additional options:
     * - **noAlerts** - `boolean` - do not display an alert message; defaults to `false`
     */
    getExternalBinaryResponse(binaryUrl, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            let res;
            try {
                const fetchRes = yield fetch(binaryUrl);
                if (fetchRes.status >= 400) {
                    throw res;
                }
                res = fetchRes;
            }
            catch (_a) {
                if (!options.noAlerts) {
                    const msg = gettext('Could not get the external binary');
                    this.alert.danger(msg);
                }
            }
            return res;
        });
    }
    createEntry(mo) {
        return __awaiter(this, void 0, void 0, function* () {
            const binaryId = yield this.inventoryBinary.getIdFromUrl(mo.url);
            const newMo = yield this.inventory.create(mo);
            if (binaryId) {
                yield this.inventory.childAdditionsAdd(binaryId, newMo.data);
            }
            return newMo;
        });
    }
    updateEntry(mo, url) {
        return __awaiter(this, void 0, void 0, function* () {
            const existingBinaryId = yield this.inventoryBinary.getIdFromUrl(url);
            const newBinaryId = yield this.inventoryBinary.getIdFromUrl(mo.url);
            if (existingBinaryId && existingBinaryId !== newBinaryId) {
                const id = this.inventoryBinary.getIdFromUrl(url);
                yield this.inventoryBinary.delete(id);
            }
            if (newBinaryId) {
                yield this.inventory.childAdditionsAdd(newBinaryId, mo);
            }
            return this.inventory.update(mo);
        });
    }
    getBaseVersionResultListForLegacyEntry(entry) {
        return Promise.resolve({
            res: {},
            data: [
                Object.assign(Object.assign({}, entry), { [entry.type]: {
                        version: entry.version,
                        url: entry.url
                    } })
            ]
        });
    }
    getDeviceSoftwareChangesFromSoftwareListOperation(operation, device) {
        return __awaiter(this, void 0, void 0, function* () {
            const changes = [];
            const deviceSoftwareList = yield this.getCurrentSoftware(device, 'c8y_SoftwareList', []);
            forEach(operation.c8y_SoftwareList, operationSoftware => {
                const deviceSoftware = find(deviceSoftwareList, { name: operationSoftware.name });
                if ((operationSoftware && operationSoftware.version) !==
                    (deviceSoftware && deviceSoftware.version)) {
                    changes.push(Object.assign(Object.assign({}, operationSoftware), { action: 'install' }));
                }
            });
            forEach(deviceSoftwareList, deviceSoftware => {
                const operationSoftware = find(operation.c8y_SoftwareList, { name: deviceSoftware.name });
                if ((operationSoftware && operationSoftware.version) !==
                    (deviceSoftware && deviceSoftware.version)) {
                    const installChange = changes.find(change => deviceSoftware.name === change.name && change.action === 'install');
                    // check that this software is not an installation software change, otherwise it's an update and not a removal
                    if (!installChange) {
                        changes.push(Object.assign(Object.assign({}, deviceSoftware), { action: 'delete' }));
                    }
                }
            });
            return changes;
        });
    }
    getDeviceSoftwareChangesFromSoftwareOperation(operation, device) {
        return __awaiter(this, void 0, void 0, function* () {
            const changes = [];
            const deviceSoftware = yield this.getCurrentSoftware(device, 'c8y_Software', {});
            forEach(deviceSoftware, (deviceSoftwareVersion, deviceSoftwareName) => {
                if (operation.c8y_Software[deviceSoftwareName] !== deviceSoftwareVersion) {
                    changes.push({
                        name: deviceSoftwareName,
                        version: deviceSoftwareVersion,
                        action: 'delete'
                    });
                }
            });
            forEach(operation.c8y_Software, (operationSoftwareVersion, operationSoftwareName) => {
                const deviceSoftwareVersion = deviceSoftware && deviceSoftware[operationSoftwareName];
                if (deviceSoftwareVersion !== operationSoftwareVersion) {
                    changes.push({
                        name: operationSoftwareName,
                        version: operationSoftwareVersion,
                        action: 'install'
                    });
                }
            });
            return changes;
        });
    }
    getCurrentSoftware(device, swFragment, defaultValue) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const isASMAvailable = yield this.advancedSoftwareService.isASMAvailable();
            if (isASMAvailable) {
                let softwareResultList = yield this.advancedSoftwareService.list({ deviceId: device.id, pageSize: 100 });
                let list = ((softwareResultList === null || softwareResultList === void 0 ? void 0 : softwareResultList.data) || []).map(sw => pick(omitBy(sw, isNil), ['name', 'version', 'url', 'softwareType']));
                while ((_a = softwareResultList.paging) === null || _a === void 0 ? void 0 : _a.nextPage) {
                    softwareResultList = yield softwareResultList.paging.next();
                    list = [
                        ...list,
                        ...((softwareResultList === null || softwareResultList === void 0 ? void 0 : softwareResultList.data) || []).map(sw => pick(omitBy(sw, isNil), ['name', 'version', 'url', 'softwareType']))
                    ];
                }
                if (!(list === null || list === void 0 ? void 0 : list.length)) {
                    return defaultValue;
                }
                return Array.isArray(defaultValue) ? list : this.softwareListToLegacy(list);
            }
            else {
                return device[swFragment] || defaultValue;
            }
        });
    }
    softwareListToLegacy(list) {
        return (list || []).reduce((prev, curr) => (Object.assign(Object.assign({}, prev), { [curr.name]: curr.version })), {});
    }
}
RepositoryService.decorators = [
    { type: Injectable }
];
RepositoryService.ctorParameters = () => [
    { type: InventoryService },
    { type: InventoryBinaryService },
    { type: OperationService },
    { type: AlertService },
    { type: EventService },
    { type: OperationRealtimeService },
    { type: EventBinaryService },
    { type: AdvancedSoftwareService }
];

var LinkRenderType;
(function (LinkRenderType) {
    LinkRenderType[LinkRenderType["DOWNLOAD"] = 0] = "DOWNLOAD";
    LinkRenderType[LinkRenderType["LINK"] = 1] = "LINK";
    LinkRenderType[LinkRenderType["TEXTONLY"] = 2] = "TEXTONLY";
})(LinkRenderType || (LinkRenderType = {}));

class FileDownloadComponent {
    constructor(repositoryService, inventoryBinaryService, alertService) {
        this.repositoryService = repositoryService;
        this.inventoryBinaryService = inventoryBinaryService;
        this.alertService = alertService;
        this.linkRenderType = LinkRenderType;
        this.isDownloading = false;
    }
    getBinaryName$(binaryUrl) {
        return this.repositoryService.getBinaryName$(binaryUrl);
    }
    determineBehavior() {
        let result;
        if (this.inventoryBinaryService.getIdFromUrl(this.url)) {
            result = LinkRenderType.DOWNLOAD;
        }
        else if (this.url.match(/\/\//g)) {
            result = LinkRenderType.LINK;
        }
        else {
            result = LinkRenderType.TEXTONLY;
        }
        return result;
    }
    downloadFile() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.isDownloading = true;
                const binary = yield this.repositoryService.getBinaryFile(this.url, {
                    allowExternal: false
                });
                this.isDownloading = false;
                saveAs(binary);
            }
            catch (ex) {
                this.isDownloading = false;
                if (ex) {
                    this.alertService.addServerFailure(ex);
                }
            }
        });
    }
}
FileDownloadComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-file-download',
                template: "<a\n  *ngIf=\"determineBehavior() === linkRenderType.LINK\"\n  href=\"{{ url }}\"\n  class=\"pointer\"\n  target=\"_blank\"\n  rel=\"noopener noreferrer\"\n>\n  {{ getBinaryName$(url) | async }}\n</a>\n\n<span *ngIf=\"determineBehavior() === linkRenderType.TEXTONLY\">{{\n  getBinaryName$(url) | async\n}}</span>\n\n<span *ngIf=\"determineBehavior() === linkRenderType.DOWNLOAD\">\n  <a *ngIf=\"!isDownloading\" class=\"pointer\" (click)=\"downloadFile()\">\n    {{ getBinaryName$(url) | async }}\n  </a>\n\n  <span *ngIf=\"isDownloading\">\n    <i c8yIcon=\"spinner\" class=\"icon-spin\"></i> {{ 'Downloading\u2026' | translate }}\n  </span>\n</span>\n"
            },] }
];
FileDownloadComponent.ctorParameters = () => [
    { type: RepositoryService },
    { type: InventoryBinaryService },
    { type: AlertService }
];
FileDownloadComponent.propDecorators = {
    url: [{ type: Input }]
};
__decorate([
    memoize()
], FileDownloadComponent.prototype, "getBinaryName$", null);
__decorate([
    memoize()
], FileDownloadComponent.prototype, "determineBehavior", null);

// MODAL STRUCTURE
// - selectModalObject (repository entry (repositoryCategory) -> type c8y_Firmware/c8y_Software)
//   -- ISelectModalOption (repository binary entry (repositoryBinary) => type c8y_FirmwareBinary/c8y_SoftwareBinary)
//   -- ISelectModalOption...
// - selectModalObject...
/**
 * RepositorySelectModalComponent displays repository entries options and allows to select them.
 *
 * @example
 * ```
 * import { take } from 'rxjs/operators';
 * import { RepositorySelectModalComponent, ModalSelectionMode, RepositoryType } from '@c8y/ngx-components/repository/shared';
 *
 * const initialState = {
 *   repositoryType: RepositoryType.FIRMWARE,
 *   title: gettext('Install firmware'),
 *   subTitle: gettext('Available firmwares matching the device type'),
 *   icon: 'c8y-firmware',
 *   mode: ModalSelectionMode.SINGLE,
 *   labels: { ok: gettext('Install') },
 *   disableSelected: false
 * };
 *
 * const modal = this.bsModal.show(RepositorySelectModalComponent, {
 *   ignoreBackdropClick: true,
 *   initialState
 * });
 *
 * modal.content.load.next();
 * modal.content.resultEmitter.pipe(take(1)).subscribe((firmware) => {
 *   ...
 * })
 * ```
 */
class RepositorySelectModalComponent {
    constructor(repositoryService, translateService) {
        this.repositoryService = repositoryService;
        this.translateService = translateService;
        /**
         * Optional
         * Allows to provide custom data.
         * @example
         * ```
         * import { from } from 'rxjs';
         *
         * const repositoryEntry = { name: 'ExampleEntry', type: 'c8y_Firmware' };
         * const versions = [{ c8y_Firmware: { version: '1.0.0', url: 'http://example.com' } }];
         *
         * const initialState = {repositoryEntriesWithVersions$: from({ ...repositoryEntry, versions })};
         * ```
         */
        this.repositoryEntriesWithVersions$ = undefined;
        /**
         * Optional
         * Allows to use custom badges templates.
         * @example
         * ```
         * import { gettext } from '@c8y/ngx-components';
         *
         * const badgeTemplates = { '=1': gettext('{{count}} version'), other: gettext('{{count}} versions') };
         * const initialState = { badgeTemplates };
         * ```
         */
        this.badgeTemplates = { '=1': gettext('{{count}} version'), other: gettext('{{count}} versions') };
        /**
         * Optional
         * Allows to provide custom modal title.
         */
        this.title = gettext('Select repository entry');
        /**
         * Loads the content of the modal.
         * Must be invoked by the modal's caller.
         */
        this.load = new Subject();
        /**
         * Triggers an update of the item list emitted.
         */
        this.updateInstallableList$ = new Subject();
        /**
         * Optional
         * Emits a filter criteria object currently entered in the filter input.
         * Use it to filter the items if you use custom repositoryEntriesWithVersions$.
         */
        this.searchTerm = new BehaviorSubject({});
        /**
         * Optional
         * Allows to provide device type query to restrict search criteria.
         * Only takes effect when repositoryEntriesWithVersions$ is not provided,
         * otherwise modal's caller have to provide already filtered data in the repositoryEntriesWithVersions$.
         */
        this.deviceTypeQuery = {};
        /**
         * Optional
         * Allows to provide query to restrict search criteria.
         * Only takes effect when repositoryEntriesWithVersions$ is not provided,
         * otherwise modal's caller have to provide already filtered data in the repositoryEntriesWithVersions$.
         */
        this.searchQuery = {};
        /**
         * Optional
         * Allows to provide custom labels for the buttons responsible for confirm/dismiss modal actions.
         */
        this.labels = { ok: gettext('Save') };
        /**
         * Optional
         * Allows to hide the name filter input field.
         * By default, the filter input field is displayed.
         */
        this.showFilter = true;
        /**
         * Optional
         * Allows to show a warning that the search criteria should be narrowed down.
         * By default, this warning is hidden.
         */
        this.areMoreEntries = false;
        /**
         * Emits whenever a new repository binary have been selected in the modal.
         */
        this.onChoiceUpdated = new EventEmitter();
        /**
         * Emits the list of selected options.
         */
        this.resultEmitter = new EventEmitter();
        /**
         * Optional
         * Allows to change selection mode.
         * Supported options:
         *   * single: only single option can be selected.
         *   * multiple: multiple options can be selected.
         */
        this.mode = ModalSelectionMode.SINGLE;
        /**
         * Allows to block selection of the other versions from the same repository entry.
         */
        this.disableSelected = true;
        this.filterCriteria = {};
        this.repositoryEntries$ = this.load.pipe(switchMap(() => this.repositoryEntriesWithVersions$), mergeMap(mos => this.aggregate(mos)), tap(items => {
            this.areMoreEntries = items.length >= this.PAGE_SIZE ? true : false;
        }), tap(items => (this.repositoryEntries = items)));
        this.modalEntries = merge(this.repositoryEntries$, this.updateInstallableList$.pipe(map((updateItemEvent) => {
            const itemToUpdate = (this.repositoryEntries || []).find(item => item.groupId === updateItemEvent.object.groupId);
            if (itemToUpdate) {
                const optionToUpdate = (itemToUpdate.options || []).find(option => option.obj.id === updateItemEvent.object.selectedId);
                if (optionToUpdate) {
                    optionToUpdate.template = updateItemEvent.template;
                    if (updateItemEvent.mapper) {
                        optionToUpdate.obj = updateItemEvent.mapper(optionToUpdate.obj);
                    }
                }
            }
            return this.repositoryEntries;
        })));
        this.PAGE_SIZE = 100;
        this.queriesUtil = new QueriesUtil();
    }
    ngOnInit() {
        if (!this.repositoryType) {
            throw new Error('Repository type must be defined');
        }
        if (!this.repositoryEntriesWithVersions$) {
            this.repositoryEntriesWithVersions$ = of(1).pipe(mergeMap(() => this.repositoryService.listRepositoryEntries(this.repositoryType, {
                query: this.queriesUtil.addAndFilter(this.deviceTypeQuery, has(this.searchQuery, 'name')
                    ? Object.assign(Object.assign({}, this.searchQuery), { name: `*${this.searchQuery.name}*` }) : this.searchQuery),
                params: { pageSize: this.PAGE_SIZE }
            })), map(({ data }) => data), map(mos => this.getAndAssignRepositoryBinaries(mos)));
        }
    }
    getAndAssignRepositoryBinaries(mos) {
        mos.forEach(mo => {
            mo.versions = this.repositoryService.listAllVersions(mo);
        });
        return mos;
    }
    search(filterCriteria) {
        this.filterCriteria = omitBy(Object.assign(Object.assign({}, this.filterCriteria), filterCriteria), isEmpty);
        if (!isEqual(this.filterCriteria, this.searchQuery)) {
            this.searchTerm.next(this.filterCriteria);
            this.searchQuery = this.filterCriteria;
            this.load.next();
        }
    }
    result(selectedItems) {
        this.resultEmitter.emit(selectedItems);
    }
    aggregate(mos) {
        return __awaiter(this, void 0, void 0, function* () {
            const repositoryType = this.repositoryType;
            const selectedItems = this.selected;
            return Promise.all(mos.map((repositoryEntry) => __awaiter(this, void 0, void 0, function* () {
                const options = this.getSelectModalOptions(yield this.repositoryService.fetchAllItemsFromList(repositoryEntry.versions), selectedItems, repositoryEntry, repositoryType);
                const selectModalObject = this.getSelectModalObject(repositoryEntry, options);
                return selectModalObject;
            })));
        });
    }
    getSelectModalOptions(versions, selectedItems, repositoryEntry, repositoryType) {
        const selectModalOptions = [];
        versions.forEach(repositoryBinary => {
            const isSelected = this.isBinaryRepositorySelected(selectedItems, repositoryEntry, repositoryBinary, repositoryType);
            const { version } = repositoryBinary[`${repositoryType}`];
            const bodyValue = version || `(${this.translateService.instant(gettext('not specified`version`'))})`;
            const bodyClass = version ? '' : 'text-muted';
            selectModalOptions.push({
                body: [
                    {
                        value: bodyValue,
                        class: bodyClass
                    }
                ],
                obj: Object.assign(Object.assign(Object.assign({ id: repositoryBinary.id, name: repositoryEntry.name, version }, (get(repositoryBinary, 'c8y_Patch.dependency') && {
                    dependency: get(repositoryBinary, 'c8y_Patch.dependency')
                })), (get(repositoryBinary, 'c8y_Patch') && { isPatch: true })), { url: repositoryBinary[`${repositoryType}`].url, softwareType: repositoryEntry.softwareType }),
                selected: isSelected
            });
        });
        return selectModalOptions;
    }
    isBinaryRepositorySelected(selectedItems, repositoryEntry, repositoryBinary, repositoryType) {
        const isSelected = selectedItems
            ? selectedItems.filter(repositoryFragment => repositoryFragment.name === repositoryEntry.name &&
                repositoryFragment.version === repositoryBinary[`${repositoryType}`].version).length > 0
            : false;
        return isSelected;
    }
    getSelectModalObject(repositoryEntry, options) {
        const label = options.length === 1
            ? this.translateService.instant(this.badgeTemplates['=1'], { count: options.length })
            : this.translateService.instant(this.badgeTemplates.other, { count: options.length });
        const selectModalObject = {
            groupId: repositoryEntry.id,
            body: [
                { value: repositoryEntry.name, class: 'text-truncate' },
                { value: repositoryEntry.description, class: 'text-truncate text-muted' }
            ],
            additionalInformation: { value: label, class: 'label label-info' },
            options
        };
        return selectModalObject;
    }
}
RepositorySelectModalComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-repository-select-modal',
                template: "<c8y-select-modal\n  [icon]=\"icon\"\n  [title]=\"title\"\n  [subTitle]=\"subTitle\"\n  [items]=\"modalEntries | async\"\n  [mode]=\"mode\"\n  [disableSelected]=\"disableSelected\"\n  [labels]=\"labels\"\n  [showFilter]=\"showFilter\"\n  [additionalFilterTemplate]=\"additionalFilterTemplate\"\n  [areMoreEntries]=\"areMoreEntries\"\n  [noItemsMessage]=\"noItemsMessage\"\n  (search)=\"search({ name: $event })\"\n  (onChoiceUpdated)=\"onChoiceUpdated.emit($event)\"\n  (result)=\"result($event)\"\n>\n</c8y-select-modal>\n"
            },] }
];
RepositorySelectModalComponent.ctorParameters = () => [
    { type: RepositoryService },
    { type: TranslateService }
];

class SoftwareTypeComponent {
    constructor(repositoryService, changeDetectorRef, translateService) {
        this.repositoryService = repositoryService;
        this.changeDetectorRef = changeDetectorRef;
        this.translateService = translateService;
        this.required = true;
        this.placeholder = this.translateService.instant(gettext('e.g. {{ example }}'), {
            example: 'yum'
        });
        this.emitResultsOnly = false;
        this.showBtnInNotFoundMessage = true;
        this.allowFreeEntries = true;
        this.showClearSelectionOption = false;
        this.clearSelectionOptionLabel = gettext('All software types');
        this.onSelectSoftware = new EventEmitter();
        this.filterPipe = pipe(tap());
        this.search$ = new BehaviorSubject(null);
        this.queriesUtil = new QueriesUtil();
        this.softwareTypes = new Set();
        this.softwaresResult$ = this.search$.pipe(debounceTime(300), tap(() => this.softwareTypes.clear()), switchMap((searchString) => {
            if (!this.emitResultsOnly || !searchString) {
                this.onSelectSoftware.emit(this.softwareTypeMO);
            }
            return this.getSoftwareByTypeResult(searchString);
        }), shareReplay(1));
        this.filterPipe = pipe(map(this.removeDuplicatesBySoftwareType.bind(this)));
    }
    ngOnInit() {
        this.notFoundTemplateToUse = this.showBtnInNotFoundMessage
            ? this.notFoundTypeAddNewTemplate
            : this.notFoundTypeTemplate;
    }
    getSoftwareByTypeResult(searchString) {
        let query = this.queriesUtil.prependOrderbys({}, [{ softwareType: 1 }]);
        const filter = !!searchString
            ? {
                softwareType: {
                    __eq: `*${searchString}*`
                }
            }
            : {
                __has: 'softwareType'
            };
        query = this.queriesUtil.addAndFilter(query, filter);
        return this.repositoryService.listRepositoryEntries(RepositoryType.SOFTWARE, {
            query,
            params: {
                pageSize: 200
            }
        });
    }
    selectSoftware(software) {
        this.softwareTypeMO = software;
        this.onSelectSoftware.emit(software);
        this.deviceSoftwareTypeModel.searchControlModel.control.markAsDirty();
        this.deviceSoftwareTypeModel.onChange(software);
    }
    clearSoftware() {
        this.softwareTypeMO = undefined;
        this.search$.next('');
        this.onSelectSoftware.emit();
    }
    resetInput() {
        this.deviceSoftwareTypeModel.reset();
    }
    writeValue(value) {
        this.deviceSoftwareTypeModel.writeValue(value);
    }
    registerOnChange(fn) {
        this.deviceSoftwareTypeModel.registerOnChange(fn);
    }
    registerOnTouched(fn) {
        this.deviceSoftwareTypeModel.registerOnTouched(fn);
    }
    setDisabledState(isDisabled) {
        this.deviceSoftwareTypeModel.setDisabledState(isDisabled);
    }
    validate(control) {
        return this.deviceSoftwareTypeModel.validate(control);
    }
    removeDuplicatesBySoftwareType(list) {
        const uniqueBySoftwareType = uniqBy(list, 'softwareType').filter((sw) => !this.softwareTypes.has(sw.softwareType));
        uniqueBySoftwareType.forEach((sw) => this.softwareTypes.add(sw.softwareType));
        return uniqueBySoftwareType;
    }
}
SoftwareTypeComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-software-type',
                template: "<c8y-typeahead\n  [(ngModel)]=\"softwareTypeMO\"\n  [required]=\"required\"\n  [disabled]=\"disabled\"\n  name=\"softwareType\"\n  [placeholder]=\"placeholder\"\n  [allowFreeEntries]=\"allowFreeEntries\"\n  #deviceSoftwareTypeModel\n  (onSearch)=\"search$.next($event)\"\n  displayProperty=\"softwareType\"\n  [ngStyle]=\"style\"\n>\n  <c8y-li\n    *ngIf=\"showClearSelectionOption\"\n    class=\"p-l-8 p-r-8 c8y-list__item--link\"\n    (click)=\"clearSoftware()\"\n    [active]=\"!softwareTypeMO?.softwareType\"\n  >\n    <span>{{ clearSelectionOptionLabel | translate }}</span>\n  </c8y-li>\n  <c8y-li\n    *c8yFor=\"\n      let software of softwaresResult$;\n      pipe: filterPipe;\n      loadMore: 'auto';\n      notFound: notFoundTemplateToUse\n    \"\n    class=\"p-l-8 p-r-8 c8y-list__item--link\"\n    (click)=\"selectSoftware(software)\"\n    [active]=\"softwareTypeMO?.softwareType === software.softwareType\"\n  >\n    <c8y-highlight\n      [text]=\"software.softwareType || '--'\"\n      [pattern]=\"search$ | async\"\n    ></c8y-highlight>\n  </c8y-li>\n  <ng-template #notFoundTypeAddNewTemplate>\n    <c8y-li class=\"bg-gray-lighter p-8\" *ngIf=\"(search$ | async)?.length > 0\">\n      <span translate>No match found.</span>\n      <button\n        title=\"{{ 'Add new`software type`' | translate }}\"\n        type=\"button\"\n        class=\"btn btn-primary btn-xs m-l-8\"\n        translate\n      >\n        Add new`software type`\n      </button>\n    </c8y-li>\n  </ng-template>\n  <ng-template #notFoundTypeTemplate>\n    <c8y-li\n      class=\"bg-gray-lighter p-8\"\n      *ngIf=\"(search$ | async)?.length > 0 && (softwaresResult$ | async)?.data?.length === 0\"\n    >\n      <span translate>No match found. Refine your search terms or check your spelling.</span>\n    </c8y-li>\n  </ng-template>\n</c8y-typeahead>\n",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        multi: true,
                        useExisting: forwardRef(() => SoftwareTypeComponent)
                    },
                    {
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef(() => SoftwareTypeComponent),
                        multi: true
                    }
                ]
            },] }
];
SoftwareTypeComponent.ctorParameters = () => [
    { type: RepositoryService },
    { type: ChangeDetectorRef },
    { type: TranslateService }
];
SoftwareTypeComponent.propDecorators = {
    softwareTypeMO: [{ type: Input }],
    disabled: [{ type: Input }],
    style: [{ type: Input }],
    required: [{ type: Input }],
    placeholder: [{ type: Input }],
    emitResultsOnly: [{ type: Input }],
    showBtnInNotFoundMessage: [{ type: Input }],
    allowFreeEntries: [{ type: Input }],
    showClearSelectionOption: [{ type: Input }],
    clearSelectionOptionLabel: [{ type: Input }],
    deviceSoftwareTypeModel: [{ type: ViewChild, args: ['deviceSoftwareTypeModel', { static: true },] }],
    notFoundTypeAddNewTemplate: [{ type: ViewChild, args: ['notFoundTypeAddNewTemplate', { static: true },] }],
    notFoundTypeTemplate: [{ type: ViewChild, args: ['notFoundTypeTemplate', { static: true },] }],
    onSelectSoftware: [{ type: Output }]
};

class SharedRepositoryModule {
}
SharedRepositoryModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, CoreModule, FormsModule, PopoverModule],
                declarations: [RepositorySelectModalComponent, FileDownloadComponent, SoftwareTypeComponent],
                entryComponents: [RepositorySelectModalComponent],
                providers: [AdvancedSoftwareService, RepositoryService, OperationRealtimeService],
                exports: [RepositorySelectModalComponent, FileDownloadComponent, SoftwareTypeComponent]
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { AdvancedSoftwareService, DeviceConfigurationOperation, FileDownloadComponent, REPOSITORY_BINARY_TYPES, RepositorySelectModalComponent, RepositoryService, RepositoryType, SharedRepositoryModule, SoftwareTypeComponent };
//# sourceMappingURL=c8y-ngx-components-repository-shared.js.map
