import { __awaiter, __rest } from 'tslib';
import * as i3 from '@c8y/ngx-components';
import { NavigatorNode, gettext, DeviceStatusComponent, AssetTypesService, ModalService, AlertService, BreadcrumbService, AppStateService, OptionsService, CoreModule, CommonModule, SearchModule, ModalModule, DeviceStatusModule, HOOK_NAVIGATOR_NODES } from '@c8y/ngx-components';
import { get, debounce } from 'lodash-es';
import { BehaviorSubject, Subject, empty } from 'rxjs';
import * as i0 from '@angular/core';
import { InjectionToken, Injectable, Optional, Inject, EventEmitter, Component, forwardRef, ChangeDetectorRef, Input, Output, ViewChild, NgModule } from '@angular/core';
import { QueriesUtil, InventoryService, UserService } from '@c8y/client';
import * as i2 from '@c8y/ngx-components/api';
import { ApiService } from '@c8y/ngx-components/api';
import { filter, mergeMap, takeUntil } from 'rxjs/operators';
import * as i1 from '@c8y/client';
import * as i4 from '@c8y/client';
import { CollapseModule } from 'ngx-bootstrap/collapse';
import { BsDropdownModule } from 'ngx-bootstrap/dropdown';
import { TranslateService } from '@ngx-translate/core';
import { NG_VALUE_ACCESSOR, NG_VALIDATORS, FormsModule } from '@angular/forms';
import { isArray, isNumber, isString, isObject } from 'lodash';

var Action;
(function (Action) {
    Action[Action["FETCH"] = 0] = "FETCH";
    Action[Action["NEXT"] = 1] = "NEXT";
    Action[Action["REFRESH"] = 2] = "REFRESH";
    Action[Action["LOADING_DONE"] = 3] = "LOADING_DONE";
})(Action || (Action = {}));

var GroupFragment;
(function (GroupFragment) {
    GroupFragment["groupType"] = "c8y_DeviceGroup";
    GroupFragment["subGroupType"] = "c8y_DeviceSubgroup";
    GroupFragment["groupFragmentType"] = "c8y_IsDeviceGroup";
    GroupFragment["dataBrokerSourceFragment"] = "c8y_BrokerSource";
    GroupFragment["dynamicGroupType"] = "c8y_DynamicGroup";
    GroupFragment["dynamicGroupFragment"] = "c8y_IsDynamicGroup";
    GroupFragment["dynamicGroupColumnConfig"] = "c8y_UIDeviceFilterConfig";
    GroupFragment["dynamicGroupQueryString"] = "c8y_DeviceQueryString";
})(GroupFragment || (GroupFragment = {}));

class LoadMoreNode extends NavigatorNode {
    constructor() {
        super();
        this.label = gettext('Load more');
        this.icon = 'plus';
        this.droppable = true;
        this.priority = -Infinity;
    }
    toString() {
        return LoadMoreNode.NAME;
    }
    isGroup() {
        return false;
    }
}
LoadMoreNode.NAME = 'LoadMoreNode';

class AssetNode extends NavigatorNode {
    constructor(service, config = {}) {
        var _a, _b, _c, _d, _e;
        super(config);
        this.service = service;
        this.config = config;
        this.hideDevices = false;
        this.filterQuery$ = new BehaviorSubject('');
        this.showChildDevices = false;
        /**
         * Asset node children (subentries).
         */
        this.children = [];
        this.root = this.root || false;
        this.hideDevices = (_a = config.hideDevices) !== null && _a !== void 0 ? _a : this.hideDevices;
        this.mo = this.mo || {};
        this.path = this.getPath();
        this.draggable = !((_c = (_b = this.service) === null || _b === void 0 ? void 0 : _b.moduleConfig) === null || _c === void 0 ? void 0 : _c.disableDragAndDrop) && !this.root;
        this.droppable =
            !((_e = (_d = this.service) === null || _d === void 0 ? void 0 : _d.moduleConfig) === null || _e === void 0 ? void 0 : _e.disableDragAndDrop) && !this.isDeviceOrProbablyChildDevice;
        this.routerLinkExact = this.root;
        this.updateIcon(false);
        this.onUpdateSubscription = this.service
            .onUpdate(this)
            .subscribe(({ data, method }) => this.refresh(data, method));
        this.setLabel();
        this.iconComponent = this.isDeviceOrProbablyChildDevice ? DeviceStatusComponent : undefined;
    }
    get hasChildren() {
        return this.root || this.service.isGroup(this.mo);
    }
    get isDevice() {
        return !!this.mo.c8y_IsDevice;
    }
    get isDeviceOrProbablyChildDevice() {
        return this.isDevice || this.isNeitherDeviceOrGroup;
    }
    get isNeitherDeviceOrGroup() {
        return (!this.service.isGroup(this.mo) &&
            !this.service.isDynamicGroup(this.mo) &&
            !this.isDevice &&
            !this.root);
    }
    getPath() {
        if (this.config.path) {
            return this.config.path;
        }
        return this.root
            ? 'group'
            : this.isDeviceOrProbablyChildDevice
                ? `device/${this.mo.id}`
                : `group/${this.mo.id}`;
    }
    openOnStart(url) {
        const urlRegex = /^\/group\//;
        if (this.root) {
            if (this.service.moduleConfig.openOnStart || urlRegex.test(url)) {
                return true;
            }
        }
        const matches = url.match(/\/(group)\/(\d+)/);
        let isMatch = false;
        if (matches) {
            const id = matches[2];
            isMatch = []
                .concat(get(this.mo, 'childAssets.references', []))
                .some(({ managedObject }) => managedObject.id === id);
            return isMatch;
        }
        return false;
    }
    refresh(mo = {}, method = 'GET') {
        if (mo.id === this.mo.id) {
            this.mo = mo;
            this.setLabel();
        }
        else if (method === 'DELETE') {
            this.parents.forEach((node) => node.refresh());
            return;
        }
        if (this.events) {
            this.events.next(Action.REFRESH);
        }
    }
    setLabel() {
        this.label = this.config.label || (this.root && gettext('Groups')) || this.mo.name || '--';
    }
    click(options = {}) {
        if (this.isDeviceOrProbablyChildDevice && !this.showChildDevices) {
            this.service.preferBreadcrumb(this.parents);
            return;
        }
        this.hookEvents();
        this.updateIcon(options.open);
        if (options.open) {
            this.events.next(Action.FETCH);
        }
    }
    sort() {
        this.children.sort((a, b) => {
            if (a.priority > b.priority) {
                return -1;
            }
            else if (a.priority < b.priority) {
                return 1;
            }
            else {
                return 0;
            }
        });
    }
    addManagedObject(mo) {
        const { childAdditions } = this.mo;
        if (!this.isChildAddition(childAdditions, mo)) {
            this.add(this.service.createChildNode(mo, { hideDevices: this.hideDevices }));
        }
    }
    isChildAddition(childAdditions, mo) {
        return (childAdditions && childAdditions.references.some(({ managedObject: { id } }) => id === mo.id));
    }
    destroy() {
        this.onUpdateSubscription.unsubscribe();
    }
    get canDrop() {
        const nodeToMove = this.service.draggedData;
        if (nodeToMove) {
            const shouldGetChildOfItsOwn = !!nodeToMove.find(child => child === this);
            const isAlreadyChild = this.children.some(child => child.mo && child.mo.id === nodeToMove.mo.id);
            const preventMove = this === nodeToMove || shouldGetChildOfItsOwn || isAlreadyChild;
            return this.droppable && !preventMove && this.service.canDropNode(this.root);
        }
        return this.droppable;
    }
    dragStart($event) {
        super.dragStart($event);
        this.service.draggedData = this;
        this.service.rootNode.droppable = !this.isDeviceOrProbablyChildDevice;
    }
    dragEnd($event) {
        super.dragEnd($event);
    }
    drop($event) {
        const _super = Object.create(null, {
            drop: { get: () => super.drop }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const nodeToMove = this.service.draggedData;
            // TODO remove when asset type node can be used on the root level.
            if (this.root && this.isAsset(nodeToMove)) {
                this.service.alert.info(gettext('Asset type node cannot become root node.'));
                this.draggedHover = false;
                this.service.draggedData = undefined;
                return;
            }
            _super.drop.call(this, $event);
            if (this.canDrop) {
                yield this.moveNode(nodeToMove);
            }
            else {
                this.draggedHover = false;
                this.service.draggedData = undefined;
            }
        });
    }
    hookEvents() {
        if (!this.events) {
            this.events = new Subject();
            this.events.subscribe(evt => {
                if (!this.loading) {
                    this.handleEvent(evt);
                }
            });
        }
    }
    toString() {
        return AssetNode.NAME;
    }
    /**
     * Checks if the current node has child devices.
     */
    hasChildDevices() {
        return this.mo && this.mo.c8y_IsDevice && this.mo.childDevices.references.length > 0;
    }
    fetch() {
        return this.root
            ? this.service.getRootNodes()
            : this.service.getGroupItems(this.mo.id, this.hideDevices
                ? {
                    query: `$filter=(has(${GroupFragment.groupFragmentType}))$orderby=name`
                }
                : {});
    }
    countChildren() {
        return this.children.length;
    }
    handleEvent(evt) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.countChildren() && evt === Action.FETCH) {
                this.loading = true;
                this.addNodes(yield this.fetch());
                this.loading = false;
            }
            else if (evt === Action.NEXT) {
                this.loadMoreNode.loading = true;
                this.addNodes(yield this.paging.next());
                this.loadMoreNode.loading = false;
            }
            else if (evt === Action.REFRESH) {
                this.loading = false;
                this.paging = undefined;
                this.loadMoreNode = undefined;
                this.empty();
                this.events.next(Action.FETCH);
            }
        });
    }
    addNodes(res) {
        if (res.paging) {
            const { currentPage, nextPage, pageSize } = (this.paging = res.paging);
            if (currentPage === 1) {
                this.empty();
            }
            const itemsCount = res.data.length;
            const moreItemsAvailable = !!nextPage && itemsCount === pageSize;
            this.toggleLoadMore(moreItemsAvailable);
        }
        (res.data || res).map(mo => {
            return this.addManagedObject(mo);
        });
        this.events.next(Action.LOADING_DONE);
    }
    toggleLoadMore(show) {
        if (!this.loadMoreNode && show) {
            this.loadMoreNode = new LoadMoreNode();
            this.add(this.loadMoreNode);
            this.loadMoreNode.click = debounce(() => this.events.next(Action.NEXT), 300, {
                leading: true,
                trailing: false
            });
        }
        if (this.loadMoreNode) {
            this.loadMoreNode.hidden = !show;
        }
    }
    moveNode(nodeToMove) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const isCopy = yield this.showDropConfirm(nodeToMove);
                yield this.verifyNodeAccess(nodeToMove);
                yield this.addMovedNode(nodeToMove);
                if (!isCopy) {
                    yield this.removeMovedNode(nodeToMove);
                }
                this.expand();
            }
            catch (ex) {
                if (ex) {
                    this.service.alert.addServerFailure(ex);
                }
            }
            finally {
                this.draggedHover = false;
                this.service.draggedData = undefined;
            }
        });
    }
    showDropConfirm(nodeToMove) {
        return __awaiter(this, void 0, void 0, function* () {
            this.confirm.title = gettext('Move');
            this.confirm.message = gettext('Do you want to move the group?');
            const buttons = [
                {
                    label: gettext('Cancel'),
                    action: () => Promise.reject()
                },
                {
                    label: gettext('Move'),
                    status: 'default',
                    action: () => Promise.resolve(false)
                }
            ];
            if (nodeToMove.isDeviceOrProbablyChildDevice) {
                this.confirm.title = gettext('Move or add');
                this.confirm.message = gettext('Do you want to move or add the device?');
                buttons.push({
                    label: gettext('Add'),
                    status: 'primary',
                    action: () => Promise.resolve(true)
                });
            }
            return this.confirm.show(buttons);
        });
    }
    verifyNodeAccess(nodeToMove) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.service.inventory.update({ id: nodeToMove.mo.id });
        });
    }
    addMovedNode(nodeToMove) {
        return __awaiter(this, void 0, void 0, function* () {
            let mo;
            if (this.root && !this.isAsset(nodeToMove)) {
                mo = (yield this.service.inventory.update({
                    id: nodeToMove.mo.id,
                    type: GroupFragment.groupType
                })).data;
                this.addManagedObject(mo);
                return;
            }
            mo = (yield this.service.inventory.childAssetsAdd(nodeToMove.mo, this.mo)).data;
            this.addManagedObject(mo);
        });
    }
    isAsset(nodeToMove) {
        var _a;
        // TODO use isAsset check when https://github.softwareag.com/IOTA/cumulocity-ui/pull/690 is merged.
        // Do not override asset type!
        return (_a = nodeToMove.mo) === null || _a === void 0 ? void 0 : _a.c8y_IsAsset;
    }
    removeMovedNode(nodeToMove) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const parent of nodeToMove.parents) {
                if (parent.mo && parent.mo.type === GroupFragment.dynamicGroupType) {
                    break; // smart groups don't need to be changed
                }
                if (parent.root && !this.isAsset(nodeToMove)) {
                    yield this.service.inventory.update({
                        id: nodeToMove.mo.id,
                        type: GroupFragment.subGroupType
                    });
                }
                if (!parent.root) {
                    yield this.service.inventory.childAssetsRemove(nodeToMove.mo, parent.mo);
                }
                parent.remove(nodeToMove);
            }
        });
    }
    updateIcon(open) {
        this.icon = this.service.icon(
        // if it's root we are going to pass a fake mo to get the same icon as groups
        this.root ? { c8y_IsDeviceGroup: {} } : this.mo, open);
    }
}
AssetNode.NAME = 'AssetNode';

class DynamicGroupNode extends AssetNode {
    constructor(service, config = {}) {
        super(service, config);
        this.service = service;
        this.draggable = false;
        this.droppable = false;
    }
    get hasChildren() {
        return true;
    }
    get query() {
        return this.mo.c8y_DeviceQueryString;
    }
    fetch() {
        return this.service.getDynamicGroupItems(this.query);
    }
}

const ASSET_NAVIGATOR_CONFIG = new InjectionToken('AssetNodeConfig');

const MO_TYPES = [
    'asset',
    'dynamicGroup',
    'brokerSource',
    'brokerSourceInactive',
    'group',
    'other'
];
class DeviceGroupService {
    constructor(assetTypesService) {
        this.assetTypesService = assetTypesService;
        this.icons = {
            brokerSourceInactive: {
                icon: 'c8y-group-remote-inactive',
                iconOpen: 'c8y-group-remote-inactive'
            },
            brokerSource: {
                icon: 'c8y-group-remote',
                iconOpen: 'c8y-group-remote-open'
            },
            group: {
                icon: 'c8y-group',
                iconOpen: 'c8y-group-open'
            },
            dynamicGroup: {
                icon: 'c8y-group-smart',
                iconOpen: 'c8y-group-smart-open'
            },
            other: {
                icon: 'exchange',
                iconClass: 'statusUnknown'
            }
        };
        this.dataBrokerSourceFragmentInactive = `_${GroupFragment.dataBrokerSourceFragment}`;
    }
    /**
     * Finds an icon based on the contents of a managed object.
     * It takes into account factors such as type, and specific fragemnts.
     * @param mo Managed object to be checked.
     * @param open Determines whether the method should return an alternative icon showing the open state.
     * @returns Returns an icon.
     */
    icon(mo, open = false) {
        let icon;
        const genericMoType = this.determineMoType(mo);
        if (genericMoType === 'asset') {
            icon = this.getAssetCustomIcon(mo.type, open);
            return icon;
        }
        const typeIcons = this.getDefaultIcon(genericMoType);
        return (open && typeIcons.iconOpen) || typeIcons.icon;
    }
    /**
     * Checks whether a given managed object is a group.
     * @param mo Managed object to be checked.
     * @returns Returns true if the managed object is a group.
     */
    isGroup(mo) {
        return !!mo[GroupFragment.groupFragmentType] || mo.type === GroupFragment.groupType;
    }
    /**
     * Checks whether a given managed object is a dynamic group.
     * @param mo Managed object to be checked.
     * @returns Returns true if the managed object is a dynamic group.
     */
    isDynamicGroup(mo) {
        return !!mo[GroupFragment.dynamicGroupFragment] || mo.type === GroupFragment.dynamicGroupType;
    }
    /**
     * Checks whether a given managed object is a data broker.
     * @param mo Managed object to be checked.
     * @returns Returns true if the managed object is a data broker.
     */
    isDataBroker(mo) {
        return (!!mo[GroupFragment.dataBrokerSourceFragment] || !!mo[this.dataBrokerSourceFragmentInactive]);
    }
    /**
     * Checks whether a given managed object is a data broker active.
     * @param mo Managed object to be checked.
     * @returns Returns true if the managed object is a data broker active.
     */
    isDataBrokerActive(mo) {
        return (!!mo[GroupFragment.dataBrokerSourceFragment] && !mo[this.dataBrokerSourceFragmentInactive]);
    }
    /**
     * Checks whether a given managed object is an asset.
     * @param mo Managed object to be checked.
     * @returns Returns true if the managed object is an asset.
     */
    isAsset(mo) {
        return !!mo.c8y_IsAsset;
    }
    /**
     * Checks whether the object belongs to any type of group.
     * Types of groups: group, dynamic group, data broker, data broker active.
     * @param mo Managed object to be checked.
     * @returns Returns true if the managed object belongs to the group category.
     */
    isAnyGroup(mo) {
        return (this.isGroup(mo) ||
            this.isDynamicGroup(mo) ||
            this.isDataBroker(mo) ||
            this.isDataBrokerActive(mo));
    }
    /**
     * Checks whether a given managed object is a device.
     * @param mo Managed object to be checked.
     * @returns Returns true if the managed object is a device.
     */
    isDevice(mo) {
        return !!mo.c8y_IsDevice;
    }
    getAssetCustomIcon(moType, open = false) {
        return this.assetTypesService.getIcon(moType, open);
    }
    getDefaultIcon(moType) {
        return this.icons[moType];
    }
    determineMoType(mo) {
        if (this.isAsset(mo)) {
            return 'asset';
        }
        if (this.isDynamicGroup(mo)) {
            return 'dynamicGroup';
        }
        if (this.isDataBrokerActive(mo)) {
            return 'brokerSource';
        }
        if (this.isDataBroker(mo)) {
            return 'brokerSourceInactive';
        }
        if (this.isGroup(mo)) {
            return 'group';
        }
        return 'other';
    }
}
DeviceGroupService.ɵprov = i0.ɵɵdefineInjectable({ factory: function DeviceGroupService_Factory() { return new DeviceGroupService(i0.ɵɵinject(i3.AssetTypesService)); }, token: DeviceGroupService, providedIn: "root" });
DeviceGroupService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
DeviceGroupService.ctorParameters = () => [
    { type: AssetTypesService }
];

class AssetNodeService {
    constructor(inventory, apiService, modal, alert, breadcrumbService, user, appState, optionsService, moduleConfig, deviceGroupService) {
        this.inventory = inventory;
        this.apiService = apiService;
        this.modal = modal;
        this.alert = alert;
        this.breadcrumbService = breadcrumbService;
        this.user = user;
        this.appState = appState;
        this.optionsService = optionsService;
        this.moduleConfig = moduleConfig;
        this.deviceGroupService = deviceGroupService;
        this.firstUrl = true;
        this.PAGE_SIZE = 20;
        this.moduleConfig = Object.assign({ rootNodePriority: 2000 }, (moduleConfig || {}));
        this.queriesUtil = new QueriesUtil();
    }
    icon(mo, open) {
        return this.deviceGroupService.icon(mo, open);
    }
    isGroup(mo) {
        return this.deviceGroupService.isGroup(mo);
    }
    isDynamicGroup(mo) {
        return this.deviceGroupService.isDynamicGroup(mo);
    }
    isDataBroker(mo) {
        return this.deviceGroupService.isDataBroker(mo);
    }
    isDataBrokerActive(mo) {
        return this.deviceGroupService.isDataBrokerActive(mo);
    }
    isAsset(mo) {
        return this.deviceGroupService.isAsset(mo);
    }
    isAnyGroup(mo) {
        return this.deviceGroupService.isAnyGroup(mo);
    }
    isDevice(mo) {
        return this.deviceGroupService.isDevice(mo);
    }
    createRootNode(config = {}) {
        this.rootNode = this.createAssetNode(Object.assign(Object.assign({ root: true }, config), { priority: this.moduleConfig.rootNodePriority, featureId: 'groups' }));
        return this.rootNode;
    }
    createDynamicGroupNode(config) {
        return new DynamicGroupNode(this, config);
    }
    createAssetNode(config) {
        return new AssetNode(this, config);
    }
    createChildNode(managedObject, config) {
        const { type } = managedObject;
        config.mo = managedObject;
        if (type === GroupFragment.dynamicGroupType) {
            return this.createDynamicGroupNode(config);
        }
        return this.createAssetNode(config);
    }
    getRootNodes(customFilter) {
        const defaultFilter = {
            pageSize: this.PAGE_SIZE,
            withChildren: false,
            onlyRoots: !this.optionsService.disableOnlyRootsQuery,
            query: this.queriesUtil.buildQuery(this.navRootQueryFilter())
        };
        const groupFilter = Object.assign(Object.assign({}, defaultFilter), customFilter);
        // due to BE performance limitations we do not allow filtering and sorting for a user without inventory roles
        if (!this.user.hasRole(this.appState.currentUser.value, 'ROLE_INVENTORY_READ')) {
            delete groupFilter.query;
            Object.assign(groupFilter, {
                fragmentType: GroupFragment.groupFragmentType,
                onlyRoots: true
            });
        }
        return this.inventory.list(this.createFilter(groupFilter));
    }
    getAllInventories(customFilter) {
        const defaultFilter = {
            pageSize: this.PAGE_SIZE,
            withChildren: false
        };
        const groupFilter = Object.assign(Object.assign({}, defaultFilter), customFilter);
        return this.inventory.list(this.createFilter(groupFilter));
    }
    getGroupItems(moId, extraFilter = {}, withChildren = false, filterQuery = '') {
        const queryFilter = {
            withChildren,
            pageSize: this.PAGE_SIZE,
            query: this.groupQueryFilter(moId, filterQuery)
        };
        return this.inventory.childAssetsList(moId, Object.assign(Object.assign({}, queryFilter), extraFilter));
    }
    getUnassignedDevices(withChildren = false, filterQuery = '') {
        const queryFilter = {
            fragmentType: 'c8y_IsDevice',
            onlyRoots: true,
            withChildren,
            pageSize: this.PAGE_SIZE,
            q: this.getUnassignedDevicesQueryStr(filterQuery)
        };
        return this.inventory.list(this.createFilter(queryFilter));
    }
    getDynamicGroupItems(groupQuery, filterObj = {}) {
        const { query } = filterObj, queryParams = __rest(filterObj, ["query"]);
        const orderByQuery = query;
        const queryFilter = Object.assign({ q: this.buildCombinedQuery(groupQuery, orderByQuery) }, queryParams);
        return this.inventory.list(this.createFilter(queryFilter));
    }
    getDeviceChildren(moId, extraFilter = {}, filterQuery = '', withChildren = false) {
        const queryFilter = {
            withChildren,
            pageSize: this.PAGE_SIZE,
            query: this.groupQueryFilter(moId, filterQuery)
        };
        return this.inventory.childDevicesList(moId, Object.assign(Object.assign({}, queryFilter), extraFilter));
    }
    getUnassignedDevicesQueryStr(filterQuery) {
        const hasGroupId = filterQuery.includes('bygroupid');
        // Fetch all unassigned devices.
        const defaultQueryStr = '$orderby=name';
        // filterQuery is a custom query to fetch unassigned devices filtered by name.
        return hasGroupId || !filterQuery ? defaultQueryStr : filterQuery;
    }
    groupQueryFilter(moId, filterQuery) {
        if (!filterQuery) {
            return `$filter=(bygroupid(${moId}))$orderby=name`;
        }
        return filterQuery;
    }
    navRootQueryFilter() {
        const navRootFilter = this.rootQueryFilter();
        navRootFilter.__orderby = [{ name: 1 }];
        return navRootFilter;
    }
    rootQueryFilter() {
        const { moduleConfig } = this;
        const rootFilter = this.optionsService.disableOnlyRootsQuery
            ? {
                __filter: {
                    type: GroupFragment.groupType
                },
                __orderby: []
            }
            : {
                __filter: {
                    __has: GroupFragment.groupFragmentType
                },
                __orderby: []
            };
        if (moduleConfig.smartGroups) {
            const queryFilter = {
                __filter: {
                    __and: [
                        {
                            type: GroupFragment.dynamicGroupType
                        },
                        {
                            __has: GroupFragment.dynamicGroupFragment
                        },
                        { __not: { __has: `${GroupFragment.dynamicGroupFragment}.invisible` } }
                    ]
                }
            };
            this.queriesUtil.addOrFilter(rootFilter, queryFilter);
        }
        return rootFilter;
    }
    onUpdate({ mo, root }) {
        if (mo.id) {
            return this.apiService
                .hookResponse(({ url, method }) => ['PUT', 'DELETE', 'POST'].includes(method) &&
                RegExp(`((inventory/managedObjects)|(service/smartgroup/smartgroups))/${mo.id}`).test(url))
                .pipe(filter(() => !this.draggedData), mergeMap(this.apiService.resolveData), filter(response => !response.data.c8y_Dashboard));
        }
        else if (root) {
            return this.apiService
                .hookResponse(({ url, method }) => RegExp('((inventory/managedObjects)|(service/smartgroup/smartgroups))/?$').test(url) &&
                method === 'POST')
                .pipe(mergeMap(this.apiService.resolveData), filter(response => this.isNewManagedObjectRoot(response)));
        }
        else {
            return empty();
        }
    }
    isNewManagedObjectRoot(response = {}) {
        const { data } = response;
        let isRootAsset = false;
        if (typeof data === 'object') {
            isRootAsset = !!data[GroupFragment.groupFragmentType];
            if (!isRootAsset && this.moduleConfig.smartGroups) {
                isRootAsset = !!data[GroupFragment.dynamicGroupFragment];
            }
        }
        return isRootAsset;
    }
    /**
     * Check if it is possible to drop a node after dragging.
     * @param dropOnRoot Is the drop performed on the root node
     */
    canDropNode(dropOnRoot) {
        return (!dropOnRoot || this.user.hasRole(this.appState.currentUser.value, 'ROLE_INVENTORY_ADMIN'));
    }
    /**
     * There could be multiple breadcrumbs for devices,
     * so we set a preferred one on click on a device.
     * @param parents The parent nodes of the device to select the prefered one.
     */
    preferBreadcrumb(parents) {
        if (parents.length === 1) {
            this.breadcrumbService.selectPreferredByPath(parents[0].path);
        }
    }
    createFilter(extraParams = {}) {
        const params = {
            currentPage: 1,
            withTotalPages: true,
            pageSize: 10
        };
        return Object.assign(Object.assign({}, params), extraParams);
    }
    buildCombinedQuery(query, orderByQuery) {
        let combinedQuery;
        if (query && orderByQuery) {
            const filterQuery = this.queriesUtil.buildQuery({
                __useFilterQueryString: query
            });
            combinedQuery = `${filterQuery} ${orderByQuery}`;
        }
        else {
            combinedQuery = query || orderByQuery || '';
        }
        return combinedQuery;
    }
}
AssetNodeService.ɵprov = i0.ɵɵdefineInjectable({ factory: function AssetNodeService_Factory() { return new AssetNodeService(i0.ɵɵinject(i1.InventoryService), i0.ɵɵinject(i2.ApiService), i0.ɵɵinject(i3.ModalService), i0.ɵɵinject(i3.AlertService), i0.ɵɵinject(i3.BreadcrumbService), i0.ɵɵinject(i4.UserService), i0.ɵɵinject(i3.AppStateService), i0.ɵɵinject(i3.OptionsService), i0.ɵɵinject(ASSET_NAVIGATOR_CONFIG, 8), i0.ɵɵinject(DeviceGroupService)); }, token: AssetNodeService, providedIn: "root" });
AssetNodeService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
AssetNodeService.ctorParameters = () => [
    { type: InventoryService },
    { type: ApiService },
    { type: ModalService },
    { type: AlertService },
    { type: BreadcrumbService },
    { type: UserService },
    { type: AppStateService },
    { type: OptionsService },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [ASSET_NAVIGATOR_CONFIG,] }] },
    { type: DeviceGroupService }
];

class AssetNodeFactory {
    constructor(service, moduleConfig) {
        this.service = service;
        this.moduleConfig = moduleConfig;
    }
    get() {
        var _a;
        const rootNavigatorNode = (_a = get(this.moduleConfig, 'rootNavigatorNode')) !== null && _a !== void 0 ? _a : true;
        let { rootNode } = this.service;
        if (rootNavigatorNode === false) {
            return;
        }
        if (!rootNode) {
            rootNode = this.service.createRootNode(rootNavigatorNode === true ? {} : rootNavigatorNode);
        }
        return rootNode;
    }
}
AssetNodeFactory.decorators = [
    { type: Injectable }
];
AssetNodeFactory.ctorParameters = () => [
    { type: AssetNodeService },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [ASSET_NAVIGATOR_CONFIG,] }] }
];

class GroupNode extends AssetNode {
    /**
     * Creates a new node which shows only groups.
     *
     * @param service The service to use.
     * @param config  The default configuration of the node.
     * @param groupsOnly Set this true, if only groups should be shown.
     * @param selectable Set this true, if it is selectable.
     */
    constructor(service, config = {}) {
        super(service, config);
        this.service = service;
        /**
         * Set this true, if only groups should be shown.
         */
        this.groupsOnly = false;
        /**
         * Set this true, if it groups are also selectable.
         */
        this.groupsSelectable = false;
        /**
         * Devices with children can be selected to show their child devices.
         */
        this.showChildDevices = false;
        /**
         * Group node children (subentries).
         */
        this.children = [];
        this.groupsOnly = config.groupsOnly || false;
        this.groupsSelectable = config.groupsSelectable || false;
        this.showChildDevices = config.showChildDevices || false;
    }
    /**
     * Adds the MO as a child node.
     * @param mo ManagedObject
     */
    addManagedObject(mo) {
        const { childAdditions } = this.mo;
        if (!this.isChildAddition(childAdditions, mo)) {
            this.add(this.service.createChildNode({
                mo,
                groupsOnly: this.groupsOnly,
                groupsSelectable: this.groupsSelectable,
                showChildDevices: this.showChildDevices
            }));
        }
    }
    /**
     * Counts the number of children for the current node (with the exception of the UnassignedDevicesNode).
     */
    countChildren() {
        return this.children.filter(value => value.toString() !== 'UnassignedDevicesNode').length;
    }
    /**
     * Removes all child nodes except the UnassignedDevicesNode.
     */
    empty() {
        this.children = this.children.filter(value => value.toString() === 'UnassignedDevicesNode');
    }
    fetch() {
        const isRoot = this.root;
        const isDevice = this.mo.c8y_IsDevice;
        return isRoot
            ? this.service.getRootNodes()
            : isDevice
                ? this.service.getDeviceChildren(this.mo.id, {}, this.filterQuery$.value, this.showChildDevices)
                : this.service.getGroupItems(this.mo.id, this.groupsOnly
                    ? {
                        query: `$filter=(has(${GroupFragment.groupFragmentType}))`
                    }
                    : {}, this.showChildDevices, this.filterQuery$.value);
    }
    toString() {
        return GroupNode.NAME;
    }
    isGroup() {
        return this.mo && this.service.isGroup(this.mo);
    }
}
GroupNode.NAME = 'GroupNode';

class GroupNodeService extends AssetNodeService {
    constructor() {
        super(...arguments);
        this.PAGE_SIZE = 5;
    }
    createGroupNode(config) {
        return new GroupNode(this, config);
    }
    createChildNode(config) {
        return this.createGroupNode(config);
    }
}
GroupNodeService.decorators = [
    { type: Injectable }
];

class AssetSelectorService extends AssetNodeService {
    /**
     * Simplifies the object model based on the selected mode.
     * @param obj The selected asset.
     * @param mode The mode which will decide what type of model will be returned.
     */
    normalizeValue(obj, modelMode) {
        return this.simplifyModel(this.normalizeModelValue(obj), modelMode);
    }
    simplifyModel(model, mode) {
        const mapModel = modelObj => {
            const { id, name, c8y_DeviceQueryString } = modelObj;
            return Object.assign({ id, name }, (c8y_DeviceQueryString ? { c8y_DeviceQueryString } : {}));
        };
        if (mode === 'full') {
            return model;
        }
        if (!isArray(model)) {
            return mapModel(model);
        }
        return model.map(mapModel);
    }
    normalizeModelValue(value) {
        if (isNumber(value) || isString(value)) {
            return [{ id: value }];
        }
        if (isArray(value)) {
            return value;
        }
        if (isObject(value)) {
            return [value];
        }
        return [];
    }
}
AssetSelectorService.ɵprov = i0.ɵɵdefineInjectable({ factory: function AssetSelectorService_Factory() { return new AssetSelectorService(i0.ɵɵinject(i1.InventoryService), i0.ɵɵinject(i2.ApiService), i0.ɵɵinject(i3.ModalService), i0.ɵɵinject(i3.AlertService), i0.ɵɵinject(i3.BreadcrumbService), i0.ɵɵinject(i4.UserService), i0.ɵɵinject(i3.AppStateService), i0.ɵɵinject(i3.OptionsService), i0.ɵɵinject(ASSET_NAVIGATOR_CONFIG, 8), i0.ɵɵinject(DeviceGroupService)); }, token: AssetSelectorService, providedIn: "root" });
AssetSelectorService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];

const CONFIG_OPTIONS_DEFAULT = {
    label: gettext('Asset selection'),
    multi: false,
    showFilter: false,
    columnHeaders: false,
    singleColumn: false,
    modelMode: 'simple',
    groupsOnly: false,
    groupsSelectable: false,
    search: false,
    showUnassignedDevices: false,
    view: 'tree',
    showChildDevices: false
};

class UnassignedDevicesNode extends GroupNode {
    constructor(service, config = {}) {
        super(service, config);
        this.service = service;
        this.label = gettext('Unassigned devices');
        this.icon = 'delete-folder';
        this.groupsSelectable = false;
        this.groupsOnly = false;
        this.showChildDevices = false;
        this.mo = {};
        this.priority = Infinity;
        this.showChildDevices = config.showChildDevices || false;
    }
    click(options = {}) {
        this.hookEvents();
        if (options.open) {
            this.events.next(Action.FETCH);
        }
    }
    addManagedObject(mo) {
        this.add(this.service.createChildNode({ mo, showChildDevices: this.showChildDevices }));
    }
    fetch() {
        return this.service.getUnassignedDevices(this.showChildDevices, this.filterQuery$.value);
    }
    isGroup() {
        return true;
    }
    toString() {
        return UnassignedDevicesNode.NAME;
    }
}
UnassignedDevicesNode.NAME = 'UnassignedDevicesNode';

class AssetSelectorBase {
    constructor(groupNodeService, inventory, assetSelectorService) {
        this.groupNodeService = groupNodeService;
        this.inventory = inventory;
        this.assetSelectorService = assetSelectorService;
        /**
         * Config object containing all options for the asset selector.
         */
        this.config = {};
        /**
         * The loading state of the current node.
         */
        this.isLoading = false;
        /**
         * Emit the selected asset or assets.
         */
        this.onSelected = new EventEmitter();
    }
    /**
     * @ignore
     */
    validate(control) {
        if (this.config.required && (!control.value || control.value.length === 0)) {
            return { required: true };
        }
        return null;
    }
    /**
     * @ignore
     */
    writeValue(obj) {
        this.selected = this.assetSelectorService.normalizeValue(obj, this.config.modelMode);
    }
    /**
     * @ignore
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @ignore
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @ignore
     */
    doBlur() {
        if (this.onTouched) {
            this.onTouched();
        }
    }
    /**
     * Deselects all expect the given one.
     * @param selectedMo The selected asset (optional, if empty -> just deselect all).
     */
    deselectAll(selectedMo) {
        this.selected = [];
        if (selectedMo) {
            this.selected = [this.assetSelectorService.simplifyModel(selectedMo, this.config.modelMode)];
        }
        this.emitChange(this.selected, selectedMo, !!selectedMo);
        this.doBlur();
    }
    /**
     * Adds an managed object to the selected array and emits the change.
     * @param selectedMo The selected asset.
     */
    select(selectedMo) {
        if (!this.config.multi) {
            this.selected = [];
        }
        const index = this.getIndexOfSelected(this.selected, selectedMo);
        if (index === -1) {
            this.selected.push(this.assetSelectorService.simplifyModel(selectedMo, this.config.modelMode));
        }
        this.emitChange(this.selected, selectedMo, true);
        this.doBlur();
    }
    /**
     * Removes a managed object from the selected array and emits the change.
     * @param selectedMo The selected asset.
     */
    deselect(selectedMo) {
        const index = this.getIndexOfSelected(this.selected, selectedMo);
        if (index > -1) {
            this.selected.splice(index, 1);
        }
        this.emitChange(this.selected, selectedMo, false);
        this.doBlur();
    }
    /**
     * Returns the index of the currently selected item.
     * @param selected All selected items
     * @param selectedMo The new selected item-
     * @returns An index, or -1 if not found.
     */
    getIndexOfSelected(selected, selectedMo) {
        return selected.findIndex(mo => mo.id === selectedMo.id);
    }
    emitChange(selected, item, isSelected) {
        const changes = this.config.multi ? selected : selected[0];
        if (this.onChange) {
            this.onChange(changes);
        }
        this.onSelected.emit({ items: changes, change: { item, isSelected } });
    }
    createDefaultRootNode() {
        return this.groupNodeService.createGroupNode({
            root: true,
            groupsSelectable: this.config.groupsSelectable,
            groupsOnly: this.config.groupsOnly,
            showChildDevices: this.config.showChildDevices
        });
    }
    createManagedObjectRootNode(asset) {
        return __awaiter(this, void 0, void 0, function* () {
            if (asset.id) {
                return this.groupNodeService.createGroupNode({
                    mo: asset,
                    groupsSelectable: this.config.groupsSelectable,
                    groupsOnly: this.config.groupsOnly,
                    showChildDevices: this.config.showChildDevices
                });
            }
            const { data: mo } = yield this.inventory.detail(asset);
            return this.groupNodeService.createGroupNode({
                mo,
                groupsSelectable: this.config.groupsSelectable,
                groupsOnly: this.config.groupsOnly,
                showChildDevices: this.config.showChildDevices
            });
        });
    }
}

/**
 * Displays a hierarchical tree selector for assets.
 */
class AssetSelectorComponent extends AssetSelectorBase {
    /**
     * @ignore only DI
     */
    constructor(groupNodeService, inventory, assetSelectorService, cd) {
        super(groupNodeService, inventory, assetSelectorService);
        this.groupNodeService = groupNodeService;
        this.inventory = inventory;
        this.assetSelectorService = assetSelectorService;
        this.cd = cd;
        /**
         * Config object containing all options for the asset selector.
         */
        this.config = {};
        /**
         * Used only for miller-view, displays the column level for the current node.
         * E.g if the index is one, this will be second column.
         */
        this.index = 0;
        /**
         * The asset to use as root.
         */
        this.asset = undefined;
        /**
         * The selected device.
         */
        this.selectedDevice = undefined;
        /**
         * An array of predefined nodes.
         */
        this.selected = [];
        /**
         * All currently selected assets.
         */
        this.selectedItems = [];
        this.container = 'body';
        /**
         * Emits if one item was selected (all currently selected nodes).
         */
        this.onSelected = new EventEmitter();
        /**
         * Used only for miller view. Emit the selected node and use it as a 'rootNode' for the new column.
         */
        this.onRowSelected = new EventEmitter();
        /**
         * Emits the current loading state of the node.
         */
        this.onLoad = new EventEmitter();
        /**
         * The current filter applied.
         */
        this.filterText = '';
        /**
         * Displays the global search at all times if the miller view is used
         * on root group level.
         */
        this.root = false;
        /**
         * @ignore
         */
        this.unsubscribe$ = new Subject();
    }
    /**
     * Checks when a node was selected, if a new column needs to be added.
     * @param node The node that was clicked.
     * @param index The current index of this node.
     * @returns True if the click was handled and a new column was added.
     */
    handleNextMillerViewColumn(node, index) {
        const nodeCopy = Object.create(node);
        const isSameAsRoot = this.rootNode === node;
        const isUnassignedDevicesNode = node.toString() === UnassignedDevicesNode.NAME;
        const isNewColumnNeeded = !isSameAsRoot && (node.isGroup() || isUnassignedDevicesNode || node.hasChildDevices());
        if (isNewColumnNeeded) {
            this.onRowSelected.emit({ nodeCopy, index });
            return false;
        }
        return true;
    }
    /**
     * @ignore
     */
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.index === 0) {
                this.config = Object.assign(Object.assign({}, CONFIG_OPTIONS_DEFAULT), this.config);
            }
            const shouldResetNameFilter = this.rootNode && this.rootNode.mo && this.config.view === 'miller';
            if (shouldResetNameFilter) {
                this.applyFilter('');
            }
            const isOnlyAssetNodeDefined = this.asset;
            if (isOnlyAssetNodeDefined) {
                this.rootNode = yield this.createManagedObjectRootNode(this.asset);
            }
            const isAnyNodeDefined = !this.rootNode && (!this.asset || Object.keys(this.asset).length === 0);
            if (isAnyNodeDefined) {
                this.rootNode = this.createDefaultRootNode();
            }
            if (this.config.showUnassignedDevices &&
                (!this.asset || Object.keys(this.asset).length === 0) &&
                this.rootNode.root) {
                this.rootNode.add(new UnassignedDevicesNode(this.groupNodeService, {
                    showChildDevices: this.config.showChildDevices
                }));
            }
            this.root = this.rootNode.root;
        });
    }
    ngOnChanges(changes) {
        return __awaiter(this, void 0, void 0, function* () {
            if (changes.asset &&
                changes.asset.currentValue &&
                Object.keys(changes.asset.currentValue).length !== 0) {
                this.rootNode = yield this.createManagedObjectRootNode(changes.asset.currentValue);
            }
        });
    }
    /**
     * Changes the current root to one level back.
     */
    back() {
        const index = this.index - 1;
        const nodeCopy = Object.create(this.rootNode.parents[0]);
        this.onRowSelected.emit({ nodeCopy, index });
    }
    /**
     * Clears the current filter.
     */
    clearFilters() {
        this.filterText = '';
        this.applyFilter('');
    }
    clearSelectedDevices() {
        this.selectedDevice = undefined;
        this.applyFilter('');
    }
    isGroupSelected() {
        if (this.selectedItems.some(selectedNode => { var _a; return selectedNode.id === ((_a = this.rootNode.mo) === null || _a === void 0 ? void 0 : _a.id); })) {
            return true;
        }
        return false;
    }
    groupNameFilter(nameFilter, moId, showUnassignedDevices) {
        if (nameFilter) {
            const filterByName = showUnassignedDevices
                ? {
                    __filter: {
                        name: nameFilter
                    },
                    __orderby: [{ name: 1 }]
                }
                : {
                    __filter: {
                        name: nameFilter,
                        __bygroupid: moId
                    }
                };
            return this.assetSelectorService.queriesUtil.buildQuery(filterByName);
        }
        const defaultFilter = {
            __filter: {
                __bygroupid: moId
            },
            __orderby: [{ name: 1 }]
        };
        return this.assetSelectorService.queriesUtil.buildQuery(defaultFilter);
    }
    /**
     * Applies a filter.
     * @param filter The filter to apply.
     */
    applyFilter(filter) {
        return __awaiter(this, void 0, void 0, function* () {
            this.rootNode.filterQuery$.next(this.groupNameFilter(filter, this.rootNode.mo.id, this.isUnassignedDevicesNode() ? true : false));
            this.rootNode.refresh();
            this.onLoad.emit({
                loading: true,
                filterText: this.filterText,
                index: this.index,
                selectedDevice: this.selectedDevice
            });
            this.cd.detectChanges();
        });
    }
    /**
     * Check if the UnassignedDevice node is the rootNode.
     */
    isUnassignedDevicesNode() {
        return this.rootNode.toString() === UnassignedDevicesNode.NAME;
    }
    /**
     * Called when the user resets the search result.
     */
    onSearchResultReset(term) {
        if (term) {
            this.deselectAll();
            this.rootNode = this.createDefaultRootNode();
            if (this.config.showUnassignedDevices) {
                this.rootNode.add(new UnassignedDevicesNode(this.groupNodeService, {
                    showChildDevices: this.config.showChildDevices
                }));
            }
            if (this.config.view === 'miller') {
                this.onRowSelected.emit({ root: true });
            }
            this.rootNode.click({ open: true });
            if (this.config.view === 'tree') {
                this.rootNode.open = true;
            }
        }
    }
    /**
     * Called if the user clicks on a search result.
     */
    onSearchResultClick(mo) {
        return __awaiter(this, void 0, void 0, function* () {
            const canSelectNode = this.config.groupsSelectable || !this.groupNodeService.isGroup(mo);
            this.rootNode = yield this.createManagedObjectRootNode(mo);
            this.rootNode.click({ open: true });
            if (this.config.view === 'miller') {
                const nodeCopy = Object.create(this.rootNode);
                this.onRowSelected.emit({
                    nodeCopy,
                    index: 0,
                    selectedDevices: this.selectedDevice,
                    root: true
                });
            }
            this.deselectAll();
            if (canSelectNode) {
                this.select(this.rootNode.mo);
            }
        });
    }
}
AssetSelectorComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-asset-selector',
                template: "<div\n  class=\"p-b-8 bg-inherit\"\n  [ngClass]=\"{ 'p-l-16 p-absolute p-r-16': config.view === 'miller' }\"\n  style=\"left: 0; right: 4px\"\n  [ngStyle]=\"{ 'z-index': config.singleColumn ? '30' : '20' }\"\n  *ngIf=\"!selectedDevice && index === 0 && (config.search || config.singleColumn)\"\n>\n  <p class=\"text-medium m-b-4 p-t-8\">\n    {{ config.label | translate }}\n  </p>\n  <c8y-search-input\n    *ngIf=\"config.search && root\"\n    (onClick)=\"onSearchResultClick($event)\"\n    (reset)=\"onSearchResultReset($event)\"\n    [mode]=\"'select'\"\n    [container]=\"container\"\n  ></c8y-search-input>\n</div>\n\n<div *ngIf=\"selectedDevice\" class=\"p-r-16\">\n  <div class=\"d-flex p-b-4\">\n    <p *ngIf=\"selectedDevice; else multiAssets\" class=\"text-medium p-t-8 m-r-8\">\n      {{ 'Selected asset' | translate }}\n    </p>\n    <ng-template #multiAssets>\n      <p class=\"text-medium m-r-8\">{{ 'Selected assets' | translate }}</p>\n    </ng-template>\n    <button\n      class=\"btn btn-default btn-xs a-s-center m-t-4 m-l-auto\"\n      (click)=\"clearSelectedDevices()\"\n      title=\"{{ 'Edit' | translate }}\"\n    >\n      {{ 'Change' | translate }}\n    </button>\n  </div>\n  <div class=\"d-flex\">\n    <i [c8yIcon]=\"'check-circle'\" class=\"text-success p-l-0 p-r-8\"></i>\n    <i\n      c8yIcon=\"{{ selectedDevice.type === 'c8y_DeviceGroup' ? 'c8y-group' : 'exchange' }}\"\n      class=\"m-r-4 icon-20\"\n    ></i>\n    <span>{{ selectedDevice.name }}</span>\n  </div>\n</div>\n\n<!-- miller columns header -->\n<div\n  *ngIf=\"\n    config.view === 'miller' &&\n    ((config.showFilter && !rootNode.root) || config.columnHeaders || config.singleColumn) &&\n    !selectedDevice\n  \"\n  class=\"miller-column__header sticky-top bg-inherit separator-top-bottom\"\n  [ngClass]=\"{ 'm-t-72 ': config.search, 'm-t-32': !config.search && config.singleColumn }\"\n  [ngStyle]=\"{ top: config.search && !config.singleColumn ? '72px' : '0' }\"\n>\n  <p\n    class=\"text-12 text-muted text-truncate m-b-4\"\n    *ngIf=\"config.singleColumn && index !== 0\"\n    title=\"{{ rootNode.breadcrumb || rootNode.label | translate }}\"\n  >\n    <i c8yIcon=\"home\" class=\"m-r-4\"></i>\n    {{ rootNode.breadcrumb || rootNode.label | translate }}\n  </p>\n  <div *ngIf=\"config.columnHeaders || config.singleColumn\" class=\"d-flex a-i-center p-b-4\">\n    <button\n      class=\"btn btn-default btn-xs m-r-8 p-t-0 p-b-0 p-l-4 p-r-4 l-h-1\"\n      *ngIf=\"config.singleColumn && !rootNode.root && index !== 0\"\n      title=\"{{ 'Back' | translate }}\"\n      (click)=\"back()\"\n    >\n      <i c8yIcon=\"angle-left\"></i>\n    </button>\n    <label\n      *ngIf=\"!rootNode.root && index === 0 && (config.groupsSelectable || !rootNode.isGroup())\"\n      class=\"c8y-radio checkbox-inline m-r-8\"\n    >\n      <input\n        type=\"radio\"\n        (change)=\"select(rootNode.mo)\"\n        [checked]=\"isGroupSelected()\"\n        title=\"{{ 'Select group' | translate }}\"\n      /><span></span>\n    </label>\n\n    <p\n      class=\"text-truncate\"\n      title=\"{{ rootNode.label | translate }}\"\n      *ngIf=\"config.columnHeaders\"\n      [ngClass]=\"{\n        'text-label-small': !config.singleColumn,\n        'text-medium': config.singleColumn\n      }\"\n    >\n      <i\n        *ngIf=\"config.singleColumn || (!rootNode.root && index === 0)\"\n        c8yIcon=\"c8y-group-open\"\n        class=\"icon-20 c8y-icon-duocolor m-r-4\"\n      ></i>\n      {{ rootNode.label | translate }}\n    </p>\n  </div>\n\n  <div *ngIf=\"!rootNode.root && config.showFilter\" [ngClass]=\"{ 'p-t-4': config.columnHeaders }\">\n    <div class=\"input-group input-group-sm input-group-search\">\n      <input\n        [(ngModel)]=\"filterText\"\n        placeholder=\"{{ 'Filter this column\u2026' | translate }}\"\n        class=\"form-control\"\n        (keyup.enter)=\"applyFilter('*' + filterText + '*')\"\n      />\n      <span class=\"input-group-btn\">\n        <button\n          title=\"{{ 'Apply filter' | translate }}\"\n          class=\"btn btn-clean p-r-8 p-l-4\"\n          (click)=\"applyFilter('*' + filterText + '*')\"\n        >\n          <i c8yIcon=\"filter\"></i>\n        </button>\n        <button\n          title=\" {{ 'Clear filters' | translate }}\"\n          class=\"btn btn-clean p-r-8 p-l-4\"\n          (click)=\"clearFilters()\"\n          *ngIf=\"filterText.length\"\n        >\n          <i c8yIcon=\"times\"></i>\n        </button>\n      </span>\n    </div>\n  </div>\n</div>\n\n<c8y-asset-selector-node\n  *ngIf=\"rootNode && !selectedDevice\"\n  [node]=\"rootNode\"\n  [preselected]=\"selected\"\n  [multi]=\"config.multi\"\n  [view]=\"config.view\"\n  [index]=\"index\"\n  [selectedItems]=\"selectedItems\"\n  [active]=\"active\"\n  class=\"d-block bg-inherit p-relative\"\n  [ngClass]=\"{ 'collapse show': !rootNode.root && !rootNode.hidden && config.view !== 'miller' }\"\n  style=\"z-index: 9\"\n></c8y-asset-selector-node>\n",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        multi: true,
                        useExisting: forwardRef(() => AssetSelectorComponent)
                    },
                    {
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef(() => AssetSelectorComponent),
                        multi: true
                    }
                ]
            },] }
];
AssetSelectorComponent.ctorParameters = () => [
    { type: GroupNodeService },
    { type: InventoryService },
    { type: AssetSelectorService },
    { type: ChangeDetectorRef }
];
AssetSelectorComponent.propDecorators = {
    config: [{ type: Input }],
    active: [{ type: Input }],
    index: [{ type: Input }],
    asset: [{ type: Input }],
    selectedDevice: [{ type: Input }],
    selected: [{ type: Input }],
    rootNode: [{ type: Input }],
    selectedItems: [{ type: Input }],
    container: [{ type: Input }],
    onSelected: [{ type: Output }],
    onRowSelected: [{ type: Output }],
    onLoad: [{ type: Output }]
};

class AssetSelectorNodeComponent {
    /**
     * @ignore only di
     */
    constructor(translateService, cd, parentAssetSelector) {
        this.translateService = translateService;
        this.cd = cd;
        this.parentAssetSelector = parentAssetSelector;
        /**
         * All preselected items.
         */
        this.preselected = [];
        /**
         * Should the path be shown.
         */
        this.showPath = false;
        /**
         * Can the user select multiple assets.
         */
        this.multi = false;
        /**
         * The current path to the node.
         */
        this.view = 'tree';
        /**
         * All currently selected assets.
         */
        this.selectedItems = [];
        /**
         * @ignore
         */
        this.level = 0;
        /**
         * @ignore
         */
        this.unsubscribe$ = new Subject();
        /** sets the `btn-pending` class in the load more button */
        this.isLoading = false;
    }
    /**
     * @ignore
     */
    get expandTitle() {
        return !this.node.open ? gettext('Expand') : gettext('Collapse');
    }
    /**
     * @ignore
     */
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.breadcrumb = this.node.label;
            this.setupBreadcrumbsAndLevel(this.node);
            if (this.node instanceof GroupNode) {
                this.node.hookEvents();
            }
            // open on startup
            if (this.node.root) {
                this.click();
            }
            // used for loading and to trigger change detection when the node is no longer loading.
            if (this.node.events) {
                this.node.events
                    .pipe(takeUntil(this.unsubscribe$), filter((a) => a === Action.LOADING_DONE))
                    .subscribe(() => {
                    this.parentAssetSelector.onLoad.emit({
                        loading: false,
                        filterText: this.parentAssetSelector.filterText
                    });
                    this.cd.markForCheck();
                });
            }
        });
    }
    /**
     * Opens a node.
     */
    click() {
        this.node.open = !this.node.open;
        this.node.click({ open: this.node.open });
    }
    setupBreadcrumbsAndLevel(node) {
        if (node.parents && node.parents.length) {
            const parent = node.parents[0];
            this.breadcrumb =
                this.translateService.instant(parent.label) +
                    ' > ' +
                    this.translateService.instant(this.breadcrumb);
            this.level++;
            this.setupBreadcrumbsAndLevel(parent);
        }
    }
    /**
     * Selects the node and emits a change on the parent component.
     * @param node The node to select.
     */
    selected(node) {
        if (node.mo) {
            this.updateSelection(node.mo);
            return;
        }
        this.click();
    }
    /**
     * Handles clicks on a item in Miller View.
     * @param node The node that was clicked.
     */
    millerViewClick(node) {
        node.breadcrumb = this.breadcrumb;
        const shouldHandleDefault = this.parentAssetSelector.handleNextMillerViewColumn(node, this.index);
        if (shouldHandleDefault) {
            this.selected(node);
        }
    }
    /**
     * @ignore
     */
    ngOnDestroy() {
        this.unsubscribe$.next(true);
        this.unsubscribe$.complete();
    }
    isSelected() {
        if (!this.node.mo) {
            return false;
        }
        return this.parentAssetSelector.getIndexOfSelected(this.preselected, this.node.mo) > -1;
    }
    isActive() {
        var _a;
        if (this.active && this.node.mo) {
            return ((_a = this.active.mo) === null || _a === void 0 ? void 0 : _a.id) === this.node.mo.id;
        }
        return false;
    }
    isGroupSelected() {
        if (this.selectedItems.some(selectedNode => { var _a; return selectedNode.id === ((_a = this.node.mo) === null || _a === void 0 ? void 0 : _a.id); })) {
            return true;
        }
        return false;
    }
    updateSelection(selectedMo) {
        if (!this.multi) {
            this.parentAssetSelector.deselectAll(selectedMo);
            return;
        }
        if (this.isSelected()) {
            this.parentAssetSelector.deselect(selectedMo);
            return;
        }
        this.parentAssetSelector.select(selectedMo);
    }
}
AssetSelectorNodeComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-asset-selector-node',
                template: "<!-- Hierarchy tree -->\n<div\n  *ngIf=\"view === 'tree'\"\n  class=\"c8y-asset-selector__item\"\n  [attr.role]=\"view === 'tree' ? 'tree' : 'list'\"\n  [ngClass]=\"{\n    'c8y-asset-selector__item--more': node?.icon === 'plus',\n    'c8y-asset-selector__item--start': level === 0\n  }\"\n  [ngStyle]=\"{\n    'margin-left': level > 1 ? 16 + 'px' : '0'\n  }\"\n>\n  <div\n    *ngIf=\"node && !node.root && !node.hidden\"\n    class=\"c8y-asset-selector__node\"\n    [attr.role]=\"view === 'tree' ? 'treeitem' : 'listitem'\"\n    [ngClass]=\"{ 'c8y-asset-selector__node--open': node?.open }\"\n    title=\"{{ breadcrumb | translate }}\"\n  >\n    <div class=\"d-flex a-i-center p-t-4 p-b-4 m-r-8\" *ngIf=\"node.toString() !== 'LoadMoreNode'\">\n      <label [ngClass]=\"{ 'c8y-checkbox': multi, 'c8y-radio': !multi }\">\n        <input\n          [attr.aria-label]=\"node.label | translate\"\n          [type]=\"multi ? 'checkbox' : 'radio'\"\n          (change)=\"selected(node)\"\n          [checked]=\"isSelected()\"\n          [disabled]=\"!node.groupsSelectable && node.isGroup()\"\n        />\n        <span></span>\n      </label>\n    </div>\n\n    <!-- group button -->\n    <button\n      *ngIf=\"node.isGroup() || node.hasChildDevices()\"\n      class=\"c8y-asset-selector__btn text-truncate\"\n      (click)=\"click()\"\n      [attr.aria-expanded]=\"!node.open\"\n    >\n      <i\n        [c8yIcon]=\"node.icon\"\n        *ngIf=\"node.icon === 'c8y-group-smart'\"\n        [title]=\"'Smart group' | translate\"\n        class=\"c8y-icon c8y-icon-duocolor m-r-4 text-16\"\n      ></i>\n      <i\n        [c8yIcon]=\"node.icon\"\n        *ngIf=\"node.icon !== 'c8y-group-smart'\"\n        [title]=\"'Group' | translate\"\n        class=\"c8y-icon c8y-icon-duocolor m-r-4 text-16\"\n      ></i>\n      <span title=\"{{ breadcrumb }}\">\n        {{ node.label | translate }}\n        <!-- use just for search results to display the path -->\n        <p *ngIf=\"showPath\" class=\"text-truncate\">\n          <small class=\"text-muted\" title=\"{{ breadcrumb }}\">\n            <em>{{ breadcrumb }}</em>\n          </small>\n        </p>\n        <!-- up to here -->\n      </span>\n    </button>\n    <!-- not a group button -->\n    <button\n      *ngIf=\"!node.isGroup() && !node.hasChildDevices()\"\n      class=\"flex-grow\"\n      [ngClass]=\"{\n        'btn btn-default btn-sm m-b-8 d-flex j-c-center': node.icon === 'plus',\n        'c8y-asset-selector__btn text-truncate': node.icon != 'plus'\n      }\"\n      (click)=\"selected(node)\"\n      type=\"button\"\n      title=\"{{ breadcrumb }}\"\n    >\n      <i\n        [c8yIcon]=\"node.icon\"\n        *ngIf=\"node.icon === 'c8y-group-smart'\"\n        [title]=\"'Smart group' | translate\"\n        class=\"c8y-icon c8y-icon-duocolor m-r-4 text-16\"\n      ></i>\n      <i\n        [c8yIcon]=\"node.icon\"\n        *ngIf=\"node.icon !== 'c8y-group-smart'\"\n        [title]=\"'Group' | translate\"\n        [ngClass]=\"{ 'c8y-icon-duocolor text-16 ': node.icon != 'plus' }\"\n        class=\"c8y-icon m-r-4\"\n      ></i>\n      <span title=\"{{ breadcrumb }}\">\n        {{ node.label | translate }}\n        <!-- use just for search results to display the path -->\n        <p *ngIf=\"showPath\" class=\"text-truncate text-muted small\">\n          <em>{{ breadcrumb }}</em>\n        </p>\n        <!-- up to here -->\n      </span>\n    </button>\n    <!-- expand button (only for groups) -->\n    <div *ngIf=\"node.isGroup() || node.hasChildDevices()\">\n      <button\n        [title]=\"expandTitle\"\n        class=\"collapse-btn btn\"\n        (click)=\"click()\"\n        [attr.aria-expanded]=\"node.open\"\n      >\n        <i c8yIcon=\"angle-down\"></i>\n      </button>\n    </div>\n  </div>\n  <div\n    *ngIf=\"node.countChildren()\"\n    class=\"collapse\"\n    [collapse]=\"!node.open\"\n    [isAnimated]=\"true\"\n    [attr.role]=\"'group'\"\n  >\n    <c8y-asset-selector-node\n      *ngFor=\"let childNode of node.children\"\n      [node]=\"childNode\"\n      [preselected]=\"preselected || []\"\n      [multi]=\"multi\"\n      [active]=\"active\"\n      [attr.role]=\"view === 'tree' ? 'treeitem' : 'listitem'\"\n    ></c8y-asset-selector-node>\n  </div>\n</div>\n\n<!-- Miller columns -->\n<div *ngIf=\"view === 'miller'\">\n  <div\n    *ngIf=\"node && !node.root && !node.hidden && node !== parentAssetSelector.rootNode\"\n    class=\"miller-column__item bg-inherit\"\n    [ngClass]=\"{\n      active: isActive(),\n      'miller-column__item--more': node.toString() === 'LoadMoreNode'\n    }\"\n    title=\"{{ breadcrumb | translate }}\"\n  >\n    <div\n      class=\"m-l-4 m-r-4 miller-column__item__checkbox\"\n      *ngIf=\"node.toString() !== 'LoadMoreNode'\"\n    >\n      <label [ngClass]=\"{ 'c8y-radio': !multi, 'c8y-checkbox': multi }\">\n        <input\n          [attr.aria-label]=\"node.label | translate\"\n          [type]=\"multi ? 'checkbox' : 'radio'\"\n          (change)=\"selected(node)\"\n          [checked]=\"isGroupSelected()\"\n          [disabled]=\"!node.groupsSelectable && node.isGroup()\"\n        />\n        <span></span>\n      </label>\n    </div>\n\n    <button\n      [ngClass]=\"{\n        'btn btn-default btn-sm d-flex flex-grow j-c-center m-l-16 m-r-16 m-b-8':\n          node.toString() === 'LoadMoreNode',\n        'miller-column__item__btn': node.toString() !== 'LoadMoreNode',\n        'btn-pending': node.loading && node.toString() === 'LoadMoreNode'\n      }\"\n      title=\"{{ breadcrumb | translate }}\"\n      (click)=\"millerViewClick(node)\"\n      type=\"button\"\n    >\n      <i\n        [c8yIcon]=\"node.icon\"\n        class=\"c8y-icon m-r-4\"\n        [ngClass]=\"{ 'c8y-icon-duocolor text-16': node.toString() !== 'LoadMoreNode' }\"\n      ></i>\n      <div class=\"text-left text-truncate\">\n        <p title=\"{{ node.label | translate }}\" class=\"text-truncate\">\n          {{ node.label | translate }}\n        </p>\n        <!-- use just for search results to display the path -->\n        <small *ngIf=\"showPath\" class=\"text-muted text-truncate\" title=\"{{ breadcrumb }}\">\n          <em>{{ breadcrumb }}</em>\n        </small>\n        <!-- up to here -->\n      </div>\n      <span *ngIf=\"node.isGroup() || node.hasChildDevices()\" class=\"p-l-4 m-l-auto\">\n        <i c8yIcon=\"angle-right\"></i>\n      </span>\n    </button>\n  </div>\n\n  <div *ngIf=\"node\" [ngClass]=\"{ hidden: node !== parentAssetSelector.rootNode }\" role=\"list\">\n    <c8y-asset-selector-node\n      *ngFor=\"let childNode of node.children\"\n      [node]=\"childNode\"\n      [preselected]=\"preselected || []\"\n      [multi]=\"multi\"\n      [view]=\"view\"\n      [index]=\"index\"\n      [selectedItems]=\"selectedItems\"\n      [active]=\"active\"\n      role=\"listitem\"\n    ></c8y-asset-selector-node>\n  </div>\n</div>\n"
            },] }
];
AssetSelectorNodeComponent.ctorParameters = () => [
    { type: TranslateService },
    { type: ChangeDetectorRef },
    { type: AssetSelectorComponent }
];
AssetSelectorNodeComponent.propDecorators = {
    node: [{ type: Input }],
    preselected: [{ type: Input }],
    showPath: [{ type: Input }],
    multi: [{ type: Input }],
    view: [{ type: Input }],
    index: [{ type: Input }],
    active: [{ type: Input }],
    selectedItems: [{ type: Input }]
};

class MillerViewComponent extends AssetSelectorBase {
    constructor(groupNodeService, inventory, assetSelectorService, cd) {
        super(groupNodeService, inventory, assetSelectorService);
        this.groupNodeService = groupNodeService;
        this.inventory = inventory;
        this.assetSelectorService = assetSelectorService;
        this.cd = cd;
        /**
         * Config object containing all options for the asset selector.
         */
        this.config = {};
        /**
         * The asset to use as root.
         */
        this.asset = undefined;
        /**
         * The selected devices.
         */
        this.selectedDevice = undefined;
        /**
         * Emits if the selection changes
         */
        this.onSelected = new EventEmitter();
        /**
         * The column array will contain all currently selected nodes
         *  which will form the miller view columns (only one per level).
         */
        this.columns = [];
        /**
         * The current filter applied. Used for the empty state text in the view.
         */
        this.filterText = '';
        this.container = 'body';
        this.configOptionsDefault = {
            view: 'miller',
            singleColumn: false
        };
    }
    /**
     * @ignore
     */
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.config = Object.assign(Object.assign({}, this.configOptionsDefault), this.config);
            const isAnyNodeDefined = !this.rootNode && (!this.asset || Object.keys(this.asset).length === 0);
            if (isAnyNodeDefined) {
                this.rootNode = this.createDefaultRootNode();
            }
            const isOnlyAssetNodeDefined = this.asset && Object.keys(this.asset).length !== 0;
            if (isOnlyAssetNodeDefined) {
                this.rootNode = yield this.createManagedObjectRootNode(this.asset);
                this.rootNode.click();
            }
            this.columns.push(this.rootNode);
        });
    }
    /**
     * @ignore
     */
    ngOnChanges(changes) {
        return __awaiter(this, void 0, void 0, function* () {
            if (changes.asset && changes.asset.currentValue && !this.asset) {
                this.columns = [];
                this.columns.push(yield this.createManagedObjectRootNode(changes.asset.currentValue));
            }
        });
    }
    /**
     * Create a new column with the selected node as root.
     */
    addNewColumn(node) {
        const level = node.index;
        this.selectedDevice = node.selectedDevices || undefined;
        if (node.root) {
            window.requestAnimationFrame(() => (this.millerViewWrapper.nativeElement.scrollLeft = 0));
            this.columns.length = 1;
        }
        const isLevelLowerThanColumnNumber = level < this.columns.length - 1;
        let goBack = false;
        if (isLevelLowerThanColumnNumber) {
            this.columns.length = level + 1;
            goBack = true;
        }
        if (!node.root && !(this.config.singleColumn && goBack)) {
            this.columns.push(node.nodeCopy);
            window.requestAnimationFrame(() => (this.millerViewWrapper.nativeElement.scrollLeft = 99999));
        }
    }
    /**
     * Change the loading state of the asset selector.
     */
    onLoad(event) {
        this.isLoading = event.loading;
        this.filterText = event.filterText;
        this.columnIndex = event.index;
        this.selectedDevice = event.selectedDevice;
        this.cd.detectChanges();
    }
    /**
     * Add the selected node to the selected array.
     */
    onSelectionChange(event) {
        if (!this.config.multi) {
            this.deselectAll(event.change.item);
            return;
        }
        if (event.change.isSelected) {
            this.select(event.change.item);
            return;
        }
        this.deselect(event.change.item);
    }
}
MillerViewComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-asset-selector-miller',
                template: "<div\n  #millerViewWrapper\n  class=\"miller-view-wrapper\"\n  [ngClass]=\"{ 'single-column': config.singleColumn }\"\n>\n  <div *ngFor=\"let column of columns; index as i\" class=\"miller-column bg-inherit\">\n    <c8y-asset-selector\n      [config]=\"config\"\n      [index]=\"i\"\n      [active]=\"columns[i + 1]\"\n      [rootNode]=\"column\"\n      [selectedItems]=\"selected || []\"\n      [selectedDevice]=\"selectedDevice\"\n      (onSelected)=\"onSelectionChange($event)\"\n      (onRowSelected)=\"addNewColumn($event)\"\n      (onLoad)=\"onLoad($event)\"\n      [container]=\"container\"\n      class=\"bg-inherit\"\n    >\n    </c8y-asset-selector>\n\n    <div class=\"p-relative p-b-64\" *ngIf=\"isLoading && columnIndex === i && !selectedDevice\">\n      <c8y-loading></c8y-loading>\n    </div>\n\n    <div *ngIf=\"!column.children.length && !isLoading\" class=\"p-l-8 p-r-8\">\n      <c8y-ui-empty-state\n        *ngIf=\"!filterText; else noSearchResults\"\n        [icon]=\"'folder-open'\"\n        [title]=\"'No results to display.' | translate\"\n        [subtitle]=\"'The selected asset has no children.' | translate\"\n        [horizontal]=\"true\"\n      ></c8y-ui-empty-state>\n      <ng-template #noSearchResults>\n        <c8y-ui-empty-state\n          [icon]=\"'folder-open'\"\n          [title]=\"'No results to display for the current filter.' | translate\"\n          [subtitle]=\"'There are no assets matching the filter.' | translate\"\n          [horizontal]=\"true\"\n        ></c8y-ui-empty-state>\n      </ng-template>\n    </div>\n  </div>\n</div>\n",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => MillerViewComponent),
                        multi: true
                    }
                ]
            },] }
];
MillerViewComponent.ctorParameters = () => [
    { type: GroupNodeService },
    { type: InventoryService },
    { type: AssetSelectorService },
    { type: ChangeDetectorRef }
];
MillerViewComponent.propDecorators = {
    config: [{ type: Input }],
    asset: [{ type: Input }],
    selectedDevice: [{ type: Input }],
    rootNode: [{ type: Input }],
    onSelected: [{ type: Output }],
    millerViewWrapper: [{ type: ViewChild, args: ['millerViewWrapper',] }],
    container: [{ type: Input }]
};

class AssetSelectorModule {
}
AssetSelectorModule.decorators = [
    { type: NgModule, args: [{
                imports: [CoreModule, CommonModule, CollapseModule, BsDropdownModule, SearchModule, FormsModule],
                exports: [AssetSelectorNodeComponent, AssetSelectorComponent, MillerViewComponent],
                providers: [GroupNodeService, AssetSelectorService],
                declarations: [AssetSelectorNodeComponent, AssetSelectorComponent, MillerViewComponent]
            },] }
];

class AssetsNavigatorModule {
    static config(config = {}) {
        return {
            ngModule: AssetsNavigatorModule,
            providers: [
                {
                    provide: ASSET_NAVIGATOR_CONFIG,
                    useValue: config
                }
            ]
        };
    }
}
AssetsNavigatorModule.decorators = [
    { type: NgModule, args: [{
                declarations: [],
                imports: [ModalModule, AssetSelectorModule, DeviceStatusModule],
                providers: [
                    ModalService,
                    AssetNodeService,
                    {
                        provide: HOOK_NAVIGATOR_NODES,
                        useClass: AssetNodeFactory,
                        multi: true
                    }
                ],
                entryComponents: [DeviceStatusComponent]
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { ASSET_NAVIGATOR_CONFIG, Action, AssetNode, AssetNodeFactory, AssetNodeService, AssetSelectorComponent, AssetSelectorModule, AssetSelectorNodeComponent, AssetsNavigatorModule, CONFIG_OPTIONS_DEFAULT, DeviceGroupService, DynamicGroupNode, GroupFragment, GroupNode, GroupNodeService, LoadMoreNode, MO_TYPES, MillerViewComponent, AssetSelectorBase as ɵa, AssetSelectorService as ɵb };
//# sourceMappingURL=c8y-ngx-components-assets-navigator.js.map
