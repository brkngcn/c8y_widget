import { EventEmitter, Component, ViewChild, Input, Output, NgModule } from '@angular/core';
import { TypeDeviceGridColumn, StatusDeviceGridColumn, NameDeviceGridColumn, ModelDeviceGridColumn, GroupDeviceGridColumn, RegistrationDateDeviceGridColumn, AlarmsDeviceGridColumn, DeviceGridComponent, DeviceGridModule } from '@c8y/ngx-components/device-grid';
import { FilteringActionType, CoreModule } from '@c8y/ngx-components';
import { Subject } from 'rxjs';
import { distinctUntilChanged, takeUntil } from 'rxjs/operators';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@c8y/ngx-components/device-grid';
import * as ɵngcc2 from '@c8y/ngx-components';
class DeviceSelectorComponent {
    constructor() {
        this.GRID_CONFIG_KEY = 'device-grid-bulk';
        this.typeColumn = new TypeDeviceGridColumn();
        this.onDeviceQueryStringChange = new EventEmitter();
        this.columns = [
            new StatusDeviceGridColumn(),
            new NameDeviceGridColumn(),
            this.typeColumn,
            new ModelDeviceGridColumn(),
            new GroupDeviceGridColumn(),
            new RegistrationDateDeviceGridColumn(),
            new AlarmsDeviceGridColumn()
        ];
        this.unsubscribe$ = new Subject();
    }
    ngOnInit() {
        if (this.deviceTypes) {
            this.deviceTypes
                .pipe(distinctUntilChanged(), takeUntil(this.unsubscribe$))
                .subscribe((types) => {
                this.deviceGrid.updateFiltering([this.typeColumn.name], {
                    type: types && types.length
                        ? FilteringActionType.ApplyFilter
                        : FilteringActionType.ResetFilter,
                    payload: types
                        ? {
                            filteringModifier: {
                                externalFilterQuery: {
                                    types
                                }
                            }
                        }
                        : undefined
                });
            });
        }
    }
    ngOnDestroy() {
        this.unsubscribe$.next(true);
        this.unsubscribe$.complete();
    }
}
DeviceSelectorComponent.ɵfac = function DeviceSelectorComponent_Factory(t) { return new (t || DeviceSelectorComponent)(); };
DeviceSelectorComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: DeviceSelectorComponent, selectors: [["c8y-device-selector"]], viewQuery: function DeviceSelectorComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(DeviceGridComponent, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.deviceGrid = _t.first);
    } }, inputs: { deviceTypes: "deviceTypes" }, outputs: { onDeviceQueryStringChange: "onDeviceQueryStringChange" }, decls: 2, vars: 6, consts: [[3, "title", "columnsConfigKey", "columns", "infiniteScroll", "onDeviceQueryStringChange"]], template: function DeviceSelectorComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "c8y-device-grid", 0);
        ɵngcc0.ɵɵlistener("onDeviceQueryStringChange", function DeviceSelectorComponent_Template_c8y_device_grid_onDeviceQueryStringChange_0_listener($event) { return ctx.onDeviceQueryStringChange.emit($event); });
        ɵngcc0.ɵɵpipe(1, "translate");
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("title", ɵngcc0.ɵɵpipeBind1(1, 4, "Target devices"))("columnsConfigKey", ctx.GRID_CONFIG_KEY)("columns", ctx.columns)("infiniteScroll", "auto");
    } }, directives: [ɵngcc1.DeviceGridComponent], pipes: [ɵngcc2.C8yTranslatePipe], encapsulation: 2 });
DeviceSelectorComponent.propDecorators = {
    deviceGrid: [{ type: ViewChild, args: [DeviceGridComponent, { static: true },] }],
    deviceTypes: [{ type: Input }],
    onDeviceQueryStringChange: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DeviceSelectorComponent, [{
        type: Component,
        args: [{
                selector: 'c8y-device-selector',
                template: "<c8y-device-grid\n  [title]=\"'Target devices' | translate\"\n  [columnsConfigKey]=\"GRID_CONFIG_KEY\"\n  [columns]=\"columns\"\n  [infiniteScroll]=\"'auto'\"\n  (onDeviceQueryStringChange)=\"onDeviceQueryStringChange.emit($event)\"\n></c8y-device-grid>\n"
            }]
    }], function () { return []; }, { onDeviceQueryStringChange: [{
            type: Output
        }], deviceGrid: [{
            type: ViewChild,
            args: [DeviceGridComponent, { static: true }]
        }], deviceTypes: [{
            type: Input
        }] }); })();

/**
 * This module provides a component for selecting devices based on filters.
 */
class DeviceSelectorModule {
}
DeviceSelectorModule.ɵfac = function DeviceSelectorModule_Factory(t) { return new (t || DeviceSelectorModule)(); };
DeviceSelectorModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: DeviceSelectorModule });
DeviceSelectorModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CoreModule, DeviceGridModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DeviceSelectorModule, [{
        type: NgModule,
        args: [{
                imports: [CoreModule, DeviceGridModule],
                declarations: [DeviceSelectorComponent],
                exports: [DeviceSelectorComponent]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DeviceSelectorModule, { declarations: function () { return [DeviceSelectorComponent]; }, imports: function () { return [CoreModule, DeviceGridModule]; }, exports: function () { return [DeviceSelectorComponent]; } }); })();

/**
 * Generated bundle index. Do not edit.
 */

export { DeviceSelectorComponent, DeviceSelectorModule };

//# sourceMappingURL=c8y-ngx-components-operations-device-selector.js.map