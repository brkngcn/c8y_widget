import { Injectable } from '@angular/core';
import * as i0 from "@angular/core";
import * as ɵngcc0 from '@angular/core';
export class DatapointParserService {
    constructor() {
        this.attributeToParse = [
            'target',
            'yellowRangeMin',
            'yellowRangeMax',
            'redRangeMin',
            'redRangeMax',
            'min',
            'max'
        ];
    }
    parseDatapoints(datapoints) {
        return datapoints.map(dp => this.parseDatapoint(dp));
    }
    parseDatapoint(datapoint) {
        if (!datapoint.c8y_Kpi) {
            return datapoint;
        }
        const kpi = datapoint.c8y_Kpi;
        for (const key of this.attributeToParse) {
            if (typeof kpi[key] === 'string') {
                const num = Number.parseFloat(kpi[key]);
                if (!Number.isNaN(num)) {
                    kpi[key] = num;
                }
                else {
                    delete kpi[key];
                }
            }
        }
        return datapoint;
    }
}
DatapointParserService.ɵfac = function DatapointParserService_Factory(t) { return new (t || DatapointParserService)(); };
DatapointParserService.ɵprov = i0.ɵɵdefineInjectable({ factory: function DatapointParserService_Factory() { return new DatapointParserService(); }, token: DatapointParserService, providedIn: "root" });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DatapointParserService, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return []; }, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YXBvaW50LXBhcnNlci5zZXJ2aWNlLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9kYXRhcG9pbnQtbGlicmFyeS9zZXJ2aWNlcy9kYXRhcG9pbnQtcGFyc2VyLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQzs7QUFHQSxNQUFNLE9BQU8sc0JBQXNCO0FBQ25DLElBRkE7QUFBZ0IsUUFFSyxxQkFBZ0IsR0FBRztBQUN4QyxZQUFJLFFBQVE7QUFDWixZQUFJLGdCQUFnQjtBQUNwQixZQUFJLGdCQUFnQjtBQUNwQixZQUFJLGFBQWE7QUFDakIsWUFBSSxhQUFhO0FBQ2pCLFlBQUksS0FBSztBQUNULFlBQUksS0FBSztBQUNULFNBQVksQ0FBQztBQUNiLEtBd0JDO0FBQ0QsSUF4QkUsZUFBZSxDQUFDLFVBQTRCO0FBQzlDLFFBQUksT0FBTyxVQUFVLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQ3pELElBQUUsQ0FBQztBQUNILElBQ0UsY0FBYyxDQUFDLFNBQXlCO0FBQUksUUFDMUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLEVBQUU7QUFDNUIsWUFBTSxPQUFPLFNBQVMsQ0FBQztBQUN2QixTQUFLO0FBQ0wsUUFDSSxNQUFNLEdBQUcsR0FBRyxTQUFTLENBQUMsT0FBTyxDQUFDO0FBQ2xDLFFBQUksS0FBSyxNQUFNLEdBQUcsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLEVBQUU7QUFDN0MsWUFBTSxJQUFJLE9BQU8sR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLFFBQVEsRUFBRTtBQUN4QyxnQkFBUSxNQUFNLEdBQUcsR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ2hELGdCQUFRLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFO0FBQ2hDLG9CQUFVLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUM7QUFDekIsaUJBQVM7QUFBQyxxQkFBSztBQUNmLG9CQUFVLE9BQU8sR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQzFCLGlCQUFTO0FBQ1QsYUFBTztBQUNQLFNBQUs7QUFDTCxRQUNJLE9BQU8sU0FBUyxDQUFDO0FBQ3JCLElBQUUsQ0FBQztBQUNIO3lIQUFDO0FBQ0Q7a0RBcENDLFVBQVUsU0FBQyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUU7OztnREFDN0I7QUFBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElNYW5hZ2VkT2JqZWN0IH0gZnJvbSAnQGM4eS9jbGllbnQnO1xuXG5ASW5qZWN0YWJsZSh7IHByb3ZpZGVkSW46ICdyb290JyB9KVxuZXhwb3J0IGNsYXNzIERhdGFwb2ludFBhcnNlclNlcnZpY2Uge1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgYXR0cmlidXRlVG9QYXJzZSA9IFtcbiAgICAndGFyZ2V0JyxcbiAgICAneWVsbG93UmFuZ2VNaW4nLFxuICAgICd5ZWxsb3dSYW5nZU1heCcsXG4gICAgJ3JlZFJhbmdlTWluJyxcbiAgICAncmVkUmFuZ2VNYXgnLFxuICAgICdtaW4nLFxuICAgICdtYXgnXG4gIF0gYXMgY29uc3Q7XG5cbiAgcGFyc2VEYXRhcG9pbnRzKGRhdGFwb2ludHM6IElNYW5hZ2VkT2JqZWN0W10pIHtcbiAgICByZXR1cm4gZGF0YXBvaW50cy5tYXAoZHAgPT4gdGhpcy5wYXJzZURhdGFwb2ludChkcCkpO1xuICB9XG5cbiAgcGFyc2VEYXRhcG9pbnQoZGF0YXBvaW50OiBJTWFuYWdlZE9iamVjdCk6IElNYW5hZ2VkT2JqZWN0IHtcbiAgICBpZiAoIWRhdGFwb2ludC5jOHlfS3BpKSB7XG4gICAgICByZXR1cm4gZGF0YXBvaW50O1xuICAgIH1cblxuICAgIGNvbnN0IGtwaSA9IGRhdGFwb2ludC5jOHlfS3BpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIHRoaXMuYXR0cmlidXRlVG9QYXJzZSkge1xuICAgICAgaWYgKHR5cGVvZiBrcGlba2V5XSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgbnVtID0gTnVtYmVyLnBhcnNlRmxvYXQoa3BpW2tleV0pO1xuICAgICAgICBpZiAoIU51bWJlci5pc05hTihudW0pKSB7XG4gICAgICAgICAga3BpW2tleV0gPSBudW07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGtwaVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGFwb2ludDtcbiAgfVxufVxuIl19