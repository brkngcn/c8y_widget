import { __awaiter } from "tslib";
import { Component, Input, Optional } from '@angular/core';
import { MeasurementRealtimeService } from '@c8y/ngx-components';
import { DatapointLibraryService } from '@c8y/ngx-components/datapoint-selector';
import { combineLatest, from, NEVER } from 'rxjs';
import { distinctUntilChanged, filter, map, pairwise, startWith, tap } from 'rxjs/operators';
import { ContextDashboardComponent } from '@c8y/ngx-components/context-dashboard';
var ColorClass;
(function (ColorClass) {
    ColorClass["danger"] = "text-danger";
    ColorClass["warning"] = "text-warning";
    ColorClass["unknown"] = "";
})(ColorClass || (ColorClass = {}));
export class KpiWidgetViewComponent {
    constructor(measurementRealtime, datapointLib, dashboard) {
        this.measurementRealtime = measurementRealtime;
        this.datapointLib = datapointLib;
        this.dashboard = dashboard;
        this.config = { datapoints: [] };
        this.state$ = NEVER;
        // used to differentiate between loading state and empty state
        this.noDataInitiallyInDB = false;
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            const datapoints = this.config.datapoints || [];
            const datapoint = datapoints.find(tmp => tmp.__active);
            if (!datapoint) {
                return;
            }
            this.state$ = this.setupObservable(datapoint);
        });
    }
    setupObservable(datapoint) {
        this.assignContextFromContextDashboard(datapoint);
        const latestMeasurement$ = this.getLatestMeasurement$(datapoint);
        const lastTwoValues$ = this.getLastTwoValuesOfObservable$(latestMeasurement$);
        const previousValue$ = lastTwoValues$.pipe(map(res => res[0]), startWith(undefined));
        const datapointUpdate$ = this.getDatapointLibraryEntry$(datapoint);
        const combineMeasurementAndDatapointLibEntry$ = combineLatest([
            latestMeasurement$,
            datapointUpdate$
        ]);
        const unit$ = combineMeasurementAndDatapointLibEntry$.pipe(map(([latestMeasurementValue, currentDatapoint]) => currentDatapoint.unit || latestMeasurementValue.unit || ''), startWith(''), distinctUntilChanged());
        return combineLatest([
            latestMeasurement$,
            previousValue$,
            this.getTrendOfLatestMeasurements$(lastTwoValues$),
            unit$,
            this.getColorClass$(combineMeasurementAndDatapointLibEntry$)
        ]).pipe(map(([latestMeasurement, previousValue, trend, unit, colorClass]) => {
            return {
                latestMeasurement,
                previousValue,
                trend,
                unit,
                colorClass
            };
        }));
    }
    getLatestMeasurement$(datapoint) {
        return this.measurementRealtime
            .latestValueOfSpecificMeasurement$(datapoint.fragment, datapoint.series, datapoint.__target, 
        // we only need the last two values in case we want to show a trend
        this.config.showTrend ? 2 : 1, 
        // null will be emitted in case no measurement was found initially
        true)
            .pipe(tap(measurement => {
            if (!measurement) {
                this.noDataInitiallyInDB = true;
            }
        }), filter(measurement => !!measurement), map(measurement => {
            return {
                unit: measurement[datapoint.fragment][datapoint.series].unit,
                value: measurement[datapoint.fragment][datapoint.series].value,
                date: measurement.time
            };
        }));
    }
    getDatapointLibraryEntry$(datapoint) {
        return from(this.datapointLib.updateDatapoints([datapoint], true)).pipe(map(tmp => tmp[0]), filter(tmp => !!tmp), startWith(datapoint));
    }
    getColorClass$(measurementAndDatapointCombination$) {
        return measurementAndDatapointCombination$.pipe(map(([latestMeasurementValue, currentDatapoint]) => {
            if (this.inRangeOf(currentDatapoint, latestMeasurementValue.value, 'redRangeMin', 'redRangeMax')) {
                return ColorClass.danger;
            }
            if (this.inRangeOf(currentDatapoint, latestMeasurementValue.value, 'yellowRangeMin', 'yellowRangeMax')) {
                return ColorClass.warning;
            }
            return ColorClass.unknown;
        }), startWith(ColorClass.unknown), distinctUntilChanged());
    }
    getLastTwoValuesOfObservable$(input$) {
        return input$.pipe(pairwise());
    }
    getTrendOfLatestMeasurements$(latestMeasurement$) {
        return latestMeasurement$.pipe(map(res => {
            if (res.length === 2) {
                const oldValue = res[0].value;
                const newValue = res[1].value;
                if (oldValue < newValue) {
                    return '45deg';
                }
                if (oldValue > newValue) {
                    return '135deg';
                }
            }
            return '90deg';
        }), startWith('90deg'), distinctUntilChanged());
    }
    inRangeOf(datapoint, measurementValue, minAttribute, maxAttribute) {
        if (typeof datapoint[minAttribute] === 'number' &&
            typeof datapoint[maxAttribute] === 'number') {
            if (measurementValue >= datapoint[minAttribute] &&
                measurementValue < datapoint[maxAttribute]) {
                return true;
            }
        }
        return false;
    }
    assignContextFromContextDashboard(datapoint) {
        var _a, _b;
        if (!((_a = this.dashboard) === null || _a === void 0 ? void 0 : _a.isDeviceTypeDashboard)) {
            return;
        }
        const context = (_b = this.dashboard) === null || _b === void 0 ? void 0 : _b.context;
        if (context === null || context === void 0 ? void 0 : context.id) {
            const { name, id } = context;
            datapoint.__target = { name, id };
        }
    }
}
KpiWidgetViewComponent.decorators = [
    { type: Component, args: [{
                selector: 'c8y-kpi-widget-view',
                template: "<div\n  class=\"kpi-widget__container d-flex d-col fit-h fit-w a-i-center j-c-center\"\n  *ngIf=\"state$ | async as lastState; else noMeasurementFound\"\n>\n  <div class=\"d-flex a-i-center j-c-center fit-w\">\n    <div\n      class=\"m-r-16 flex-no-shrink text-muted\"\n      [ngClass]=\"lastState.colorClass\"\n      *ngIf=\"config.icon && config.showIcon\"\n    >\n      <i class=\"icon-32\" [c8yIcon]=\"config.icon\"></i>\n    </div>\n    <div class=\"text-truncate\">\n      <span\n        class=\"text-truncate text-medium\"\n        [ngClass]=\"lastState.colorClass\"\n        [ngStyle]=\"{ 'font-size': (config.fontSize || '36') + 'px' }\"\n        title=\"{{\n          lastState.colorClass === 'text-danger'\n            ? ('Within red range:' | translate)\n            : lastState.colorClass === 'text-warning'\n            ? ('Within yellow range:' | translate)\n            : ''\n        }} {{\n          lastState.latestMeasurement.value\n            | number\n              : '1.' +\n                  (config.numberOfDecimalPlaces || '0') +\n                  '-' +\n                  (config.numberOfDecimalPlaces || '0')\n        }} {{ lastState.unit || '' }}\"\n      >\n        {{\n          lastState.latestMeasurement.value\n            | number\n              : '1.' +\n                  (config.numberOfDecimalPlaces || '0') +\n                  '-' +\n                  (config.numberOfDecimalPlaces || '0')\n        }}\n        <small class=\"text-regular\">{{ lastState.unit || '' }}</small>\n      </span>\n    </div>\n    <div\n      class=\"dot dot-info dot-30 m-l-16 flex-no-shrink\"\n      *ngIf=\"config?.showTrend && lastState.previousValue as previousValue\"\n    >\n      <i\n        class=\"icon-20\"\n        [title]=\"\n          ('Previous value' | translate) +\n          ': ' +\n          (previousValue.value\n            | number\n              : '1.' +\n                  (config.numberOfDecimalPlaces || '0') +\n                  '-' +\n                  (config.numberOfDecimalPlaces || '0')) +\n          ' (' +\n          (previousValue.date | date: 'medium') +\n          ')'\n        \"\n        c8yIcon=\"arrow-dotted-up\"\n        [ngStyle]=\"{ transform: 'rotate(' + lastState.trend + ')' }\"\n      ></i>\n    </div>\n  </div>\n  <div class=\"d-flex j-c-center\">\n    <p *ngIf=\"config?.showTimestamp\" class=\"icon-flex text-center text-muted small\">\n      <i c8yIcon=\"calendar\"></i>\n      {{ lastState.latestMeasurement.date | date: 'medium' }}\n    </p>\n  </div>\n</div>\n\n<ng-template #noMeasurementFound>\n  <div class=\"d-flex fit-h fit-w j-c-center a-i-center\">\n    <c8y-ui-empty-state\n      *ngIf=\"noDataInitiallyInDB\"\n      class=\"fit-w\"\n      [icon]=\"'line-chart'\"\n      [title]=\"'No measurement to display.' | translate\"\n      [subtitle]=\"'Waiting for measurements to be created.' | translate\"\n      [horizontal]=\"true\"\n    ></c8y-ui-empty-state>\n    <c8y-loading *ngIf=\"!noDataInitiallyInDB\"></c8y-loading>\n  </div>\n</ng-template>\n",
                providers: [MeasurementRealtimeService]
            },] }
];
KpiWidgetViewComponent.ctorParameters = () => [
    { type: MeasurementRealtimeService },
    { type: DatapointLibraryService },
    { type: ContextDashboardComponent, decorators: [{ type: Optional }] }
];
KpiWidgetViewComponent.propDecorators = {
    config: [{ type: Input }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia3BpLXdpZGdldC12aWV3LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3dpZGdldHMva3BpLXdpZGdldC9rcGktd2lkZ2V0LXZpZXcva3BpLXdpZGdldC12aWV3LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQVUsUUFBUSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ25FLE9BQU8sRUFBRSwwQkFBMEIsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ2pFLE9BQU8sRUFBRSx1QkFBdUIsRUFBYyxNQUFNLHdDQUF3QyxDQUFDO0FBQzdGLE9BQU8sRUFBRSxhQUFhLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBYyxNQUFNLE1BQU0sQ0FBQztBQUM5RCxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzdGLE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxNQUFNLHVDQUF1QyxDQUFDO0FBU2xGLElBQUssVUFJSjtBQUpELFdBQUssVUFBVTtJQUNiLG9DQUFzQixDQUFBO0lBQ3RCLHNDQUF3QixDQUFBO0lBQ3hCLDBCQUFZLENBQUE7QUFDZCxDQUFDLEVBSkksVUFBVSxLQUFWLFVBQVUsUUFJZDtBQU9ELE1BQU0sT0FBTyxzQkFBc0I7SUFhakMsWUFDVSxtQkFBK0MsRUFDL0MsWUFBcUMsRUFDekIsU0FBb0M7UUFGaEQsd0JBQW1CLEdBQW5CLG1CQUFtQixDQUE0QjtRQUMvQyxpQkFBWSxHQUFaLFlBQVksQ0FBeUI7UUFDekIsY0FBUyxHQUFULFNBQVMsQ0FBMkI7UUFmakQsV0FBTSxHQUFvQixFQUFFLFVBQVUsRUFBRSxFQUFFLEVBQUUsQ0FBQztRQUN0RCxXQUFNLEdBTUQsS0FBSyxDQUFDO1FBRVgsOERBQThEO1FBQzlELHdCQUFt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QUksQ0FBQzthQUNiO1NBQ0Y7UUFDRCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFTyxpQ0FBaUMsQ0FBQyxTQUFxQjs7UUFDN0QsSUFBSSxDQUFDLENBQUEsTUFBQSxJQUFJLENBQUMsU0FBUywwQ0FBRSxxQkFBcUIsQ0FBQSxFQUFFO1lBQzFDLE9BQU87U0FDUjtRQUNELE1BQU0sT0FBTyxHQUFHLE1BQUEsSUFBSSxDQUFDLFNBQVMsMENBQUUsT0FBTyxDQUFDO1FBQ3hDLElBQUksT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLEVBQUUsRUFBRTtZQUNmLE1BQU0sRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLEdBQUcsT0FBTyxDQUFDO1lBQzdCLFNBQVMsQ0FBQyxRQUFRLEdBQUcsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLENBQUM7U0FDbkM7SUFDSCxDQUFDOzs7WUFoTkYsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSxxQkFBcUI7Z0JBQy9CLHErRkFBK0M7Z0JBQy9DLFNBQVMsRUFBRSxDQUFDLDBCQUEwQixDQUFDO2FBQ3hDOzs7WUF2QlEsMEJBQTBCO1lBQzFCLHVCQUF1QjtZQUd2Qix5QkFBeUIsdUJBb0M3QixRQUFROzs7cUJBZlYsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE9uSW5pdCwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE1lYXN1cmVtZW50UmVhbHRpbWVTZXJ2aWNlIH0gZnJvbSAnQGM4eS9uZ3gtY29tcG9uZW50cyc7XG5pbXBvcnQgeyBEYXRhcG9pbnRMaWJyYXJ5U2VydmljZSwgS1BJRGV0YWlscyB9IGZyb20gJ0BjOHkvbmd4LWNvbXBvbmVudHMvZGF0YXBvaW50LXNlbGVjdG9yJztcbmltcG9ydCB7IGNvbWJpbmVMYXRlc3QsIGZyb20sIE5FVkVSLCBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgZmlsdGVyLCBtYXAsIHBhaXJ3aXNlLCBzdGFydFdpdGgsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IENvbnRleHREYXNoYm9hcmRDb21wb25lbnQgfSBmcm9tICdAYzh5L25neC1jb21wb25lbnRzL2NvbnRleHQtZGFzaGJvYXJkJztcbmltcG9ydCB7IEtwaVdpZGdldENvbmZpZyB9IGZyb20gJy4uL2twaS13aWRnZXQubW9kZWwnO1xuXG5pbnRlcmZhY2UgTWVhc3VyZW1lbnRWYWx1ZSB7XG4gIHVuaXQ/OiBzdHJpbmc7XG4gIHZhbHVlOiBudW1iZXI7XG4gIGRhdGU6IHN0cmluZztcbn1cblxuZW51bSBDb2xvckNsYXNzIHtcbiAgZGFuZ2VyID0gJ3RleHQtZGFuZ2VyJyxcbiAgd2FybmluZyA9ICd0ZXh0LXdhcm5pbmcnLFxuICB1bmtub3duID0gJydcbn1cblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnYzh5LWtwaS13aWRnZXQtdmlldycsXG4gIHRlbXBsYXRlVXJsOiAnLi9rcGktd2lkZ2V0LXZpZXcuY29tcG9uZW50Lmh0bWwnLFxuICBwcm92aWRlcnM6IFtNZWFzdXJlbWVudFJlYWx0aW1lU2VydmljZV1cbn0pXG5leHBvcnQgY2xhc3MgS3BpV2lkZ2V0Vmlld0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIEBJbnB1dCgpIGNvbmZpZzogS3BpV2lkZ2V0Q29uZmlnID0geyBkYXRhcG9pbnRzOiBbXSB9O1xuICBzdGF0ZSQ6IE9ic2VydmFibGU8e1xuICAgIGxhdGVzdE1lYXN1cmVtZW50OiBNZWFzdXJlbWVudFZhbHVlO1xuICAgIHByZXZpb3VzVmFsdWU6IE1lYXN1cmVtZW50VmFsdWU7XG4gICAgdHJlbmQ6IHN0cmluZztcbiAgICB1bml0OiBzdHJpbmc7XG4gICAgY29sb3JDbGFzczogQ29sb3JDbGFzcztcbiAgfT4gPSBORVZFUjtcblxuICAvLyB1c2VkIHRvIGRpZmZlcmVudGlhdGUgYmV0d2VlbiBsb2FkaW5nIHN0YXRlIGFuZCBlbXB0eSBzdGF0ZVxuICBub0RhdGFJbml0aWFsbHlJbkRCID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBtZWFzdXJlbWVudFJlYWx0aW1lOiBNZWFzdXJlbWVudFJlYWx0aW1lU2VydmljZSxcbiAgICBwcml2YXRlIGRhdGFwb2ludExpYjogRGF0YXBvaW50TGlicmFyeVNlcnZpY2UsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBkYXNoYm9hcmQ6IENvbnRleHREYXNoYm9hcmRDb21wb25lbnRcbiAgKSB7fVxuXG4gIGFzeW5jIG5nT25Jbml0KCkge1xuICAgIGNvbnN0IGRhdGFwb2ludHMgPSB0aGlzLmNvbmZpZy5kYXRhcG9pbnRzIHx8IFtdO1xuICAgIGNvbnN0IGRhdGFwb2ludDogS1BJRGV0YWlscyA9IGRhdGFwb2ludHMuZmluZCh0bXAgPT4gdG1wLl9fYWN0aXZlKTtcbiAgICBpZiAoIWRhdGFwb2ludCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUkID0gdGhpcy5zZXR1cE9ic2VydmFibGUoZGF0YXBvaW50KTtcbiAgfVxuXG4gIHNldHVwT2JzZXJ2YWJsZShkYXRhcG9pbnQ6IEtQSURldGFpbHMpOiBPYnNlcnZhYmxlPHtcbiAgICBsYXRlc3RNZWFzdXJlbWVudDogTWVhc3VyZW1lbnRWYWx1ZTtcbiAgICBwcmV2aW91c1ZhbHVlOiBhbnk7XG4gICAgdHJlbmQ6IHN0cmluZztcbiAgICB1bml0OiBzdHJpbmc7XG4gICAgY29sb3JDbGFzczogQ29sb3JDbGFzcztcbiAgfT4ge1xuICAgIHRoaXMuYXNzaWduQ29udGV4dEZyb21Db250ZXh0RGFzaGJvYXJkKGRhdGFwb2ludCk7XG4gICAgY29uc3QgbGF0ZXN0TWVhc3VyZW1lbnQkID0gdGhpcy5nZXRMYXRlc3RNZWFzdXJlbWVudCQoZGF0YXBvaW50KTtcbiAgICBjb25zdCBsYXN0VHdvVmFsdWVzJCA9IHRoaXMuZ2V0TGFzdFR3b1ZhbHVlc09mT2JzZXJ2YWJsZSQobGF0ZXN0TWVhc3VyZW1lbnQkKTtcblxuICAgIGNvbnN0IHByZXZpb3VzVmFsdWUkID0gbGFzdFR3b1ZhbHVlcyQucGlwZShcbiAgICAgIG1hcChyZXMgPT4gcmVzWzBdKSxcbiAgICAgIHN0YXJ0V2l0aCh1bmRlZmluZWQgYXMgYW55KVxuICAgICk7XG5cbiAgICBjb25zdCBkYXRhcG9pbnRVcGRhdGUkID0gdGhpcy5nZXREYXRhcG9pbnRMaWJyYXJ5RW50cnkkKGRhdGFwb2ludCk7XG5cbiAgICBjb25zdCBjb21iaW5lTWVhc3VyZW1lbnRBbmREYXRhcG9pbnRMaWJFbnRyeSQgPSBjb21iaW5lTGF0ZXN0KFtcbiAgICAgIGxhdGVzdE1lYXN1cmVtZW50JCxcbiAgICAgIGRhdGFwb2ludFVwZGF0ZSRcbiAgICBdKTtcblxuICAgIGNvbnN0IHVuaXQkID0gY29tYmluZU1lYXN1cmVtZW50QW5kRGF0YXBvaW50TGliRW50cnkkLnBpcGUoXG4gICAgICBtYXAoXG4gICAgICAgIChbbGF0ZXN0TWVhc3VyZW1lbnRWYWx1ZSwgY3VycmVudERhdGFwb2ludF0pID0+XG4gICAgICAgICAgY3VycmVudERhdGFwb2ludC51bml0IHx8IGxhdGVzdE1lYXN1cmVtZW50VmFsdWUudW5pdCB8fCAnJ1xuICAgICAgKSxcbiAgICAgIHN0YXJ0V2l0aCgnJyksXG4gICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpXG4gICAgKTtcblxuICAgIHJldHVybiBjb21iaW5lTGF0ZXN0KFtcbiAgICAgIGxhdGVzdE1lYXN1cmVtZW50JCxcbiAgICAgIHByZXZpb3VzVmFsdWUkLFxuICAgICAgdGhpcy5nZXRUcmVuZE9mTGF0ZXN0TWVhc3VyZW1lbnRzJChsYXN0VHdvVmFsdWVzJCksXG4gICAgICB1bml0JCxcbiAgICAgIHRoaXMuZ2V0Q29sb3JDbGFzcyQoY29tYmluZU1lYXN1cmVtZW50QW5kRGF0YXBvaW50TGliRW50cnkkKVxuICAgIF0pLnBpcGUoXG4gICAgICBtYXAoKFtsYXRlc3RNZWFzdXJlbWVudCwgcHJldmlvdXNWYWx1ZSwgdHJlbmQsIHVuaXQsIGNvbG9yQ2xhc3NdKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGF0ZXN0TWVhc3VyZW1lbnQsXG4gICAgICAgICAgcHJldmlvdXNWYWx1ZSxcbiAgICAgICAgICB0cmVuZCxcbiAgICAgICAgICB1bml0LFxuICAgICAgICAgIGNvbG9yQ2xhc3NcbiAgICAgICAgfTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0TGF0ZXN0TWVhc3VyZW1lbnQkKGRhdGFwb2ludDogS1BJRGV0YWlscyk6IE9ic2VydmFibGU8TWVhc3VyZW1lbnRWYWx1ZT4ge1xuICAgIHJldHVybiB0aGlzLm1lYXN1cmVtZW50UmVhbHRpbWVcbiAgICAgIC5sYXRlc3RWYWx1ZU9mU3BlY2lmaWNNZWFzdXJlbWVudCQoXG4gICAgICAgIGRhdGFwb2ludC5mcmFnbWVudCxcbiAgICAgICAgZGF0YXBvaW50LnNlcmllcyxcbiAgICAgICAgZGF0YXBvaW50Ll9fdGFyZ2V0LFxuICAgICAgICAvLyB3ZSBvbmx5IG5lZWQgdGhlIGxhc3QgdHdvIHZhbHVlcyBpbiBjYXNlIHdlIHdhbnQgdG8gc2hvdyBhIHRyZW5kXG4gICAgICAgIHRoaXMuY29uZmlnLnNob3dUcmVuZCA/IDIgOiAxLFxuICAgICAgICAvLyBudWxsIHdpbGwgYmUgZW1pdHRlZCBpbiBjYXNlIG5vIG1lYXN1cmVtZW50IHdhcyBmb3VuZCBpbml0aWFsbHlcbiAgICAgICAgdHJ1ZVxuICAgICAgKVxuICAgICAgLnBpcGUoXG4gICAgICAgIHRhcChtZWFzdXJlbWVudCA9PiB7XG4gICAgICAgICAgaWYgKCFtZWFzdXJlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5ub0RhdGFJbml0aWFsbHlJbkRCID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBmaWx0ZXIobWVhc3VyZW1lbnQgPT4gISFtZWFzdXJlbWVudCksXG4gICAgICAgIG1hcChtZWFzdXJlbWVudCA9PiB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVuaXQ6IG1lYXN1cmVtZW50W2RhdGFwb2ludC5mcmFnbWVudF1bZGF0YXBvaW50LnNlcmllc10udW5pdCxcbiAgICAgICAgICAgIHZhbHVlOiBtZWFzdXJlbWVudFtkYXRhcG9pbnQuZnJhZ21lbnRdW2RhdGFwb2ludC5zZXJpZXNdLnZhbHVlLFxuICAgICAgICAgICAgZGF0ZTogbWVhc3VyZW1lbnQudGltZSBhcyBzdHJpbmdcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0RGF0YXBvaW50TGlicmFyeUVudHJ5JChkYXRhcG9pbnQ6IEtQSURldGFpbHMpOiBPYnNlcnZhYmxlPEtQSURldGFpbHM+IHtcbiAgICByZXR1cm4gZnJvbSh0aGlzLmRhdGFwb2ludExpYi51cGRhdGVEYXRhcG9pbnRzKFtkYXRhcG9pbnRdLCB0cnVlKSkucGlwZShcbiAgICAgIG1hcCh0bXAgPT4gdG1wWzBdKSxcbiAgICAgIGZpbHRlcih0bXAgPT4gISF0bXApLFxuICAgICAgc3RhcnRXaXRoKGRhdGFwb2ludClcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRDb2xvckNsYXNzJChcbiAgICBtZWFzdXJlbWVudEFuZERhdGFwb2ludENvbWJpbmF0aW9uJDogT2JzZXJ2YWJsZTxbTWVhc3VyZW1lbnRWYWx1ZSwgS1BJRGV0YWlsc10+XG4gICk6IE9ic2VydmFibGU8Q29sb3JDbGFzcz4ge1xuICAgIHJldHVybiBtZWFzdXJlbWVudEFuZERhdGFwb2ludENvbWJpbmF0aW9uJC5waXBlKFxuICAgICAgbWFwKChbbGF0ZXN0TWVhc3VyZW1lbnRWYWx1ZSwgY3VycmVudERhdGFwb2ludF0pID0+IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMuaW5SYW5nZU9mKFxuICAgICAgICAgICAgY3VycmVudERhdGFwb2ludCxcbiAgICAgICAgICAgIGxhdGVzdE1lYXN1cmVtZW50VmFsdWUudmFsdWUsXG4gICAgICAgICAgICAncmVkUmFuZ2VNaW4nLFxuICAgICAgICAgICAgJ3JlZFJhbmdlTWF4J1xuICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIENvbG9yQ2xhc3MuZGFuZ2VyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMuaW5SYW5nZU9mKFxuICAgICAgICAgICAgY3VycmVudERhdGFwb2ludCxcbiAgICAgICAgICAgIGxhdGVzdE1lYXN1cmVtZW50VmFsdWUudmFsdWUsXG4gICAgICAgICAgICAneWVsbG93UmFuZ2VNaW4nLFxuICAgICAgICAgICAgJ3llbGxvd1JhbmdlTWF4J1xuICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIENvbG9yQ2xhc3Mud2FybmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBDb2xvckNsYXNzLnVua25vd247XG4gICAgICB9KSxcbiAgICAgIHN0YXJ0V2l0aChDb2xvckNsYXNzLnVua25vd24pLFxuICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKVxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIGdldExhc3RUd29WYWx1ZXNPZk9ic2VydmFibGUkPFQ+KGlucHV0JDogT2JzZXJ2YWJsZTxUPik6IE9ic2VydmFibGU8VFtdPiB7XG4gICAgcmV0dXJuIGlucHV0JC5waXBlKHBhaXJ3aXNlKCkpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRUcmVuZE9mTGF0ZXN0TWVhc3VyZW1lbnRzJChsYXRlc3RNZWFzdXJlbWVudCQ6IE9ic2VydmFibGU8TWVhc3VyZW1lbnRWYWx1ZVtdPikge1xuICAgIHJldHVybiBsYXRlc3RNZWFzdXJlbWVudCQucGlwZShcbiAgICAgIG1hcChyZXMgPT4ge1xuICAgICAgICBpZiAocmVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIGNvbnN0IG9sZFZhbHVlID0gcmVzWzBdLnZhbHVlO1xuICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gcmVzWzFdLnZhbHVlO1xuICAgICAgICAgIGlmIChvbGRWYWx1ZSA8IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gJzQ1ZGVnJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9sZFZhbHVlID4gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAnMTM1ZGVnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICc5MGRlZyc7XG4gICAgICB9KSxcbiAgICAgIHN0YXJ0V2l0aCgnOTBkZWcnKSxcbiAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKClcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBpblJhbmdlT2YoXG4gICAgZGF0YXBvaW50OiBLUElEZXRhaWxzLFxuICAgIG1lYXN1cmVtZW50VmFsdWU6IG51bWJlcixcbiAgICBtaW5BdHRyaWJ1dGU6IHN0cmluZyxcbiAgICBtYXhBdHRyaWJ1dGU6IHN0cmluZ1xuICApOiBib29sZWFuIHtcbiAgICBpZiAoXG4gICAgICB0eXBlb2YgZGF0YXBvaW50W21pbkF0dHJpYnV0ZV0gPT09ICdudW1iZXInICYmXG4gICAgICB0eXBlb2YgZGF0YXBvaW50W21heEF0dHJpYnV0ZV0gPT09ICdudW1iZXInXG4gICAgKSB7XG4gICAgICBpZiAoXG4gICAgICAgIG1lYXN1cmVtZW50VmFsdWUgPj0gZGF0YXBvaW50W21pbkF0dHJpYnV0ZV0gJiZcbiAgICAgICAgbWVhc3VyZW1lbnRWYWx1ZSA8IGRhdGFwb2ludFttYXhBdHRyaWJ1dGVdXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHByaXZhdGUgYXNzaWduQ29udGV4dEZyb21Db250ZXh0RGFzaGJvYXJkKGRhdGFwb2ludDogS1BJRGV0YWlscykge1xuICAgIGlmICghdGhpcy5kYXNoYm9hcmQ/LmlzRGV2aWNlVHlwZURhc2hib2FyZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5kYXNoYm9hcmQ/LmNvbnRleHQ7XG4gICAgaWYgKGNvbnRleHQ/LmlkKSB7XG4gICAgICBjb25zdCB7IG5hbWUsIGlkIH0gPSBjb250ZXh0O1xuICAgICAgZGF0YXBvaW50Ll9fdGFyZ2V0ID0geyBuYW1lLCBpZCB9O1xuICAgIH1cbiAgfVxufVxuIl19