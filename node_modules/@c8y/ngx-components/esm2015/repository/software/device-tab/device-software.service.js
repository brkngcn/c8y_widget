import { Injectable } from '@angular/core';
import { AdvancedSoftwareService } from '@c8y/ngx-components/repository/shared';
import { set } from 'lodash-es';
import { BehaviorSubject, Subject } from 'rxjs';
import { share, switchMap } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@c8y/ngx-components/repository/shared";
export class DeviceSoftwareService {
    constructor(advancedSoftwareService) {
        this.advancedSoftwareService = advancedSoftwareService;
        this.reloadSubject$ = new BehaviorSubject(null);
        this.loadingSubject$ = new Subject();
    }
    /**
     * Indicates whether device software data is currently being loaded.
     */
    get loading$() {
        return this.loadingSubject$.asObservable().pipe(share());
    }
    /**
     * Trigger device software data reload.
     */
    reload() {
        this.reloadSubject$.next();
    }
    /**
     * Retrieves the software list that is installed on a given device.
     *
     * @param deviceId ID of the device to retrieve software data for
     * @param filterCriteria Criteria that software items are filtered by.
     * @param legacySoftwareList If provided no data will be fetched from backend. The provided software list
     * will be filtered by the specified filter criteria.
     *
     * @returns The software items installed on the specified device filtered by the specified criteria.
     */
    getSoftwareList(deviceId, filterCriteria, legacySoftwareList) {
        this.loadingSubject$.next(true);
        return this.reloadSubject$.pipe(switchMap(() => {
            const softwareList$ = !!legacySoftwareList
                ? this.getLegacySoftwareList(legacySoftwareList, filterCriteria)
                : this.getAdvancedSoftwareList(deviceId, filterCriteria);
            return softwareList$.then(resultList => {
                this.loadingSubject$.next(false);
                return resultList;
            });
        }), share());
    }
    getAdvancedSoftwareList(deviceId, filterCriteria) {
        const queryFilter = {
            deviceId,
            currentPage: 1,
            pageSize: 50,
            withTotalPages: true
        };
        if (filterCriteria === null || filterCriteria === void 0 ? void 0 : filterCriteria.name) {
            set(queryFilter, 'name', `*${filterCriteria.name}*`);
        }
        if (filterCriteria === null || filterCriteria === void 0 ? void 0 : filterCriteria.softwareType) {
            set(queryFilter, 'type', `${filterCriteria.softwareType}`);
        }
        return this.advancedSoftwareService.list(queryFilter);
    }
    getLegacySoftwareList(legacySoftwareList, filterCriteria) {
        const data = filterCriteria
            ? legacySoftwareList.filter(item => {
                var _a;
                let match = true;
                if (filterCriteria === null || filterCriteria === void 0 ? void 0 : filterCriteria.name) {
                    match = match && ((_a = item.name) === null || _a === void 0 ? void 0 : _a.includes(filterCriteria.name));
                }
                if (filterCriteria === null || filterCriteria === void 0 ? void 0 : filterCriteria.softwareType) {
                    match = match && item.softwareType === filterCriteria.softwareType;
                }
                return match;
            })
            : legacySoftwareList;
        return Promise.resolve({
            data,
            res: null,
            paging: {
                totalPages: data.length
            }
        });
    }
}
DeviceSoftwareService.ɵprov = i0.ɵɵdefineInjectable({ factory: function DeviceSoftwareService_Factory() { return new DeviceSoftwareService(i0.ɵɵinject(i1.AdvancedSoftwareService)); }, token: DeviceSoftwareService, providedIn: "root" });
DeviceSoftwareService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
DeviceSoftwareService.ctorParameters = () => [
    { type: AdvancedSoftwareService }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGV2aWNlLXNvZnR3YXJlLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9yZXBvc2l0b3J5L3NvZnR3YXJlL2RldmljZS10YWIvZGV2aWNlLXNvZnR3YXJlLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUUzQyxPQUFPLEVBQ0wsdUJBQXVCLEVBR3hCLE1BQU0sdUNBQXVDLENBQUM7QUFDL0MsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLFdBQVcsQ0FBQztBQUNoQyxPQUFPLEVBQUUsZUFBZSxFQUFjLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUM1RCxPQUFPLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7QUFLbEQsTUFBTSxPQUFPLHFCQUFxQjtJQVdoQyxZQUFvQix1QkFBZ0Q7UUFBaEQsNEJBQXVCLEdBQXZCLHVCQUF1QixDQUF5QjtRQUg1RCxtQkFBYyxHQUFHLElBQUksZUFBZSxDQUFPLElBQUksQ0FBQyxDQUFDO1FBQ2pELG9CQUFlLEdBQUcsSUFBSSxPQUFPLEVBQVcsQ0FBQztJQUVzQixDQUFDO0lBVnhFOztPQUVHO0lBQ0gsSUFBSSxRQUFRO1FBQ1YsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLFlBQVksRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO0lBQzNELENBQUM7SUFPRDs7T0FFRztJQUNILE1BQU07UUFDSixJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxDQUFDO0lBQzdCLENBQUM7SUFFRDs7Ozs7Ozs7O09BU0c7SUFDSCxlQUFlLENBQ2IsUUFBUSxFQUNSLGNBQThCLEVBQzlCLGtCQUFxQztRQUVyQyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUVoQyxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUM3QixTQUFTLENBQUMsR0FBRyxFQUFFO1lBQ2IsTUFBTSxhQUFhLEdBQUcsQ0FBQyxDQUFDLGtCQUFrQjtnQkFDeEMsQ0FBQyxDQUFDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxrQkFBa0IsRUFBRSxjQUFjLENBQUM7Z0JBQ2hFLENBQUMsQ0FBQyxJQUFJLENBQUMsdUJBQXVCLENBQUMsUUFBUSxFQUFFLGNBQWMsQ0FBQyxDQUFDO1lBQzNELE9BQU8sYUFBYSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsRUFBRTtnQkFDckMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQ2pDLE9BQU8sVUFBVSxDQUFDO1lBQ3BCLENBQUMsQ0FBQyxDQUFDO1FBQ0wsQ0FBQyxDQUFDLEVBQ0YsS0FBSyxFQUFFLENBQ1IsQ0FBQztJQUNKLENBQUM7SUFFTyx1QkFBdUIsQ0FDN0IsUUFBUSxFQUNSLGNBQThCO1FBRTlCLE1BQU0sV0FBVyxHQUFHO1lBQ2xCLFFBQVE7WUFDUixXQUFXLEVBQUUsQ0FBQztZQUNkLFFBQVEsRUFBRSxFQUFFO1lBQ1osY0FBYyxFQUFFLElBQUk7U0FDckIsQ0FBQztRQUNGLElBQUksY0FBYyxhQUFkLGNBQWMsdUJBQWQsY0FBYyxDQUFFLElBQUksRUFBRTtZQUN4QixHQUFHLENBQUMsV0FBVyxFQUFFLE1BQU0sRUFBRSxJQUFJLGNBQWMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO1NBQ3REO1FBQ0QsSUFBSSxjQUFjLGFBQWQsY0FBYyx1QkFBZCxjQUFjLENBQUUsWUFBWSxFQUFFO1lBQ2hDLEdBQUcsQ0FBQyxXQUFXLEVBQUUsTUFBTSxFQUFFLEdBQUcsY0FBYyxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUM7U0FDNUQ7UUFDRCxPQUFPLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUVuRCxDQUFDO0lBQ0osQ0FBQztJQUVPLHFCQUFxQixDQUMzQixrQkFBb0MsRUFDcEMsY0FBOEI7UUFFOUIsTUFBTSxJQUFJLEdBQUcsY0FBYztZQUN6QixDQUFDLENBQUMsa0JBQWtCLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFOztnQkFDL0IsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDO2dCQUNqQixJQUFJLGNBQWMsYUFBZCxjQUFjLHVCQUFkLGNBQWMsQ0FBRSxJQUFJLEVBQUU7b0JBQ3hCLEtBQUssR0FBRyxLQUFLLEtBQUksTUFBQSxJQUFJLENBQUMsSUFBSSwwQ0FBRSxRQUFRLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFBLENBQUM7aUJBQzNEO2dCQUNELElBQUksY0FBYyxhQUFkLGNBQWMsdUJBQWQsY0FBYyxDQUFFLFlBQVksRUFBRTtvQkFDaEMsS0FBSyxHQUFHLEtBQUssSUFBSSxJQUFJLENBQUMsWUFBWSxLQUFLLGNBQWMsQ0FBQyxZQUFZLENBQUM7aUJBQ3BFO2dCQUVELE9BQU8sS0FBSyxDQUFDO1lBQ2YsQ0FBQyxDQUFDO1lBQ0osQ0FBQyxDQUFDLGtCQUFrQixDQUFDO1FBQ3ZCLE9BQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQztZQUNyQixJQUFJO1lBQ0osR0FBRyxFQUFFLElBQUk7WUFDVCxNQUFNLEVBQUU7Z0JBQ04sVUFBVSxFQUFFLElBQUksQ0FBQyxNQUFNO2FBQ0U7U0FDNUIsQ0FBQyxDQUFDO0lBQ0wsQ0FBQzs7OztZQW5HRixVQUFVLFNBQUM7Z0JBQ1YsVUFBVSxFQUFFLE1BQU07YUFDbkI7OztZQVZDLHVCQUF1QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElSZXN1bHRMaXN0LCBQYWdpbmcgfSBmcm9tICdAYzh5L2NsaWVudCc7XG5pbXBvcnQge1xuICBBZHZhbmNlZFNvZnR3YXJlU2VydmljZSxcbiAgRGV2aWNlU29mdHdhcmUsXG4gIEZpbHRlckNyaXRlcmlhXG59IGZyb20gJ0BjOHkvbmd4LWNvbXBvbmVudHMvcmVwb3NpdG9yeS9zaGFyZWQnO1xuaW1wb3J0IHsgc2V0IH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCwgT2JzZXJ2YWJsZSwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgc2hhcmUsIHN3aXRjaE1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCdcbn0pXG5leHBvcnQgY2xhc3MgRGV2aWNlU29mdHdhcmVTZXJ2aWNlIHtcbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIGRldmljZSBzb2Z0d2FyZSBkYXRhIGlzIGN1cnJlbnRseSBiZWluZyBsb2FkZWQuXG4gICAqL1xuICBnZXQgbG9hZGluZyQoKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIHRoaXMubG9hZGluZ1N1YmplY3QkLmFzT2JzZXJ2YWJsZSgpLnBpcGUoc2hhcmUoKSk7XG4gIH1cblxuICBwcml2YXRlIHJlbG9hZFN1YmplY3QkID0gbmV3IEJlaGF2aW9yU3ViamVjdDx2b2lkPihudWxsKTtcbiAgcHJpdmF0ZSBsb2FkaW5nU3ViamVjdCQgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgYWR2YW5jZWRTb2Z0d2FyZVNlcnZpY2U6IEFkdmFuY2VkU29mdHdhcmVTZXJ2aWNlKSB7fVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIGRldmljZSBzb2Z0d2FyZSBkYXRhIHJlbG9hZC5cbiAgICovXG4gIHJlbG9hZCgpIHtcbiAgICB0aGlzLnJlbG9hZFN1YmplY3QkLm5leHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIHNvZnR3YXJlIGxpc3QgdGhhdCBpcyBpbnN0YWxsZWQgb24gYSBnaXZlbiBkZXZpY2UuXG4gICAqXG4gICAqIEBwYXJhbSBkZXZpY2VJZCBJRCBvZiB0aGUgZGV2aWNlIHRvIHJldHJpZXZlIHNvZnR3YXJlIGRhdGEgZm9yXG4gICAqIEBwYXJhbSBmaWx0ZXJDcml0ZXJpYSBDcml0ZXJpYSB0aGF0IHNvZnR3YXJlIGl0ZW1zIGFyZSBmaWx0ZXJlZCBieS5cbiAgICogQHBhcmFtIGxlZ2FjeVNvZnR3YXJlTGlzdCBJZiBwcm92aWRlZCBubyBkYXRhIHdpbGwgYmUgZmV0Y2hlZCBmcm9tIGJhY2tlbmQuIFRoZSBwcm92aWRlZCBzb2Z0d2FyZSBsaXN0XG4gICAqIHdpbGwgYmUgZmlsdGVyZWQgYnkgdGhlIHNwZWNpZmllZCBmaWx0ZXIgY3JpdGVyaWEuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBzb2Z0d2FyZSBpdGVtcyBpbnN0YWxsZWQgb24gdGhlIHNwZWNpZmllZCBkZXZpY2UgZmlsdGVyZWQgYnkgdGhlIHNwZWNpZmllZCBjcml0ZXJpYS5cbiAgICovXG4gIGdldFNvZnR3YXJlTGlzdChcbiAgICBkZXZpY2VJZCxcbiAgICBmaWx0ZXJDcml0ZXJpYTogRmlsdGVyQ3JpdGVyaWEsXG4gICAgbGVnYWN5U29mdHdhcmVMaXN0PzogRGV2aWNlU29mdHdhcmVbXVxuICApOiBPYnNlcnZhYmxlPElSZXN1bHRMaXN0PERldmljZVNvZnR3YXJlPj4ge1xuICAgIHRoaXMubG9hZGluZ1N1YmplY3QkLm5leHQodHJ1ZSk7XG5cbiAgICByZXR1cm4gdGhpcy5yZWxvYWRTdWJqZWN0JC5waXBlKFxuICAgICAgc3dpdGNoTWFwKCgpID0+IHtcbiAgICAgICAgY29uc3Qgc29mdHdhcmVMaXN0JCA9ICEhbGVnYWN5U29mdHdhcmVMaXN0XG4gICAgICAgICAgPyB0aGlzLmdldExlZ2FjeVNvZnR3YXJlTGlzdChsZWdhY3lTb2Z0d2FyZUxpc3QsIGZpbHRlckNyaXRlcmlhKVxuICAgICAgICAgIDogdGhpcy5nZXRBZHZhbmNlZFNvZnR3YXJlTGlzdChkZXZpY2VJZCwgZmlsdGVyQ3JpdGVyaWEpO1xuICAgICAgICByZXR1cm4gc29mdHdhcmVMaXN0JC50aGVuKHJlc3VsdExpc3QgPT4ge1xuICAgICAgICAgIHRoaXMubG9hZGluZ1N1YmplY3QkLm5leHQoZmFsc2UpO1xuICAgICAgICAgIHJldHVybiByZXN1bHRMaXN0O1xuICAgICAgICB9KTtcbiAgICAgIH0pLFxuICAgICAgc2hhcmUoKVxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIGdldEFkdmFuY2VkU29mdHdhcmVMaXN0KFxuICAgIGRldmljZUlkLFxuICAgIGZpbHRlckNyaXRlcmlhOiBGaWx0ZXJDcml0ZXJpYVxuICApOiBQcm9taXNlPElSZXN1bHRMaXN0PERldmljZVNvZnR3YXJlPj4ge1xuICAgIGNvbnN0IHF1ZXJ5RmlsdGVyID0ge1xuICAgICAgZGV2aWNlSWQsXG4gICAgICBjdXJyZW50UGFnZTogMSxcbiAgICAgIHBhZ2VTaXplOiA1MCxcbiAgICAgIHdpdGhUb3RhbFBhZ2VzOiB0cnVlXG4gICAgfTtcbiAgICBpZiAoZmlsdGVyQ3JpdGVyaWE/Lm5hbWUpIHtcbiAgICAgIHNldChxdWVyeUZpbHRlciwgJ25hbWUnLCBgKiR7ZmlsdGVyQ3JpdGVyaWEubmFtZX0qYCk7XG4gICAgfVxuICAgIGlmIChmaWx0ZXJDcml0ZXJpYT8uc29mdHdhcmVUeXBlKSB7XG4gICAgICBzZXQocXVlcnlGaWx0ZXIsICd0eXBlJywgYCR7ZmlsdGVyQ3JpdGVyaWEuc29mdHdhcmVUeXBlfWApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hZHZhbmNlZFNvZnR3YXJlU2VydmljZS5saXN0KHF1ZXJ5RmlsdGVyKSBhcyB1bmtub3duIGFzIFByb21pc2U8XG4gICAgICBJUmVzdWx0TGlzdDxEZXZpY2VTb2Z0d2FyZT5cbiAgICA+O1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRMZWdhY3lTb2Z0d2FyZUxpc3QoXG4gICAgbGVnYWN5U29mdHdhcmVMaXN0OiBEZXZpY2VTb2Z0d2FyZVtdLFxuICAgIGZpbHRlckNyaXRlcmlhOiBGaWx0ZXJDcml0ZXJpYVxuICApOiBQcm9taXNlPElSZXN1bHRMaXN0PERldmljZVNvZnR3YXJlPj4ge1xuICAgIGNvbnN0IGRhdGEgPSBmaWx0ZXJDcml0ZXJpYVxuICAgICAgPyBsZWdhY3lTb2Z0d2FyZUxpc3QuZmlsdGVyKGl0ZW0gPT4ge1xuICAgICAgICAgIGxldCBtYXRjaCA9IHRydWU7XG4gICAgICAgICAgaWYgKGZpbHRlckNyaXRlcmlhPy5uYW1lKSB7XG4gICAgICAgICAgICBtYXRjaCA9IG1hdGNoICYmIGl0ZW0ubmFtZT8uaW5jbHVkZXMoZmlsdGVyQ3JpdGVyaWEubmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmaWx0ZXJDcml0ZXJpYT8uc29mdHdhcmVUeXBlKSB7XG4gICAgICAgICAgICBtYXRjaCA9IG1hdGNoICYmIGl0ZW0uc29mdHdhcmVUeXBlID09PSBmaWx0ZXJDcml0ZXJpYS5zb2Z0d2FyZVR5cGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICB9KVxuICAgICAgOiBsZWdhY3lTb2Z0d2FyZUxpc3Q7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICBkYXRhLFxuICAgICAgcmVzOiBudWxsLFxuICAgICAgcGFnaW5nOiB7XG4gICAgICAgIHRvdGFsUGFnZXM6IGRhdGEubGVuZ3RoXG4gICAgICB9IGFzIFBhZ2luZzxEZXZpY2VTb2Z0d2FyZT5cbiAgICB9KTtcbiAgfVxufVxuIl19