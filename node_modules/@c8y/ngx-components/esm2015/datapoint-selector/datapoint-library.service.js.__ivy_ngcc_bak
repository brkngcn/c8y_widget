import { __awaiter } from "tslib";
import { Injectable } from '@angular/core';
import { InventoryService, MeasurementService } from '@c8y/client';
import { AppStateService, ColorService, MAX_PAGE_SIZE } from '@c8y/ngx-components';
import { get, sortBy, uniq } from 'lodash-es';
import { filter } from 'rxjs/operators';
import { DATAPOINT_LIBRARY_FRAGMENT } from './datapoint-selection.model';
import * as i0 from "@angular/core";
import * as i1 from "@c8y/client/lib/src/inventory/InventoryService";
import * as i2 from "@c8y/ngx-components";
import * as i3 from "@c8y/client/lib/src/measurement/MeasurementService";
export class DatapointLibraryService {
    constructor(inventory, appState, measurements, color) {
        this.inventory = inventory;
        this.appState = appState;
        this.measurements = measurements;
        this.color = color;
        this.appState.currentUser.pipe(filter(user => !user)).subscribe(() => {
            this.cache = undefined;
        });
    }
    getAllDatapointLibraryEntriesCached(forceCacheRenew = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (forceCacheRenew) {
                this.cache = undefined;
            }
            if (!this.cache) {
                this.cache = this.getAllDatapointLibraryEntries();
            }
            return this.cache;
        });
    }
    getFirstDatapointLibraryPage() {
        return __awaiter(this, void 0, void 0, function* () {
            const filterObj = {
                currentPage: 1,
                pageSize: 50,
                fragmentType: DATAPOINT_LIBRARY_FRAGMENT,
                withTotalPages: true
            };
            return (yield this.inventory.list(filterObj));
        });
    }
    getAllDatapointLibraryItemsCached() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.cache) {
                this.cache = this.getAllDatapointLibraryEntries();
            }
            const res = yield this.cache;
            return res.map(tmp => tmp[DATAPOINT_LIBRARY_FRAGMENT]);
        });
    }
    updateDatapoints(datapoints, skipUpdatingTarget = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!Array.isArray(datapoints)) {
                return datapoints;
            }
            const currentTargetsPromise = !skipUpdatingTarget ? this.getCurrentVersionOfTargetsFromDatapoints(datapoints) : Promise.resolve([]);
            const [currentTemplates, currentTargets] = yield Promise.all([
                this.getCurrentTemplatesFromDatapoints(datapoints),
                currentTargetsPromise
            ]);
            const currentTemplateVersions = currentTemplates
                .map(tmp => this.mapDatapointLibraryEntry(tmp))
                .filter(tmp => !!tmp);
            for (const datapoint of datapoints) {
                const { fragment, series, __active, __target, color, label, __template } = datapoint;
                const foundCurrentTemplateVersion = currentTemplateVersions.find(tmp => tmp.__template === datapoint.__template);
                if (foundCurrentTemplateVersion) {
                    Object.assign(datapoint, foundCurrentTemplateVersion);
                    Object.assign(datapoint, {
                        fragment,
                        series,
                        __active,
                        __target,
                        color,
                        label,
                        __template
                    });
                }
                const foundCurrentTarget = currentTargets.find(target => target.id === (__target === null || __target === void 0 ? void 0 : __target.id));
                if (foundCurrentTarget) {
                    const { id, name } = foundCurrentTarget;
                    datapoint.__target = { id, name };
                }
            }
            return datapoints;
        });
    }
    getDatapointsOfAsset(parentReference, ignoreDatapointTemplates) {
        return __awaiter(this, void 0, void 0, function* () {
            const [kpiResponse, details] = yield Promise.all([
                (ignoreDatapointTemplates
                    ? Promise.resolve(null)
                    : this.inventory.assetKPIsList(parentReference, { pageSize: MAX_PAGE_SIZE })),
                this.inventory.getMeasurementsAndSeries(parentReference)
            ]);
            const kpis = kpiResponse && kpiResponse.data ? kpiResponse.data : [];
            const sortedDetails = sortBy(details, ['fragment', 'series']);
            return yield this.combineFragmentSeriesTuplesWithDetails(sortedDetails, parentReference, kpis);
        });
    }
    /**
     * Requests the last measurement with the given fragment and series to extract it's unit.
     * If the source attribute is provided, it will check the last measurement for this specific source.
     * @returns found unit or an empty string instead
     */
    guessUnitOfDatapoint(fragment, series, source) {
        return __awaiter(this, void 0, void 0, function* () {
            const measurementfilter = {
                valueFragmentSeries: series,
                valueFragmentType: fragment,
                pageSize: 1,
                revert: true,
                dateFrom: '1970-01-01'
            };
            if (source === null || source === void 0 ? void 0 : source.id) {
                measurementfilter.source = source === null || source === void 0 ? void 0 : source.id;
            }
            try {
                const { data: lastMeasurements } = yield this.measurements.list(measurementfilter);
                const measurement = lastMeasurements[0];
                if (measurement) {
                    const pathToUnit = `${fragment}.${series}.unit`;
                    const unit = get(measurement, pathToUnit);
                    if ((unit === null || unit === void 0 ? void 0 : unit.length) && typeof unit === 'string') {
                        return unit;
                    }
                }
            }
            catch (_a) {
                // nothing to do
            }
            return '';
        });
    }
    combineFragmentSeriesTuplesWithDetails(tuples, target, kpis) {
        return __awaiter(this, void 0, void 0, function* () {
            const datapoints = tuples.map(tuple => {
                var _a;
                const foundDatapointLibraryEntry = kpis.find(kpi => kpi[DATAPOINT_LIBRARY_FRAGMENT] &&
                    kpi[DATAPOINT_LIBRARY_FRAGMENT].fragment === tuple.fragment &&
                    kpi[DATAPOINT_LIBRARY_FRAGMENT].series === tuple.series);
                const datapoint = this.mapDatapointLibraryEntry(foundDatapointLibraryEntry) || tuple;
                if (!datapoint.label) {
                    datapoint.label = `${datapoint.fragment} â†’ ${datapoint.series}`;
                }
                if (!((_a = datapoint.unit) === null || _a === void 0 ? void 0 : _a.length)) {
                    datapoint.unit = '';
                }
                datapoint.__target = target;
                return datapoint;
            });
            yield this.assignColorToDatapoints(datapoints);
            return datapoints;
        });
    }
    assignColorToDatapoints(datapoints) {
        return __awaiter(this, void 0, void 0, function* () {
            const datapointsWithoutColor = datapoints.filter(datapoint => !datapoint.color);
            yield Promise.all(datapointsWithoutColor.map(datapoint => this.color.generateColorForDatapoint(datapoint.fragment, datapoint.series).then(color => (datapoint.color = color))));
        });
    }
    getAllDatapointLibraryEntries() {
        return __awaiter(this, void 0, void 0, function* () {
            const entries = new Array();
            const filterObj = {
                currentPage: 1,
                pageSize: MAX_PAGE_SIZE,
                fragmentType: DATAPOINT_LIBRARY_FRAGMENT
            };
            let res = yield this.inventory.list(filterObj);
            while (res.data.length) {
                entries.push(...res.data);
                if (res.data.length < res.paging.pageSize) {
                    break;
                }
                res = yield res.paging.next();
            }
            return entries;
        });
    }
    mapDatapointLibraryEntry(entry) {
        if (!entry || !entry[DATAPOINT_LIBRARY_FRAGMENT]) {
            return null;
        }
        const datapoint = entry[DATAPOINT_LIBRARY_FRAGMENT];
        datapoint.__template = entry.id;
        return datapoint;
    }
    getCurrentTemplatesFromDatapoints(datapoints) {
        return __awaiter(this, void 0, void 0, function* () {
            const datapointsWithTemplateId = datapoints.filter(dp => !!dp.__template);
            const usedTemplateIds = datapointsWithTemplateId.map(dp => dp.__template);
            return yield this.getMOsByIds(usedTemplateIds);
        });
    }
    getCurrentVersionOfTargetsFromDatapoints(datapoints) {
        return __awaiter(this, void 0, void 0, function* () {
            const datapointsWithTarget = datapoints.filter(dp => { var _a; return !!((_a = dp.__target) === null || _a === void 0 ? void 0 : _a.id); });
            const usedTargetIds = datapointsWithTarget.map(dp => dp.__target.id);
            return yield this.getMOsByIds(usedTargetIds);
        });
    }
    getMOsByIds(ids) {
        return __awaiter(this, void 0, void 0, function* () {
            const uniqManagedObjectIds = uniq(ids);
            if (!uniqManagedObjectIds.length) {
                return [];
            }
            try {
                const { data: managedObjects } = yield this.inventory.list({
                    ids: uniqManagedObjectIds.join(),
                    pageSize: MAX_PAGE_SIZE
                });
                return managedObjects;
            }
            catch (_a) {
                // Fail silently in case we are not able to talk to the inventory API.
                // Should only be reached in case of an server side error.
                // instead of failing, pretend like we didn't receive any items.
                console.warn(`Failed to get the current version of the following managedObjects: ${uniqManagedObjectIds.join()}.`);
                return [];
            }
        });
    }
}
DatapointLibraryService.Éµprov = i0.ÉµÉµdefineInjectable({ factory: function DatapointLibraryService_Factory() { return new DatapointLibraryService(i0.ÉµÉµinject(i1.InventoryService), i0.ÉµÉµinject(i2.AppStateService), i0.ÉµÉµinject(i3.MeasurementService), i0.ÉµÉµinject(i2.ColorService)); }, token: DatapointLibraryService, providedIn: "root" });
DatapointLibraryService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
DatapointLibraryService.ctorParameters = () => [
    { type: InventoryService },
    { type: AppStateService },
    { type: MeasurementService },
    { type: ColorService }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YXBvaW50LWxpYnJhcnkuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2RhdGFwb2ludC1zZWxlY3Rvci9kYXRhcG9pbnQtbGlicmFyeS5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFHTCxnQkFBZ0IsRUFFaEIsa0JBQWtCLEVBQ25CLE1BQU0sYUFBYSxDQUFDO0FBQ3JCLE9BQU8sRUFBRSxlQUFlLEVBQUUsWUFBWSxFQUFFLGFBQWEsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ25GLE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxNQUFNLFdBQVcsQ0FBQztBQUM5QyxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDeEMsT0FBTyxFQUNMLDBCQUEwQixFQUczQixNQUFNLDZCQUE2QixDQUFDOzs7OztBQUdyQyxNQUFNLE9BQU8sdUJBQXVCO0lBRWxDLFlBQ1UsU0FBMkIsRUFDM0IsUUFBeUIsRUFDekIsWUFBZ0MsRUFDaEMsS0FBbUI7UUFIbkIsY0FBUyxHQUFULFNBQVMsQ0FBa0I7UUFDM0IsYUFBUSxHQUFSLFFBQVEsQ0FBaUI7UUFDekIsaUJBQVksR0FBWixZQUFZLENBQW9CO1FBQ2hDLFVBQUssR0FBTCxLQUFLLENBQWM7UUFFM0IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFO1lBQ25FLElBQUksQ0FBQyxLQUFLLEdBQUcsU0FBUyxDQUFDO1FBQ3pCLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVLLG1DQUFtQyxDQUFDLGVBQWUsR0FBRyxLQUFLOztZQUMvRCxJQUFJLGVBQWUsRUFB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QUFzRSxvQkFBb0IsQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUM7Z0JBQ25ILE9BQU8sRUFBRSxDQUFDO2FBQ1g7UUFDSCxDQUFDO0tBQUE7Ozs7WUF6T0YsVUFBVSxTQUFDLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRTs7O1lBYmhDLGdCQUFnQjtZQUlULGVBQWU7WUFGdEIsa0JBQWtCO1lBRU0sWUFBWSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gIElJZGVudGlmaWVkLFxuICBJTWFuYWdlZE9iamVjdCxcbiAgSW52ZW50b3J5U2VydmljZSxcbiAgSVJlc3VsdExpc3QsXG4gIE1lYXN1cmVtZW50U2VydmljZVxufSBmcm9tICdAYzh5L2NsaWVudCc7XG5pbXBvcnQgeyBBcHBTdGF0ZVNlcnZpY2UsIENvbG9yU2VydmljZSwgTUFYX1BBR0VfU0laRSB9IGZyb20gJ0BjOHkvbmd4LWNvbXBvbmVudHMnO1xuaW1wb3J0IHsgZ2V0LCBzb3J0QnksIHVuaXEgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgZmlsdGVyIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHtcbiAgREFUQVBPSU5UX0xJQlJBUllfRlJBR01FTlQsXG4gIEtQSURldGFpbHMsXG4gIE1hbmFnZWRPYmplY3RLUElcbn0gZnJvbSAnLi9kYXRhcG9pbnQtc2VsZWN0aW9uLm1vZGVsJztcblxuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBEYXRhcG9pbnRMaWJyYXJ5U2VydmljZSB7XG4gIHByb3RlY3RlZCBjYWNoZTogUHJvbWlzZTxNYW5hZ2VkT2JqZWN0S1BJW10+O1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGludmVudG9yeTogSW52ZW50b3J5U2VydmljZSxcbiAgICBwcml2YXRlIGFwcFN0YXRlOiBBcHBTdGF0ZVNlcnZpY2UsXG4gICAgcHJpdmF0ZSBtZWFzdXJlbWVudHM6IE1lYXN1cmVtZW50U2VydmljZSxcbiAgICBwcml2YXRlIGNvbG9yOiBDb2xvclNlcnZpY2VcbiAgKSB7XG4gICAgdGhpcy5hcHBTdGF0ZS5jdXJyZW50VXNlci5waXBlKGZpbHRlcih1c2VyID0+ICF1c2VyKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIHRoaXMuY2FjaGUgPSB1bmRlZmluZWQ7XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBnZXRBbGxEYXRhcG9pbnRMaWJyYXJ5RW50cmllc0NhY2hlZChmb3JjZUNhY2hlUmVuZXcgPSBmYWxzZSk6IFByb21pc2U8TWFuYWdlZE9iamVjdEtQSVtdPiB7XG4gICAgaWYgKGZvcmNlQ2FjaGVSZW5ldykge1xuICAgICAgdGhpcy5jYWNoZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNhY2hlKSB7XG4gICAgICB0aGlzLmNhY2hlID0gdGhpcy5nZXRBbGxEYXRhcG9pbnRMaWJyYXJ5RW50cmllcygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jYWNoZTtcbiAgfVxuXG4gIGFzeW5jIGdldEZpcnN0RGF0YXBvaW50TGlicmFyeVBhZ2UoKTogUHJvbWlzZTxJUmVzdWx0TGlzdDxNYW5hZ2VkT2JqZWN0S1BJPj4ge1xuICAgIGNvbnN0IGZpbHRlck9iaiA9IHtcbiAgICAgIGN1cnJlbnRQYWdlOiAxLFxuICAgICAgcGFnZVNpemU6IDUwLFxuICAgICAgZnJhZ21lbnRUeXBlOiBEQVRBUE9JTlRfTElCUkFSWV9GUkFHTUVOVCxcbiAgICAgIHdpdGhUb3RhbFBhZ2VzOiB0cnVlXG4gICAgfTtcbiAgICByZXR1cm4gKGF3YWl0IHRoaXMuaW52ZW50b3J5Lmxpc3QoZmlsdGVyT2JqKSkgYXMgSVJlc3VsdExpc3Q8TWFuYWdlZE9iamVjdEtQST47XG4gIH1cblxuICBhc3luYyBnZXRBbGxEYXRhcG9pbnRMaWJyYXJ5SXRlbXNDYWNoZWQoKTogUHJvbWlzZTxLUElEZXRhaWxzW10+IHtcbiAgICBpZiAoIXRoaXMuY2FjaGUpIHtcbiAgICAgIHRoaXMuY2FjaGUgPSB0aGlzLmdldEFsbERhdGFwb2ludExpYnJhcnlFbnRyaWVzKCk7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuY2FjaGU7XG4gICAgcmV0dXJuIHJlcy5tYXAodG1wID0+IHRtcFtEQVRBUE9JTlRfTElCUkFSWV9GUkFHTUVOVF0pO1xuICB9XG5cbiAgYXN5bmMgdXBkYXRlRGF0YXBvaW50cyhkYXRhcG9pbnRzOiBLUElEZXRhaWxzW10sIHNraXBVcGRhdGluZ1RhcmdldCA9IGZhbHNlKTogUHJvbWlzZTxLUElEZXRhaWxzW10+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YXBvaW50cykpIHtcbiAgICAgIHJldHVybiBkYXRhcG9pbnRzO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50VGFyZ2V0c1Byb21pc2U6IFByb21pc2U8SU1hbmFnZWRPYmplY3RbXT4gPSAhc2tpcFVwZGF0aW5nVGFyZ2V0ID8gdGhpcy5nZXRDdXJyZW50VmVyc2lvbk9mVGFyZ2V0c0Zyb21EYXRhcG9pbnRzKGRhdGFwb2ludHMpIDogUHJvbWlzZS5yZXNvbHZlKFtdKTtcbiAgICBjb25zdCBbY3VycmVudFRlbXBsYXRlcywgY3VycmVudFRhcmdldHMgXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIHRoaXMuZ2V0Q3VycmVudFRlbXBsYXRlc0Zyb21EYXRhcG9pbnRzKGRhdGFwb2ludHMpLFxuICAgICAgY3VycmVudFRhcmdldHNQcm9taXNlXG4gICAgXSk7XG4gICAgY29uc3QgY3VycmVudFRlbXBsYXRlVmVyc2lvbnMgPSBjdXJyZW50VGVtcGxhdGVzXG4gICAgICAubWFwKHRtcCA9PiB0aGlzLm1hcERhdGFwb2ludExpYnJhcnlFbnRyeSh0bXAgYXMgTWFuYWdlZE9iamVjdEtQSSkpXG4gICAgICAuZmlsdGVyKHRtcCA9PiAhIXRtcCk7XG4gICAgZm9yIChjb25zdCBkYXRhcG9pbnQgb2YgZGF0YXBvaW50cykge1xuICAgICAgY29uc3QgeyBmcmFnbWVudCwgc2VyaWVzLCBfX2FjdGl2ZSwgX190YXJnZXQsIGNvbG9yLCBsYWJlbCwgX190ZW1wbGF0ZSB9ID0gZGF0YXBvaW50O1xuICAgICAgY29uc3QgZm91bmRDdXJyZW50VGVtcGxhdGVWZXJzaW9uID0gY3VycmVudFRlbXBsYXRlVmVyc2lvbnMuZmluZChcbiAgICAgICAgdG1wID0+IHRtcC5fX3RlbXBsYXRlID09PSBkYXRhcG9pbnQuX190ZW1wbGF0ZVxuICAgICAgKTtcbiAgICAgIGlmIChmb3VuZEN1cnJlbnRUZW1wbGF0ZVZlcnNpb24pIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihkYXRhcG9pbnQsIGZvdW5kQ3VycmVudFRlbXBsYXRlVmVyc2lvbik7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oZGF0YXBvaW50LCB7XG4gICAgICAgICAgZnJhZ21lbnQsXG4gICAgICAgICAgc2VyaWVzLFxuICAgICAgICAgIF9fYWN0aXZlLFxuICAgICAgICAgIF9fdGFyZ2V0LFxuICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgIF9fdGVtcGxhdGVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZvdW5kQ3VycmVudFRhcmdldCA9IGN1cnJlbnRUYXJnZXRzLmZpbmQodGFyZ2V0ID0+IHRhcmdldC5pZCA9PT0gX190YXJnZXQ/LmlkKTtcbiAgICAgIGlmIChmb3VuZEN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgY29uc3QgeyBpZCwgbmFtZSB9ID0gZm91bmRDdXJyZW50VGFyZ2V0O1xuICAgICAgICBkYXRhcG9pbnQuX190YXJnZXQgPSB7IGlkLCBuYW1lIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhcG9pbnRzO1xuICB9XG5cbiAgYXN5bmMgZ2V0RGF0YXBvaW50c09mQXNzZXQoXG4gICAgcGFyZW50UmVmZXJlbmNlOiBJSWRlbnRpZmllZCxcbiAgICBpZ25vcmVEYXRhcG9pbnRUZW1wbGF0ZXM/OiBib29sZWFuXG4gICk6IFByb21pc2U8S1BJRGV0YWlsc1tdPiB7XG4gICAgY29uc3QgW2twaVJlc3BvbnNlLCBkZXRhaWxzXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIChpZ25vcmVEYXRhcG9pbnRUZW1wbGF0ZXNcbiAgICAgICAgPyBQcm9taXNlLnJlc29sdmUobnVsbClcbiAgICAgICAgOiB0aGlzLmludmVudG9yeS5hc3NldEtQSXNMaXN0KHBhcmVudFJlZmVyZW5jZSwgeyBwYWdlU2l6ZTogTUFYX1BBR0VfU0laRSB9KSkgYXMgUHJvbWlzZTxcbiAgICAgICAgSVJlc3VsdExpc3Q8TWFuYWdlZE9iamVjdEtQST5cbiAgICAgID4sXG4gICAgICB0aGlzLmludmVudG9yeS5nZXRNZWFzdXJlbWVudHNBbmRTZXJpZXMocGFyZW50UmVmZXJlbmNlKVxuICAgIF0pO1xuICAgIGNvbnN0IGtwaXMgPSBrcGlSZXNwb25zZSAmJiBrcGlSZXNwb25zZS5kYXRhID8ga3BpUmVzcG9uc2UuZGF0YSA6IFtdO1xuICAgIGNvbnN0IHNvcnRlZERldGFpbHMgPSBzb3J0QnkoZGV0YWlscywgWydmcmFnbWVudCcsICdzZXJpZXMnXSk7XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5jb21iaW5lRnJhZ21lbnRTZXJpZXNUdXBsZXNXaXRoRGV0YWlscyhzb3J0ZWREZXRhaWxzLCBwYXJlbnRSZWZlcmVuY2UsIGtwaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3RzIHRoZSBsYXN0IG1lYXN1cmVtZW50IHdpdGggdGhlIGdpdmVuIGZyYWdtZW50IGFuZCBzZXJpZXMgdG8gZXh0cmFjdCBpdCdzIHVuaXQuXG4gICAqIElmIHRoZSBzb3VyY2UgYXR0cmlidXRlIGlzIHByb3ZpZGVkLCBpdCB3aWxsIGNoZWNrIHRoZSBsYXN0IG1lYXN1cmVtZW50IGZvciB0aGlzIHNwZWNpZmljIHNvdXJjZS5cbiAgICogQHJldHVybnMgZm91bmQgdW5pdCBvciBhbiBlbXB0eSBzdHJpbmcgaW5zdGVhZFxuICAgKi9cbiAgYXN5bmMgZ3Vlc3NVbml0T2ZEYXRhcG9pbnQoXG4gICAgZnJhZ21lbnQ6IHN0cmluZyxcbiAgICBzZXJpZXM6IHN0cmluZyxcbiAgICBzb3VyY2U/OiBJSWRlbnRpZmllZFxuICApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IG1lYXN1cmVtZW50ZmlsdGVyOiBhbnkgPSB7XG4gICAgICB2YWx1ZUZyYWdtZW50U2VyaWVzOiBzZXJpZXMsXG4gICAgICB2YWx1ZUZyYWdtZW50VHlwZTogZnJhZ21lbnQsXG4gICAgICBwYWdlU2l6ZTogMSxcbiAgICAgIHJldmVydDogdHJ1ZSxcbiAgICAgIGRhdGVGcm9tOiAnMTk3MC0wMS0wMSdcbiAgICB9O1xuICAgIGlmIChzb3VyY2U/LmlkKSB7XG4gICAgICBtZWFzdXJlbWVudGZpbHRlci5zb3VyY2UgPSBzb3VyY2U/LmlkO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBkYXRhOiBsYXN0TWVhc3VyZW1lbnRzIH0gPSBhd2FpdCB0aGlzLm1lYXN1cmVtZW50cy5saXN0KG1lYXN1cmVtZW50ZmlsdGVyKTtcbiAgICAgIGNvbnN0IG1lYXN1cmVtZW50ID0gbGFzdE1lYXN1cmVtZW50c1swXTtcbiAgICAgIGlmIChtZWFzdXJlbWVudCkge1xuICAgICAgICBjb25zdCBwYXRoVG9Vbml0ID0gYCR7ZnJhZ21lbnR9LiR7c2VyaWVzfS51bml0YDtcbiAgICAgICAgY29uc3QgdW5pdCA9IGdldChtZWFzdXJlbWVudCwgcGF0aFRvVW5pdCk7XG4gICAgICAgIGlmICh1bml0Py5sZW5ndGggJiYgdHlwZW9mIHVuaXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIHVuaXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIGNvbWJpbmVGcmFnbWVudFNlcmllc1R1cGxlc1dpdGhEZXRhaWxzKFxuICAgIHR1cGxlczogQXJyYXk8eyBmcmFnbWVudDogc3RyaW5nOyBzZXJpZXM6IHN0cmluZyB9PixcbiAgICB0YXJnZXQ6IElJZGVudGlmaWVkLFxuICAgIGtwaXM6IE1hbmFnZWRPYmplY3RLUElbXVxuICApIHtcbiAgICBjb25zdCBkYXRhcG9pbnRzID0gdHVwbGVzLm1hcCh0dXBsZSA9PiB7XG4gICAgICBjb25zdCBmb3VuZERhdGFwb2ludExpYnJhcnlFbnRyeSA9IGtwaXMuZmluZChcbiAgICAgICAga3BpID0+XG4gICAgICAgICAga3BpW0RBVEFQT0lOVF9MSUJSQVJZX0ZSQUdNRU5UXSAmJlxuICAgICAgICAgIGtwaVtEQVRBUE9JTlRfTElCUkFSWV9GUkFHTUVOVF0uZnJhZ21lbnQgPT09IHR1cGxlLmZyYWdtZW50ICYmXG4gICAgICAgICAga3BpW0RBVEFQT0lOVF9MSUJSQVJZX0ZSQUdNRU5UXS5zZXJpZXMgPT09IHR1cGxlLnNlcmllc1xuICAgICAgKTtcbiAgICAgIGNvbnN0IGRhdGFwb2ludDogS1BJRGV0YWlscyA9XG4gICAgICAgIHRoaXMubWFwRGF0YXBvaW50TGlicmFyeUVudHJ5KGZvdW5kRGF0YXBvaW50TGlicmFyeUVudHJ5KSB8fCB0dXBsZTtcbiAgICAgIGlmICghZGF0YXBvaW50LmxhYmVsKSB7XG4gICAgICAgIGRhdGFwb2ludC5sYWJlbCA9IGAke2RhdGFwb2ludC5mcmFnbWVudH0g4oaSICR7ZGF0YXBvaW50LnNlcmllc31gO1xuICAgICAgfVxuICAgICAgaWYgKCFkYXRhcG9pbnQudW5pdD8ubGVuZ3RoKSB7XG4gICAgICAgIGRhdGFwb2ludC51bml0ID0gJyc7XG4gICAgICB9XG4gICAgICBkYXRhcG9pbnQuX190YXJnZXQgPSB0YXJnZXQ7XG4gICAgICByZXR1cm4gZGF0YXBvaW50O1xuICAgIH0pO1xuICAgIGF3YWl0IHRoaXMuYXNzaWduQ29sb3JUb0RhdGFwb2ludHMoZGF0YXBvaW50cyk7XG4gICAgcmV0dXJuIGRhdGFwb2ludHM7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgYXNzaWduQ29sb3JUb0RhdGFwb2ludHMoZGF0YXBvaW50czogS1BJRGV0YWlsc1tdKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgZGF0YXBvaW50c1dpdGhvdXRDb2xvciA9IGRhdGFwb2ludHMuZmlsdGVyKGRhdGFwb2ludCA9PiAhZGF0YXBvaW50LmNvbG9yKTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIGRhdGFwb2ludHNXaXRob3V0Q29sb3IubWFwKGRhdGFwb2ludCA9PlxuICAgICAgICB0aGlzLmNvbG9yLmdlbmVyYXRlQ29sb3JGb3JEYXRhcG9pbnQoZGF0YXBvaW50LmZyYWdtZW50LCBkYXRhcG9pbnQuc2VyaWVzKS50aGVuKGNvbG9yID0+IChkYXRhcG9pbnQuY29sb3IgPSBjb2xvcikpXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBnZXRBbGxEYXRhcG9pbnRMaWJyYXJ5RW50cmllcygpOiBQcm9taXNlPE1hbmFnZWRPYmplY3RLUElbXT4ge1xuICAgIGNvbnN0IGVudHJpZXMgPSBuZXcgQXJyYXk8TWFuYWdlZE9iamVjdEtQST4oKTtcbiAgICBjb25zdCBmaWx0ZXJPYmogPSB7XG4gICAgICBjdXJyZW50UGFnZTogMSxcbiAgICAgIHBhZ2VTaXplOiBNQVhfUEFHRV9TSVpFLFxuICAgICAgZnJhZ21lbnRUeXBlOiBEQVRBUE9JTlRfTElCUkFSWV9GUkFHTUVOVFxuICAgIH07XG4gICAgbGV0IHJlcyA9IGF3YWl0IHRoaXMuaW52ZW50b3J5Lmxpc3QoZmlsdGVyT2JqKTtcbiAgICB3aGlsZSAocmVzLmRhdGEubGVuZ3RoKSB7XG4gICAgICBlbnRyaWVzLnB1c2goLi4uKHJlcy5kYXRhIGFzIE1hbmFnZWRPYmplY3RLUElbXSkpO1xuICAgICAgaWYgKHJlcy5kYXRhLmxlbmd0aCA8IHJlcy5wYWdpbmcucGFnZVNpemUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXMgPSBhd2FpdCByZXMucGFnaW5nLm5leHQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGVudHJpZXM7XG4gIH1cblxuICBwcm90ZWN0ZWQgbWFwRGF0YXBvaW50TGlicmFyeUVudHJ5KGVudHJ5OiBNYW5hZ2VkT2JqZWN0S1BJKTogS1BJRGV0YWlscyB7XG4gICAgaWYgKCFlbnRyeSB8fCAhZW50cnlbREFUQVBPSU5UX0xJQlJBUllfRlJBR01FTlRdKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhcG9pbnQgPSBlbnRyeVtEQVRBUE9JTlRfTElCUkFSWV9GUkFHTUVOVF07XG4gICAgZGF0YXBvaW50Ll9fdGVtcGxhdGUgPSBlbnRyeS5pZDtcbiAgICByZXR1cm4gZGF0YXBvaW50O1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIGdldEN1cnJlbnRUZW1wbGF0ZXNGcm9tRGF0YXBvaW50cyhcbiAgICBkYXRhcG9pbnRzOiBLUElEZXRhaWxzW11cbiAgKTogUHJvbWlzZTxJTWFuYWdlZE9iamVjdFtdPiB7XG4gICAgY29uc3QgZGF0YXBvaW50c1dpdGhUZW1wbGF0ZUlkID0gZGF0YXBvaW50cy5maWx0ZXIoZHAgPT4gISFkcC5fX3RlbXBsYXRlKTtcbiAgICBjb25zdCB1c2VkVGVtcGxhdGVJZHMgPSBkYXRhcG9pbnRzV2l0aFRlbXBsYXRlSWQubWFwKGRwID0+IGRwLl9fdGVtcGxhdGUpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmdldE1Pc0J5SWRzKHVzZWRUZW1wbGF0ZUlkcyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgZ2V0Q3VycmVudFZlcnNpb25PZlRhcmdldHNGcm9tRGF0YXBvaW50cyhcbiAgICBkYXRhcG9pbnRzOiBLUElEZXRhaWxzW11cbiAgKTogUHJvbWlzZTxJTWFuYWdlZE9iamVjdFtdPiB7XG4gICAgY29uc3QgZGF0YXBvaW50c1dpdGhUYXJnZXQgPSBkYXRhcG9pbnRzLmZpbHRlcihkcCA9PiAhIWRwLl9fdGFyZ2V0Py5pZCk7XG4gICAgY29uc3QgdXNlZFRhcmdldElkcyA9IGRhdGFwb2ludHNXaXRoVGFyZ2V0Lm1hcChkcCA9PiBkcC5fX3RhcmdldC5pZCk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0TU9zQnlJZHModXNlZFRhcmdldElkcyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgZ2V0TU9zQnlJZHMoaWRzOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+KTogUHJvbWlzZTxJTWFuYWdlZE9iamVjdFtdPiB7XG4gICAgY29uc3QgdW5pcU1hbmFnZWRPYmplY3RJZHMgPSB1bmlxKGlkcyk7XG4gICAgaWYgKCF1bmlxTWFuYWdlZE9iamVjdElkcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YTogbWFuYWdlZE9iamVjdHMgfSA9IGF3YWl0IHRoaXMuaW52ZW50b3J5Lmxpc3Qoe1xuICAgICAgICBpZHM6IHVuaXFNYW5hZ2VkT2JqZWN0SWRzLmpvaW4oKSxcbiAgICAgICAgcGFnZVNpemU6IE1BWF9QQUdFX1NJWkVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG1hbmFnZWRPYmplY3RzO1xuICAgIH0gY2F0Y2gge1xuICAgICAgLy8gRmFpbCBzaWxlbnRseSBpbiBjYXNlIHdlIGFyZSBub3QgYWJsZSB0byB0YWxrIHRvIHRoZSBpbnZlbnRvcnkgQVBJLlxuICAgICAgLy8gU2hvdWxkIG9ubHkgYmUgcmVhY2hlZCBpbiBjYXNlIG9mIGFuIHNlcnZlciBzaWRlIGVycm9yLlxuICAgICAgLy8gaW5zdGVhZCBvZiBmYWlsaW5nLCBwcmV0ZW5kIGxpa2Ugd2UgZGlkbid0IHJlY2VpdmUgYW55IGl0ZW1zLlxuICAgICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gZ2V0IHRoZSBjdXJyZW50IHZlcnNpb24gb2YgdGhlIGZvbGxvd2luZyBtYW5hZ2VkT2JqZWN0czogJHt1bmlxTWFuYWdlZE9iamVjdElkcy5qb2luKCl9LmApO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxufVxuIl19