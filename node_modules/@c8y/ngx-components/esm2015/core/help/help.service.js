import { Injectable } from '@angular/core';
import { TranslateService } from '@ngx-translate/core';
import { BehaviorSubject } from 'rxjs';
import { OptionsService } from '../common/options.service';
import * as i0 from "@angular/core";
import * as i1 from "@ngx-translate/core";
import * as i2 from "../common/options.service";
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@ngx-translate/core';
import * as ɵngcc2 from '../common/options.service';
export class HelpService {
    constructor(translateService, options) {
        this.translateService = translateService;
        this.options = options;
        this.contextHelp = new BehaviorSubject(false);
        this.isWarningAlertViewed = false;
        this.SUPPORTED_LANGUAGES = ['en'];
        this.handleContextHelp();
    }
    isSupportedLanguage() {
        return this.SUPPORTED_LANGUAGES.indexOf(this.translateService.currentLang) > -1;
    }
    handleContextHelp() {
        const option = this.getContextHelpOption();
        if (option) {
            this.contextHelp.next(option);
            return;
        }
        this.contextHelp.next(false);
    }
    getContextHelpOption() {
        return this.options.contextHelp;
    }
}
HelpService.ɵfac = function HelpService_Factory(t) { return new (t || HelpService)(ɵngcc0.ɵɵinject(ɵngcc1.TranslateService), ɵngcc0.ɵɵinject(ɵngcc2.OptionsService)); };
HelpService.ɵprov = i0.ɵɵdefineInjectable({ factory: function HelpService_Factory() { return new HelpService(i0.ɵɵinject(i1.TranslateService), i0.ɵɵinject(i2.OptionsService)); }, token: HelpService, providedIn: "root" });
HelpService.ctorParameters = () => [
    { type: TranslateService },
    { type: OptionsService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(HelpService, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: ɵngcc1.TranslateService }, { type: ɵngcc2.OptionsService }]; }, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGVscC5zZXJ2aWNlLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9jb3JlL2hlbHAvaGVscC5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDdkQsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUN2QyxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDM0Q7QUFFQTtBQUNnQjs7OztBQURoQixNQUFNLE9BQU8sV0FBVztBQUN4QixJQUlFLFlBQW9CLGdCQUFrQyxFQUFVLE9BQXVCO0FBQ3pGLFFBRHNCLHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBa0I7QUFBQyxRQUFTLFlBQU8sR0FBUCxPQUFPLENBQWdCO0FBQUMsUUFKL0UsZ0JBQVcsR0FBc0MsSUFBSSxlQUFlLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDdkYsUUFBRSx5QkFBb0IsR0FBWSxLQUFLLENBQUM7QUFDeEMsUUFBbUIsd0JBQW1CLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNoRCxRQUVJLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO0FBQzdCLElBQUUsQ0FBQztBQUNILElBQ0UsbUJBQW1CO0FBQUssUUFDdEIsT0FBTyxJQUFJLENBQUMsbUJBQW1CLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUNwRixJQUFFLENBQUM7QUFDSCxJQUNVLGlCQUFpQjtBQUMzQixRQUFJLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO0FBQy9DLFFBQUksSUFBSSxNQUFNLEVBQUU7QUFDaEIsWUFBTSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUNwQyxZQUFNLE9BQU87QUFDYixTQUFLO0FBQ0wsUUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNqQyxJQUFFLENBQUM7QUFDSCxJQUNVLG9CQUFvQjtBQUFLLFFBQy9CLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUM7QUFDcEMsSUFBRSxDQUFDO0FBQ0g7d0tBQUM7QUFDRCw2TkExQks7QUFBQztFQURMLFVBQVUsU0FBQyxFQUFFLHZCQUVFLFlBTlAsZ0JBQWdCO0NBSUQsRUFBRSxNQUFNLEVBQUUsWEFKTCxZQUVwQixjQUFjO0FBQUc7Ozs7a0hBQUU7QUFBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFRyYW5zbGF0ZVNlcnZpY2UgfSBmcm9tICdAbmd4LXRyYW5zbGF0ZS9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgT3B0aW9uc1NlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vb3B0aW9ucy5zZXJ2aWNlJztcblxuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBIZWxwU2VydmljZSB7XG4gIHJlYWRvbmx5IGNvbnRleHRIZWxwOiBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbiB8IHN0cmluZz4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0KGZhbHNlKTtcbiAgaXNXYXJuaW5nQWxlcnRWaWV3ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSByZWFkb25seSBTVVBQT1JURURfTEFOR1VBR0VTID0gWydlbiddO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgdHJhbnNsYXRlU2VydmljZTogVHJhbnNsYXRlU2VydmljZSwgcHJpdmF0ZSBvcHRpb25zOiBPcHRpb25zU2VydmljZSkge1xuICAgIHRoaXMuaGFuZGxlQ29udGV4dEhlbHAoKTtcbiAgfVxuXG4gIGlzU3VwcG9ydGVkTGFuZ3VhZ2UoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuU1VQUE9SVEVEX0xBTkdVQUdFUy5pbmRleE9mKHRoaXMudHJhbnNsYXRlU2VydmljZS5jdXJyZW50TGFuZykgPiAtMTtcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlQ29udGV4dEhlbHAoKSB7XG4gICAgY29uc3Qgb3B0aW9uID0gdGhpcy5nZXRDb250ZXh0SGVscE9wdGlvbigpO1xuICAgIGlmIChvcHRpb24pIHtcbiAgICAgIHRoaXMuY29udGV4dEhlbHAubmV4dChvcHRpb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNvbnRleHRIZWxwLm5leHQoZmFsc2UpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRDb250ZXh0SGVscE9wdGlvbigpOiBib29sZWFuIHwgc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmNvbnRleHRIZWxwO1xuICB9XG59XG4iXX0=