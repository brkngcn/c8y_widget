import { Component, Input, Output, ContentChildren, EventEmitter, ChangeDetectorRef, ElementRef } from '@angular/core';
import { CdkStepper, STEP_STATE } from '@angular/cdk/stepper';
import { C8yStepperIcon } from './stepper-icon.directive';
import { Subject } from 'rxjs';
import { Directionality } from '@angular/cdk/bidi';
/**
 * C8yStepper extends the CdkStepper. You can use cdk based functionality and inputs.
 * Additional to that you are able to modify the behavior and also the look and feel when
 * using the C8yStepper.
 *
 * The C8yStepper is used to present any step-based process to the user.
 * A stepper, C8yStepper and/or CdkStepper is the parent of cdk-steps.
 * Each cdk-step represents one step in the whole process that you want to provide to the user.
 *
 * The C8yStepper will create, based on the given cdk-steps, a kind of stepper-progress which looks like this:
 * (1)---(2)---(3)---(n)
 * The stepper will handle the state of each step and provides styles for active steps, done-steps or in edit-mode.
 * You are able to override icons for each step in the stepper-progress with a template. You are also able to activate
 * default-icons for states like 'edit' and 'done'.
 *
 * To force users through every provided step, set the stepper to 'linear'.
 * This will disable the possibility to move for example from step one to step three.
 *
 * Whenever it comes to validation try to use formGroups. It is possible to
 * assign a formGroup to a cdk-step input called [stepControl], which automatically respects the
 * validation-rules that you created for this formGroup. If fields are required but not filled or
 * any other validation, like a pattern, is not matched the formGroup will be invalid. In this case
 * stepping in a linear stepper to the next step gets impossible.
 *
 * If there is the need to execute asynchronous code you have at least two possibilities.
 * First: As you learned, a cdk-step works with formGroups and Validators, so you are able to use
 * asyncValidators as well.
 * Second: The C8yStepper provides an event-emitter onStepChange which is called whenever a step-button (1)--(2)--(n)
 * in the stepper-progress is clicked. The event of this emitter holds the index of the step as number. You can
 * use this EventEmitter to call for example a custom navigate-method which performs first any async-call and then moves
 * on to the given step.
 *
 * @example
 * ```
 * <c8y-stepper
 * (onStepChange)="navigate($event)"
 * [disableDefaultIcons]="{ edit: true, done: false }"
 * [customClasses]="['m-l-40', 'm-r-40', 'm-t-32']"
 * linear
 * >
 * <!-- override icons -->
 * <ng-template c8yStepperIcon="final">
 *   <span [c8yIcon]="'hand-peace-o'"></span>
 * </ng-template>
 *
 * <cdk-step [stepControl]="formGroupStepOne" label="Name of the hero">
 *   <div class="m-l-40 m-r-40 m-t-32">
 *     <h4 class="p-b-8" translate>What is the name of your hero?</h4>
 *     <c8y-form-group>
 *      <div [formGroup]="formGroupStepOne">
 *       <input
 *         class="form-control"
 *         type="text"
 *         formControlName="name"
 *         placeholder="Mister X"
 *         #nameRef
 *         required
 *       />
 *       <c8y-messages>
 *         <c8y-message *ngIf="!formGroupStepOne.untouched && !nameRef.value" translate
 *           >Enter the name of the Superhero</c8y-message
 *         >
 *       </c8y-messages>
 *      </div>
 *     </c8y-form-group>
 *   </div>
 *   <c8y-stepper-buttons></c8y-stepper-buttons>
 * </cdk-step>
 * <cdk-step>
 *  ...
 * </cdk-step state="final">
 * </c8y-stepper>
 * ```
 */
export class C8yStepper extends CdkStepper {
    /**
     * @ignore
     */
    constructor(dir, changeDetectorRef, elementRef) {
        super(dir, changeDetectorRef, elementRef, document);
        this.dir = dir;
        this.changeDetectorRef = changeDetectorRef;
        this.elementRef = elementRef;
        /**
         * Optional
         * Indicator if icons for edit and done state should be shown in step-header buttons
         */
        this.disableDefaultIcons = { edit: true, done: true };
        /**
         * Optional
         * Possibility to hide the stepper progress completely.
         */
        this.hideStepProgress = false;
        /**
         * Will emit the step index number whenever a step-header button was clicked
         * It listens to the stepIndex Subject.
         */
        this.onStepChange = new EventEmitter();
        /** Consumer-specified template-refs to be used to override the header icons. */
        this._iconOverrides = {};
        this._stepIndex = new Subject();
    }
    /**
     * @ignore
     */
    ngAfterContentInit() {
        super.ngAfterContentInit();
        this._icons.forEach(({ name, templateRef }) => (this._iconOverrides[name] = templateRef));
        this._stepIndexSubscription = this._stepIndex.subscribe(index => this.onStepChange.emit(index));
    }
    /**
     * @ignore
     */
    ngOnDestroy() {
        if (this._stepIndexSubscription && !this._stepIndexSubscription.closed) {
            this._stepIndexSubscription.unsubscribe();
        }
    }
    /**
     * Manipulates the state based on the disabledDefaultIcons Input()
     * Changing edit or done to false will change the icons within step-header buttons
     * @param index step index
     * @param state step state, like 'done', 'edit', 'error'
     */
    getIndicatorType(index, state) {
        const stepState = this._getIndicatorType(index, state);
        let _state = state;
        switch (stepState) {
            case STEP_STATE.EDIT:
                if (!this.disableDefaultIcons.edit) {
                    _state = STEP_STATE.EDIT;
                }
                break;
            case STEP_STATE.DONE:
                if (!this.disableDefaultIcons.done) {
                    _state = STEP_STATE.DONE;
                }
                else {
                    _state = '_done';
                }
                break;
        }
        return _state;
    }
    /**
     * Pushes the step index to the subject
     * @param index step index
     */
    setIndex(index) {
        var _a, _b;
        const steps = this.steps.toArray();
        if (!((_b = (_a = steps[this.selectedIndex]) === null || _a === void 0 ? void 0 : _a.stepControl) === null || _b === void 0 ? void 0 : _b.invalid) || index < this.selectedIndex) {
            this.selectedIndex = index;
        }
    }
}
C8yStepper.decorators = [
    { type: Component, args: [{
                selector: 'c8y-stepper',
                template: "<ul *ngIf=\"!hideStepProgress\" class=\"c8y-stepper\" [ngClass]=\"customClasses\">\n  <li *ngFor=\"let step of steps; let i = index\">\n    <c8y-stepper-progress\n      [iconOverrides]=\"_iconOverrides\"\n      [state]=\"getIndicatorType(i, step.state)\"\n      [index]=\"i\"\n      [selected]=\"selectedIndex === i\"\n      [disabled]=\"disableProgressButtons\"\n      (onStepClicked)=\"setIndex($event)\"\n      title=\"{{ step.label | translate }}\"\n      [ngClass]=\"{'active': selectedIndex === i}\"\n    >\n    </c8y-stepper-progress>\n    <div class=\"c8y-step__label\"  title=\"{{ step.label | translate }}\">\n      {{ step.label | translate }}\n    </div>\n  </li>\n</ul>\n<ng-container [ngTemplateOutlet]=\"selected.content\"></ng-container>\n",
                providers: [{ provide: CdkStepper, useExisting: C8yStepper }]
            },] }
];
C8yStepper.ctorParameters = () => [
    { type: Directionality },
    { type: ChangeDetectorRef },
    { type: ElementRef }
];
C8yStepper.propDecorators = {
    disableDefaultIcons: [{ type: Input }],
    disableProgressButtons: [{ type: Input }],
    customClasses: [{ type: Input }],
    hideStepProgress: [{ type: Input }],
    onStepChange: [{ type: Output }],
    _icons: [{ type: ContentChildren, args: [C8yStepperIcon, { descendants: true },] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RlcHBlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9jb3JlL3N0ZXBwZXIvc3RlcHBlci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLFNBQVMsRUFFVCxLQUFLLEVBQ0wsTUFBTSxFQUNOLGVBQWUsRUFJZixZQUFZLEVBQ1osaUJBQWlCLEVBQ2pCLFVBQVUsRUFDWCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsVUFBVSxFQUFhLFVBQVUsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQ3pFLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUMxRCxPQUFPLEVBQUUsT0FBTyxFQUFnQixNQUFNLE1BQU0sQ0FBQztBQUM3QyxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFFbkQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F5RUc7QUFNSCxNQUFNLE9BQU8sVUFBVyxTQUFRLFVBQVU7SUE4RHhDOztPQUVHO0lBQ0gsWUFDVSxHQUFtQixFQUNuQixpQkFBb0MsRUFDcEMsVUFBb0M7UUFFNUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxpQkFBaUIsRUFBRSxVQUFVLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFKNUMsUUFBRyxHQUFILEdBQUcsQ0FBZ0I7UUFDbkIsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFtQjtRQUNwQyxlQUFVLEdBQVYsVUFBVSxDQUEwQjtRQW5FOUM7OztXQUdHO1FBQ00sd0JBQW1CLEdBQXNDLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLENBQUM7UUFZN0Y7OztXQUdHO1FBQ00scUJBQWdCLEdBQWEsS0FBSyxDQUFDO1FBQzVDOzs7V0FHRztRQUNPLGlCQUFZLEdBQUcsSUFBSSxZQUFZLEVBQVUsQ0FBQztRQThCcEQsZ0ZBQWdGO1FBQ2hGLG1CQUFjLEdBQXdDLEVBQUUsQ0FBQztRQUVqRCxlQUFVLEdBQW9CLElBQUksT0FBTyxFQUFFLENBQUM7SUFZcEQsQ0FBQztJQUVEOztPQUVHO0lBQ0gsa0JBQWtCO1FBQ2hCLEtBQUssQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1FBQzNCLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDO1FBQzFGLElBQUksQ0FBQyxzQkFBc0IsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDbEcsQ0FBQztJQUVEOztPQUVHO0lBQ0gsV0FBVztRQUNULElBQUksSUFBSSxDQUFDLHNCQUFzQixJQUFJLENBQUMsSUFBSSxDQUFDLHNCQUFzQixDQUFDLE1BQU0sRUFBRTtZQUN0RSxJQUFJLENBQUMsc0JBQXNCLENBQUMsV0FBVyxFQUFFLENBQUM7U0FDM0M7SUFDSCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxnQkFBZ0IsQ0FBQyxLQUFhLEVBQUUsS0FBZ0I7UUFDOUMsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztRQUN2RCxJQUFJLE1BQU0sR0FBRyxLQUFLLENBQUM7UUFDbkIsUUFBUSxTQUFTLEVBQUU7WUFDakIsS0FBSyxVQUFVLENBQUMsSUFBSTtnQkFDbEIsSUFBSSxDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLEVBQUU7b0JBQ2xDLE1BQU0sR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDO2lCQUMxQjtnQkFDRCxNQUFNO1lBRVIsS0FBSyxVQUFVLENBQUMsSUFBSTtnQkFDbEIsSUFBSSxDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLEVBQUU7b0JBQ2xDLE1BQU0sR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDO2lCQUMxQjtxQkFBTTtvQkFDTCxNQUFNLEdBQUcsT0FBTyxDQUFDO2lCQUNsQjtnQkFDRCxNQUFNO1NBQ1Q7UUFDRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsUUFBUSxDQUFDLEtBQWE7O1FBQ3BCLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDbkMsSUFBSSxDQUFDLENBQUEsTUFBQSxNQUFBLEtBQUssQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLDBDQUFFLFdBQVcsMENBQUUsT0FBTyxDQUFBLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxhQUFhLEVBQUU7WUFDbEYsSUFBSSxDQUFDLGFBQWEsR0FBRyxLQUFLLENBQUM7U0FDNUI7SUFDSCxDQUFDOzs7WUFwSUYsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSxhQUFhO2dCQUN2QiwrdkJBQXVDO2dCQUN2QyxTQUFTLEVBQUUsQ0FBQyxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLFVBQVUsRUFBRSxDQUFDO2FBQzlEOzs7WUFoRlEsY0FBYztZQU5yQixpQkFBaUI7WUFDakIsVUFBVTs7O2tDQTJGVCxLQUFLO3FDQU1MLEtBQUs7NEJBS0wsS0FBSzsrQkFLTCxLQUFLOzJCQUtMLE1BQU07cUJBNEJOLGVBQWUsU0FBQyxjQUFjLEVBQUUsRUFBRSxXQUFXLEVBQUUsSUFBSSxFQUFFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBUZW1wbGF0ZVJlZixcbiAgSW5wdXQsXG4gIE91dHB1dCxcbiAgQ29udGVudENoaWxkcmVuLFxuICBRdWVyeUxpc3QsXG4gIEFmdGVyQ29udGVudEluaXQsXG4gIE9uRGVzdHJveSxcbiAgRXZlbnRFbWl0dGVyLFxuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgRWxlbWVudFJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENka1N0ZXBwZXIsIFN0ZXBTdGF0ZSwgU1RFUF9TVEFURSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9zdGVwcGVyJztcbmltcG9ydCB7IEM4eVN0ZXBwZXJJY29uIH0gZnJvbSAnLi9zdGVwcGVyLWljb24uZGlyZWN0aXZlJztcbmltcG9ydCB7IFN1YmplY3QsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgRGlyZWN0aW9uYWxpdHkgfSBmcm9tICdAYW5ndWxhci9jZGsvYmlkaSc7XG5cbi8qKlxuICogQzh5U3RlcHBlciBleHRlbmRzIHRoZSBDZGtTdGVwcGVyLiBZb3UgY2FuIHVzZSBjZGsgYmFzZWQgZnVuY3Rpb25hbGl0eSBhbmQgaW5wdXRzLlxuICogQWRkaXRpb25hbCB0byB0aGF0IHlvdSBhcmUgYWJsZSB0byBtb2RpZnkgdGhlIGJlaGF2aW9yIGFuZCBhbHNvIHRoZSBsb29rIGFuZCBmZWVsIHdoZW5cbiAqIHVzaW5nIHRoZSBDOHlTdGVwcGVyLlxuICpcbiAqIFRoZSBDOHlTdGVwcGVyIGlzIHVzZWQgdG8gcHJlc2VudCBhbnkgc3RlcC1iYXNlZCBwcm9jZXNzIHRvIHRoZSB1c2VyLlxuICogQSBzdGVwcGVyLCBDOHlTdGVwcGVyIGFuZC9vciBDZGtTdGVwcGVyIGlzIHRoZSBwYXJlbnQgb2YgY2RrLXN0ZXBzLlxuICogRWFjaCBjZGstc3RlcCByZXByZXNlbnRzIG9uZSBzdGVwIGluIHRoZSB3aG9sZSBwcm9jZXNzIHRoYXQgeW91IHdhbnQgdG8gcHJvdmlkZSB0byB0aGUgdXNlci5cbiAqXG4gKiBUaGUgQzh5U3RlcHBlciB3aWxsIGNyZWF0ZSwgYmFzZWQgb24gdGhlIGdpdmVuIGNkay1zdGVwcywgYSBraW5kIG9mIHN0ZXBwZXItcHJvZ3Jlc3Mgd2hpY2ggbG9va3MgbGlrZSB0aGlzOlxuICogKDEpLS0tKDIpLS0tKDMpLS0tKG4pXG4gKiBUaGUgc3RlcHBlciB3aWxsIGhhbmRsZSB0aGUgc3RhdGUgb2YgZWFjaCBzdGVwIGFuZCBwcm92aWRlcyBzdHlsZXMgZm9yIGFjdGl2ZSBzdGVwcywgZG9uZS1zdGVwcyBvciBpbiBlZGl0LW1vZGUuXG4gKiBZb3UgYXJlIGFibGUgdG8gb3ZlcnJpZGUgaWNvbnMgZm9yIGVhY2ggc3RlcCBpbiB0aGUgc3RlcHBlci1wcm9ncmVzcyB3aXRoIGEgdGVtcGxhdGUuIFlvdSBhcmUgYWxzbyBhYmxlIHRvIGFjdGl2YXRlXG4gKiBkZWZhdWx0LWljb25zIGZvciBzdGF0ZXMgbGlrZSAnZWRpdCcgYW5kICdkb25lJy5cbiAqXG4gKiBUbyBmb3JjZSB1c2VycyB0aHJvdWdoIGV2ZXJ5IHByb3ZpZGVkIHN0ZXAsIHNldCB0aGUgc3RlcHBlciB0byAnbGluZWFyJy5cbiAqIFRoaXMgd2lsbCBkaXNhYmxlIHRoZSBwb3NzaWJpbGl0eSB0byBtb3ZlIGZvciBleGFtcGxlIGZyb20gc3RlcCBvbmUgdG8gc3RlcCB0aHJlZS5cbiAqXG4gKiBXaGVuZXZlciBpdCBjb21lcyB0byB2YWxpZGF0aW9uIHRyeSB0byB1c2UgZm9ybUdyb3Vwcy4gSXQgaXMgcG9zc2libGUgdG9cbiAqIGFzc2lnbiBhIGZvcm1Hcm91cCB0byBhIGNkay1zdGVwIGlucHV0IGNhbGxlZCBbc3RlcENvbnRyb2xdLCB3aGljaCBhdXRvbWF0aWNhbGx5IHJlc3BlY3RzIHRoZVxuICogdmFsaWRhdGlvbi1ydWxlcyB0aGF0IHlvdSBjcmVhdGVkIGZvciB0aGlzIGZvcm1Hcm91cC4gSWYgZmllbGRzIGFyZSByZXF1aXJlZCBidXQgbm90IGZpbGxlZCBvclxuICogYW55IG90aGVyIHZhbGlkYXRpb24sIGxpa2UgYSBwYXR0ZXJuLCBpcyBub3QgbWF0Y2hlZCB0aGUgZm9ybUdyb3VwIHdpbGwgYmUgaW52YWxpZC4gSW4gdGhpcyBjYXNlXG4gKiBzdGVwcGluZyBpbiBhIGxpbmVhciBzdGVwcGVyIHRvIHRoZSBuZXh0IHN0ZXAgZ2V0cyBpbXBvc3NpYmxlLlxuICpcbiAqIElmIHRoZXJlIGlzIHRoZSBuZWVkIHRvIGV4ZWN1dGUgYXN5bmNocm9ub3VzIGNvZGUgeW91IGhhdmUgYXQgbGVhc3QgdHdvIHBvc3NpYmlsaXRpZXMuXG4gKiBGaXJzdDogQXMgeW91IGxlYXJuZWQsIGEgY2RrLXN0ZXAgd29ya3Mgd2l0aCBmb3JtR3JvdXBzIGFuZCBWYWxpZGF0b3JzLCBzbyB5b3UgYXJlIGFibGUgdG8gdXNlXG4gKiBhc3luY1ZhbGlkYXRvcnMgYXMgd2VsbC5cbiAqIFNlY29uZDogVGhlIEM4eVN0ZXBwZXIgcHJvdmlkZXMgYW4gZXZlbnQtZW1pdHRlciBvblN0ZXBDaGFuZ2Ugd2hpY2ggaXMgY2FsbGVkIHdoZW5ldmVyIGEgc3RlcC1idXR0b24gKDEpLS0oMiktLShuKVxuICogaW4gdGhlIHN0ZXBwZXItcHJvZ3Jlc3MgaXMgY2xpY2tlZC4gVGhlIGV2ZW50IG9mIHRoaXMgZW1pdHRlciBob2xkcyB0aGUgaW5kZXggb2YgdGhlIHN0ZXAgYXMgbnVtYmVyLiBZb3UgY2FuXG4gKiB1c2UgdGhpcyBFdmVudEVtaXR0ZXIgdG8gY2FsbCBmb3IgZXhhbXBsZSBhIGN1c3RvbSBuYXZpZ2F0ZS1tZXRob2Qgd2hpY2ggcGVyZm9ybXMgZmlyc3QgYW55IGFzeW5jLWNhbGwgYW5kIHRoZW4gbW92ZXNcbiAqIG9uIHRvIHRoZSBnaXZlbiBzdGVwLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqIDxjOHktc3RlcHBlclxuICogKG9uU3RlcENoYW5nZSk9XCJuYXZpZ2F0ZSgkZXZlbnQpXCJcbiAqIFtkaXNhYmxlRGVmYXVsdEljb25zXT1cInsgZWRpdDogdHJ1ZSwgZG9uZTogZmFsc2UgfVwiXG4gKiBbY3VzdG9tQ2xhc3Nlc109XCJbJ20tbC00MCcsICdtLXItNDAnLCAnbS10LTMyJ11cIlxuICogbGluZWFyXG4gKiA+XG4gKiA8IS0tIG92ZXJyaWRlIGljb25zIC0tPlxuICogPG5nLXRlbXBsYXRlIGM4eVN0ZXBwZXJJY29uPVwiZmluYWxcIj5cbiAqICAgPHNwYW4gW2M4eUljb25dPVwiJ2hhbmQtcGVhY2UtbydcIj48L3NwYW4+XG4gKiA8L25nLXRlbXBsYXRlPlxuICpcbiAqIDxjZGstc3RlcCBbc3RlcENvbnRyb2xdPVwiZm9ybUdyb3VwU3RlcE9uZVwiIGxhYmVsPVwiTmFtZSBvZiB0aGUgaGVyb1wiPlxuICogICA8ZGl2IGNsYXNzPVwibS1sLTQwIG0tci00MCBtLXQtMzJcIj5cbiAqICAgICA8aDQgY2xhc3M9XCJwLWItOFwiIHRyYW5zbGF0ZT5XaGF0IGlzIHRoZSBuYW1lIG9mIHlvdXIgaGVybz88L2g0PlxuICogICAgIDxjOHktZm9ybS1ncm91cD5cbiAqICAgICAgPGRpdiBbZm9ybUdyb3VwXT1cImZvcm1Hcm91cFN0ZXBPbmVcIj5cbiAqICAgICAgIDxpbnB1dFxuICogICAgICAgICBjbGFzcz1cImZvcm0tY29udHJvbFwiXG4gKiAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAqICAgICAgICAgZm9ybUNvbnRyb2xOYW1lPVwibmFtZVwiXG4gKiAgICAgICAgIHBsYWNlaG9sZGVyPVwiTWlzdGVyIFhcIlxuICogICAgICAgICAjbmFtZVJlZlxuICogICAgICAgICByZXF1aXJlZFxuICogICAgICAgLz5cbiAqICAgICAgIDxjOHktbWVzc2FnZXM+XG4gKiAgICAgICAgIDxjOHktbWVzc2FnZSAqbmdJZj1cIiFmb3JtR3JvdXBTdGVwT25lLnVudG91Y2hlZCAmJiAhbmFtZVJlZi52YWx1ZVwiIHRyYW5zbGF0ZVxuICogICAgICAgICAgID5FbnRlciB0aGUgbmFtZSBvZiB0aGUgU3VwZXJoZXJvPC9jOHktbWVzc2FnZVxuICogICAgICAgICA+XG4gKiAgICAgICA8L2M4eS1tZXNzYWdlcz5cbiAqICAgICAgPC9kaXY+XG4gKiAgICAgPC9jOHktZm9ybS1ncm91cD5cbiAqICAgPC9kaXY+XG4gKiAgIDxjOHktc3RlcHBlci1idXR0b25zPjwvYzh5LXN0ZXBwZXItYnV0dG9ucz5cbiAqIDwvY2RrLXN0ZXA+XG4gKiA8Y2RrLXN0ZXA+XG4gKiAgLi4uXG4gKiA8L2Nkay1zdGVwIHN0YXRlPVwiZmluYWxcIj5cbiAqIDwvYzh5LXN0ZXBwZXI+XG4gKiBgYGBcbiAqL1xuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnYzh5LXN0ZXBwZXInLFxuICB0ZW1wbGF0ZVVybDogJy4vc3RlcHBlci5jb21wb25lbnQuaHRtbCcsXG4gIHByb3ZpZGVyczogW3sgcHJvdmlkZTogQ2RrU3RlcHBlciwgdXNlRXhpc3Rpbmc6IEM4eVN0ZXBwZXIgfV1cbn0pXG5leHBvcnQgY2xhc3MgQzh5U3RlcHBlciBleHRlbmRzIENka1N0ZXBwZXIgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0LCBPbkRlc3Ryb3kge1xuICAvKipcbiAgICogT3B0aW9uYWxcbiAgICogSW5kaWNhdG9yIGlmIGljb25zIGZvciBlZGl0IGFuZCBkb25lIHN0YXRlIHNob3VsZCBiZSBzaG93biBpbiBzdGVwLWhlYWRlciBidXR0b25zXG4gICAqL1xuICBASW5wdXQoKSBkaXNhYmxlRGVmYXVsdEljb25zPzogeyBlZGl0OiBib29sZWFuOyBkb25lOiBib29sZWFuIH0gPSB7IGVkaXQ6IHRydWUsIGRvbmU6IHRydWUgfTtcbiAgLyoqXG4gICAqIE9wdGlvbmFsXG4gICAqIERpc2FibGUvZW5hYmxlIG5hdmlnYXRpb24gYnkgc3RlcHBlciBwcm9ncmVzcyBidXR0b25zXG4gICAqIGRlZmF1bHQ6IGZhbHNlXG4gICAqL1xuICBASW5wdXQoKSBkaXNhYmxlUHJvZ3Jlc3NCdXR0b25zOiBmYWxzZTtcbiAgLyoqXG4gICAqIE9wdGlvbmFsXG4gICAqIFBvc3NpYmlsaXR5IHRvIGFkZCBhbnkga2luZCBvZiBjdXN0b20gY3NzIGNsYXNzZXMgdG8gdGhlIHN0ZXAtaGVhZGVyXG4gICAqL1xuICBASW5wdXQoKSBjdXN0b21DbGFzc2VzPzogc3RyaW5nW107XG4gIC8qKlxuICAgKiBPcHRpb25hbFxuICAgKiBQb3NzaWJpbGl0eSB0byBoaWRlIHRoZSBzdGVwcGVyIHByb2dyZXNzIGNvbXBsZXRlbHkuXG4gICAqL1xuICBASW5wdXQoKSBoaWRlU3RlcFByb2dyZXNzPzogYm9vbGVhbiA9IGZhbHNlO1xuICAvKipcbiAgICogV2lsbCBlbWl0IHRoZSBzdGVwIGluZGV4IG51bWJlciB3aGVuZXZlciBhIHN0ZXAtaGVhZGVyIGJ1dHRvbiB3YXMgY2xpY2tlZFxuICAgKiBJdCBsaXN0ZW5zIHRvIHRoZSBzdGVwSW5kZXggU3ViamVjdC5cbiAgICovXG4gIEBPdXRwdXQoKSBvblN0ZXBDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcblxuICAvKipcbiAgICogSG9sZGluZyBhIFF1ZXJ5TGlzdCBvZiBDOHlTdGVwcGVySWNvbnNcbiAgICogVGhlc2UgYXJlIHRlbXBsYXRlUmVmcyB3aGljaCBvdmVycmlkZXMgYW55IHN0ZXAtaGVhZGVyIGJ1dHRvbiBpY29uIHdpdGggbWF0Y2hpbmcgc3RhdGUgb2YgY2RrLXN0ZXBcbiAgICpcbiAgICogQGV4YW1wbGU6XG4gICAqIGBgYFxuICAgKiA8IS0tIG92ZXJyaWRlIGljb25zIC0tPlxuICAgKiAgPG5nLXRlbXBsYXRlIGM4eVN0ZXBwZXJJY29uPVwiZmluYWxcIj5cbiAgICogICA8c3BhbiBbYzh5SWNvbl09XCInaGFuZC1wZWFjZS1vJ1wiPjwvc3Bhbj5cbiAgICogIDwvbmctdGVtcGxhdGU+XG4gICAqXG4gICAqIDxjZGstc3RlcCBzdGF0ZT1cImZpbmFsXCIgbGFiZWw9XCJKb2IgZG9uZSFcIj5cbiAgICogIDxkaXYgY2xhc3M9XCJtLWwtNDAgbS1yLTQwIG0tdC0zMlwiPlxuICAgKiAgICA8aDQgY2xhc3M9XCJwLWItMzJcIiBzdHlsZT1cInRleHQtYWxpZ246IGNlbnRlcjtcIiB0cmFuc2xhdGU+XG4gICAqICAgICBZb3VyIFN1cGVyaGVybyBpcyBub3cgcmVhZHkgdG8gc2F2ZSB0aGUgd29ybGQhXG4gICAqICAgPC9oND5cbiAgICogIDwvZGl2PlxuICAgKiAgPGM4eS1zdGVwcGVyLWJ1dHRvbnNcbiAgICogICAgW2hpZGRlbl09XCIhaXNNb2RhbFwiXG4gICAqICAgIChvbkJhY2spPVwiY2xvc2UoKVwiXG4gICAqICAgIFtsYWJlbHNdPVwieyBiYWNrOiAnR290IGl0IScgfVwiXG4gICAqICA+PC9jOHktc3RlcHBlci1idXR0b25zPlxuICAgKiAgPGM4eS1zdGVwcGVyLWJ1dHRvbnMgW2hpZGRlbl09XCJpc01vZGFsXCI+PC9jOHktc3RlcHBlci1idXR0b25zPlxuICAgKiA8L2Nkay1zdGVwPlxuICAgKiBgYGBcbiAgICovXG4gIEBDb250ZW50Q2hpbGRyZW4oQzh5U3RlcHBlckljb24sIHsgZGVzY2VuZGFudHM6IHRydWUgfSkgX2ljb25zOiBRdWVyeUxpc3Q8Qzh5U3RlcHBlckljb24+O1xuXG4gIC8qKiBDb25zdW1lci1zcGVjaWZpZWQgdGVtcGxhdGUtcmVmcyB0byBiZSB1c2VkIHRvIG92ZXJyaWRlIHRoZSBoZWFkZXIgaWNvbnMuICovXG4gIF9pY29uT3ZlcnJpZGVzOiB7IFtrZXk6IHN0cmluZ106IFRlbXBsYXRlUmVmPGFueT4gfSA9IHt9O1xuXG4gIHByaXZhdGUgX3N0ZXBJbmRleDogU3ViamVjdDxudW1iZXI+ID0gbmV3IFN1YmplY3QoKTtcbiAgcHJpdmF0ZSBfc3RlcEluZGV4U3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgZGlyOiBEaXJlY3Rpb25hbGl0eSxcbiAgICBwcml2YXRlIGNoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBwcml2YXRlIGVsZW1lbnRSZWY/OiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PlxuICApIHtcbiAgICBzdXBlcihkaXIsIGNoYW5nZURldGVjdG9yUmVmLCBlbGVtZW50UmVmLCBkb2N1bWVudCk7XG4gIH1cblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIHN1cGVyLm5nQWZ0ZXJDb250ZW50SW5pdCgpO1xuICAgIHRoaXMuX2ljb25zLmZvckVhY2goKHsgbmFtZSwgdGVtcGxhdGVSZWYgfSkgPT4gKHRoaXMuX2ljb25PdmVycmlkZXNbbmFtZV0gPSB0ZW1wbGF0ZVJlZikpO1xuICAgIHRoaXMuX3N0ZXBJbmRleFN1YnNjcmlwdGlvbiA9IHRoaXMuX3N0ZXBJbmRleC5zdWJzY3JpYmUoaW5kZXggPT4gdGhpcy5vblN0ZXBDaGFuZ2UuZW1pdChpbmRleCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG5nT25EZXN0cm95KCkge1xuICAgIGlmICh0aGlzLl9zdGVwSW5kZXhTdWJzY3JpcHRpb24gJiYgIXRoaXMuX3N0ZXBJbmRleFN1YnNjcmlwdGlvbi5jbG9zZWQpIHtcbiAgICAgIHRoaXMuX3N0ZXBJbmRleFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNYW5pcHVsYXRlcyB0aGUgc3RhdGUgYmFzZWQgb24gdGhlIGRpc2FibGVkRGVmYXVsdEljb25zIElucHV0KClcbiAgICogQ2hhbmdpbmcgZWRpdCBvciBkb25lIHRvIGZhbHNlIHdpbGwgY2hhbmdlIHRoZSBpY29ucyB3aXRoaW4gc3RlcC1oZWFkZXIgYnV0dG9uc1xuICAgKiBAcGFyYW0gaW5kZXggc3RlcCBpbmRleFxuICAgKiBAcGFyYW0gc3RhdGUgc3RlcCBzdGF0ZSwgbGlrZSAnZG9uZScsICdlZGl0JywgJ2Vycm9yJ1xuICAgKi9cbiAgZ2V0SW5kaWNhdG9yVHlwZShpbmRleDogbnVtYmVyLCBzdGF0ZTogU3RlcFN0YXRlKSB7XG4gICAgY29uc3Qgc3RlcFN0YXRlID0gdGhpcy5fZ2V0SW5kaWNhdG9yVHlwZShpbmRleCwgc3RhdGUpO1xuICAgIGxldCBfc3RhdGUgPSBzdGF0ZTtcbiAgICBzd2l0Y2ggKHN0ZXBTdGF0ZSkge1xuICAgICAgY2FzZSBTVEVQX1NUQVRFLkVESVQ6XG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlRGVmYXVsdEljb25zLmVkaXQpIHtcbiAgICAgICAgICBfc3RhdGUgPSBTVEVQX1NUQVRFLkVESVQ7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgU1RFUF9TVEFURS5ET05FOlxuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZURlZmF1bHRJY29ucy5kb25lKSB7XG4gICAgICAgICAgX3N0YXRlID0gU1RFUF9TVEFURS5ET05FO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9zdGF0ZSA9ICdfZG9uZSc7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBfc3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogUHVzaGVzIHRoZSBzdGVwIGluZGV4IHRvIHRoZSBzdWJqZWN0XG4gICAqIEBwYXJhbSBpbmRleCBzdGVwIGluZGV4XG4gICAqL1xuICBzZXRJbmRleChpbmRleDogbnVtYmVyKSB7XG4gICAgY29uc3Qgc3RlcHMgPSB0aGlzLnN0ZXBzLnRvQXJyYXkoKTtcbiAgICBpZiAoIXN0ZXBzW3RoaXMuc2VsZWN0ZWRJbmRleF0/LnN0ZXBDb250cm9sPy5pbnZhbGlkIHx8IGluZGV4IDwgdGhpcy5zZWxlY3RlZEluZGV4KSB7XG4gICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSBpbmRleDtcbiAgICB9XG4gIH1cbn1cbiJdfQ==