import { Injectable, InjectionToken, Injector } from '@angular/core';
import { Router } from '@angular/router';
import { TranslateService } from '@ngx-translate/core';
import { BehaviorSubject, Subject } from 'rxjs';
import { distinctUntilChanged, filter, map, shareReplay, take } from 'rxjs/operators';
import { fromTrigger, stateToFactory, } from '../common/extension-hooks';
import { StateService } from '../common/state-service.abstract';
import * as i0 from "@angular/core";
import * as i1 from "@angular/router";
import * as i2 from "@ngx-translate/core";
/**
 * A hook to use for Multi Provider extension.
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/router';
import * as ɵngcc2 from '@ngx-translate/core';
export const HOOK_STEPPER = new InjectionToken('HookStepper');
/**
 * A service which defines the steps in a stepper component.
 * A stepper hook needs an certain outlet which has an matching id
 * to display the steps.
 */
export class StepperService extends StateService {
    constructor(injector, router, translateService) {
        super();
        this.injector = injector;
        this.translateService = translateService;
        this.refreshTrigger = new Subject();
        this.state$ = new BehaviorSubject(new Set());
        this.factories = [];
        this.items$ = fromTrigger(router, this.refreshTrigger, [
            () => this.injector.get(HOOK_STEPPER, []),
            () => this.factories,
            stateToFactory(this.state$)
        ]).pipe(shareReplay(1), distinctUntilChanged());
    }
    sortSteps(steps) {
        return steps.sort((a, b) => {
            const priorityOrder = (b.priority || 0) - (a.priority || 0);
            const aTranslatedLabel = this.translateService.instant(a.label);
            const bTranslatedLabel = this.translateService.instant(b.label);
            const translatedLabelOrder = aTranslatedLabel.localeCompare(bTranslatedLabel);
            return priorityOrder || translatedLabelOrder;
        });
    }
    /**
     * Refresh the extension factories
     */
    refresh() {
        this.refreshTrigger.next(1);
    }
    /**
     * Returns the current state.
     * @readonly
     * @returns The current set of actions.
     */
    get state() {
        return this.state$.value;
    }
    /**
     * Adds a new item to tabs and emits state change
     * @param item The item to add.
     */
    add(item) {
        this.state.add(item);
        this.emitNewState();
    }
    /**
     * Removes a step and emits a state change.
     * @param item The item to remove.
     */
    remove(item) {
        this.state.delete(item);
        this.emitNewState();
    }
    /**
     * Returns the component by it's asssigned stepper id as an observable.
     * @param id The id of the stepper to hook into.
     */
    getById$(id) {
        return this.items$.pipe(filter((steps) => steps.length > 0), map((steps) => steps.filter((cmp) => cmp.stepperId === id)), take(1));
    }
}
StepperService.ɵfac = function StepperService_Factory(t) { return new (t || StepperService)(ɵngcc0.ɵɵinject(ɵngcc0.Injector), ɵngcc0.ɵɵinject(ɵngcc1.Router), ɵngcc0.ɵɵinject(ɵngcc2.TranslateService)); };
StepperService.ɵprov = i0.ɵɵdefineInjectable({ factory: function StepperService_Factory() { return new StepperService(i0.ɵɵinject(i0.INJECTOR), i0.ɵɵinject(i1.Router), i0.ɵɵinject(i2.TranslateService)); }, token: StepperService, providedIn: "root" });
StepperService.ctorParameters = () => [
    { type: Injector },
    { type: Router },
    { type: TranslateService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(StepperService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc0.Injector }, { type: ɵngcc1.Router }, { type: ɵngcc2.TranslateService }]; }, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RlcHBlci5zZXJ2aWNlLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9jb3JlL3N0ZXBwZXIvc3RlcHBlci5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsY0FBYyxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNyRSxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDekMsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDdkQsT0FBTyxFQUFFLGVBQWUsRUFBYyxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDNUQsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsV0FBVyxFQUFFLElBQUksRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3RGLE9BQU8sRUFHTCxXQUFXLEVBQ1gsY0FBYyxHQUNmLE1BQU0sMkJBQTJCLENBQUM7QUFDbkMsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBQ2hFO0FBQXFDO0FBR047QUFtQi9CO0FBQ0E7QUFDQSxHQUFHOzs7O0FBQ0gsTUFBTSxDQUFDLE1BQU0sWUFBWSxHQUFHLElBQUksY0FBYyxDQUFxQixhQUFhLENBQUMsQ0FBQztBQUVsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFJSCxNQUFNLE9BQU8sY0FBZSxTQUFRLFlBQVk7QUFBRyxJQU1qRCxZQUNVLFFBQWtCLEVBQzFCLE1BQWMsRUFDTixnQkFBa0M7QUFDM0MsUUFDQyxLQUFLLEVBQUUsQ0FBQztBQUNaLFFBTFksYUFBUSxHQUFSLFFBQVEsQ0FBVTtBQUFDLFFBRW5CLHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBa0I7QUFDOUMsUUFSVyxtQkFBYyxHQUFHLElBQUksT0FBTyxFQUFFLENBQUM7QUFDMUMsUUFBVyxXQUFNLEdBQUcsSUFBSSxlQUFlLENBQVksSUFBSSxHQUFHLEVBQVEsQ0FB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QUFVLFNBQUMsckJBR2tDLFlBL0NULFFBQVE7ZUE2QzNDLGZBN0MrQyxZQUN4QyxNQUFNO0dBNENILEVBQUUsTUFBTSxlQUNuQiwxQkE3Q2tCLFlBQ1YsZ0JBQWdCO0FBQUc7Ozs7OztxSUFBRTtBQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgSW5qZWN0aW9uVG9rZW4sIEluamVjdG9yIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBSb3V0ZXIgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgVHJhbnNsYXRlU2VydmljZSB9IGZyb20gJ0BuZ3gtdHJhbnNsYXRlL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgZmlsdGVyLCBtYXAsIHNoYXJlUmVwbGF5LCB0YWtlIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHtcbiAgRXh0ZW5zaW9uRmFjdG9yeSxcbiAgRXh0ZW5zaW9uUG9pbnQsXG4gIGZyb21UcmlnZ2VyLFxuICBzdGF0ZVRvRmFjdG9yeSxcbn0gZnJvbSAnLi4vY29tbW9uL2V4dGVuc2lvbi1ob29rcyc7XG5pbXBvcnQgeyBTdGF0ZVNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vc3RhdGUtc2VydmljZS5hYnN0cmFjdCc7XG5pbXBvcnQgeyBTdGVwIH0gZnJvbSAnLi9zdGVwcGVyLm1vZGVsJztcblxuLyoqXG4gKiBBbiBleHRlbnNpb24gSE9PSyBjYW4gdXNlIGVpdGhlciBhIHB1cmUgdmFsdWU6XG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAgeyBwcm92aWRlOiBIT09LX1gsIHVzZVZhbHVlOiB7IC4uLmhvb2tWYWx1ZSB9LCBtdWx0aTogdHJ1ZSB9XG4gKiBgYGBcbiAqXG4gKiBPciBhbiBhcnJheSB0byBkaXJlY3RseSByZWdpc3RlciBtdWx0aXBsZTpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqICB7IHByb3ZpZGU6IEhPT0tfWCwgdXNlVmFsdWU6IFt7IC4uLmhvb2tWYWx1ZXMgfV0sIG11bHRpOiB0cnVlIH1cbiAqIGBgYFxuICpcbiAqIE9yIGFuIEV4dGVuc2lvbkZhY3Rvcnkgd2hpY2ggYWxsb3dzIHRvIGRlZmluZSBhIGdldCgpIGZ1bmN0aW9uLiBUaGlzIGZ1bmN0aW9uXG4gKiBnZXRzIGNhbGxlZCBvbiBlYWNoIG5hdmlnYXRpb24gd2l0aCB0aGUgY3VycmVudCByb3V0ZSBhbmQgY2FuIHJldHVybiB2YWx1ZXNcbiAqIGFzeW5jIChvYnNlcnZhYmxlIG9yIHByb21pc2UpLlxuICogYGBgdHlwZXNjcmlwdFxuICogIHsgcHJvdmlkZTogSE9PS19YLCB1c2VGYWN0b3J5OiB7IGdldDogKHJvdXRlKSA9PiBkb1NvbWV0aGluZ0FzeW5jKHJvdXRlKSB9LCBtdWx0aTogdHJ1ZSB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IHR5cGUgU3RlcHBlckV4dGVuc2lvbiA9IFN0ZXAgfCBTdGVwW10gfCBFeHRlbnNpb25GYWN0b3J5PFN0ZXA+O1xuXG4vKipcbiAqIEEgaG9vayB0byB1c2UgZm9yIE11bHRpIFByb3ZpZGVyIGV4dGVuc2lvbi5cbiAqL1xuZXhwb3J0IGNvbnN0IEhPT0tfU1RFUFBFUiA9IG5ldyBJbmplY3Rpb25Ub2tlbjxTdGVwcGVyRXh0ZW5zaW9uW10+KCdIb29rU3RlcHBlcicpO1xuXG4vKipcbiAqIEEgc2VydmljZSB3aGljaCBkZWZpbmVzIHRoZSBzdGVwcyBpbiBhIHN0ZXBwZXIgY29tcG9uZW50LlxuICogQSBzdGVwcGVyIGhvb2sgbmVlZHMgYW4gY2VydGFpbiBvdXRsZXQgd2hpY2ggaGFzIGFuIG1hdGNoaW5nIGlkXG4gKiB0byBkaXNwbGF5IHRoZSBzdGVwcy5cbiAqL1xuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCcsXG59KVxuZXhwb3J0IGNsYXNzIFN0ZXBwZXJTZXJ2aWNlIGV4dGVuZHMgU3RhdGVTZXJ2aWNlIGltcGxlbWVudHMgRXh0ZW5zaW9uUG9pbnQ8U3RlcHBlckV4dGVuc2lvbj4ge1xuICBpdGVtcyQ6IE9ic2VydmFibGU8U3RlcFtdPjtcbiAgcmVhZG9ubHkgcmVmcmVzaFRyaWdnZXIgPSBuZXcgU3ViamVjdCgpO1xuICByZWFkb25seSBzdGF0ZSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFNldDxTdGVwPj4obmV3IFNldDxTdGVwPigpKTtcbiAgZmFjdG9yaWVzOiBTdGVwcGVyRXh0ZW5zaW9uW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGluamVjdG9yOiBJbmplY3RvcixcbiAgICByb3V0ZXI6IFJvdXRlcixcbiAgICBwcml2YXRlIHRyYW5zbGF0ZVNlcnZpY2U6IFRyYW5zbGF0ZVNlcnZpY2VcbiAgKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLml0ZW1zJCA9IGZyb21UcmlnZ2VyKHJvdXRlciwgdGhpcy5yZWZyZXNoVHJpZ2dlciwgW1xuICAgICAgKCkgPT4gdGhpcy5pbmplY3Rvci5nZXQoSE9PS19TVEVQUEVSLCBbXSksXG4gICAgICAoKSA9PiB0aGlzLmZhY3RvcmllcyxcbiAgICAgIHN0YXRlVG9GYWN0b3J5KHRoaXMuc3RhdGUkKVxuICAgIF0pLnBpcGUoXG4gICAgICBzaGFyZVJlcGxheSgxKSxcbiAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKClcbiAgICApIGFzIE9ic2VydmFibGU8U3RlcFtdPjtcbiAgfVxuXG4gIHNvcnRTdGVwcyhzdGVwczogU3RlcFtdKSB7XG4gICAgcmV0dXJuIHN0ZXBzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IHByaW9yaXR5T3JkZXIgPSAoYi5wcmlvcml0eSB8fCAwKSAtIChhLnByaW9yaXR5IHx8IDApO1xuXG4gICAgICBjb25zdCBhVHJhbnNsYXRlZExhYmVsID0gdGhpcy50cmFuc2xhdGVTZXJ2aWNlLmluc3RhbnQoYS5sYWJlbCk7XG4gICAgICBjb25zdCBiVHJhbnNsYXRlZExhYmVsID0gdGhpcy50cmFuc2xhdGVTZXJ2aWNlLmluc3RhbnQoYi5sYWJlbCk7XG4gICAgICBjb25zdCB0cmFuc2xhdGVkTGFiZWxPcmRlciA9IGFUcmFuc2xhdGVkTGFiZWwubG9jYWxlQ29tcGFyZShiVHJhbnNsYXRlZExhYmVsKTtcblxuICAgICAgcmV0dXJuIHByaW9yaXR5T3JkZXIgfHwgdHJhbnNsYXRlZExhYmVsT3JkZXI7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVmcmVzaCB0aGUgZXh0ZW5zaW9uIGZhY3Rvcmllc1xuICAgKi9cbiAgcmVmcmVzaCgpIHtcbiAgICB0aGlzLnJlZnJlc2hUcmlnZ2VyLm5leHQoMSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICogQHJlYWRvbmx5XG4gICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IHNldCBvZiBhY3Rpb25zLlxuICAgKi9cbiAgZ2V0IHN0YXRlKCk6IFNldDxTdGVwPiB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUkLnZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBuZXcgaXRlbSB0byB0YWJzIGFuZCBlbWl0cyBzdGF0ZSBjaGFuZ2VcbiAgICogQHBhcmFtIGl0ZW0gVGhlIGl0ZW0gdG8gYWRkLlxuICAgKi9cbiAgYWRkKGl0ZW06IFN0ZXApIHtcbiAgICB0aGlzLnN0YXRlLmFkZChpdGVtKTtcbiAgICB0aGlzLmVtaXROZXdTdGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBzdGVwIGFuZCBlbWl0cyBhIHN0YXRlIGNoYW5nZS5cbiAgICogQHBhcmFtIGl0ZW0gVGhlIGl0ZW0gdG8gcmVtb3ZlLlxuICAgKi9cbiAgcmVtb3ZlKGl0ZW06IFN0ZXApIHtcbiAgICB0aGlzLnN0YXRlLmRlbGV0ZShpdGVtKTtcbiAgICB0aGlzLmVtaXROZXdTdGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvbXBvbmVudCBieSBpdCdzIGFzc3NpZ25lZCBzdGVwcGVyIGlkIGFzIGFuIG9ic2VydmFibGUuXG4gICAqIEBwYXJhbSBpZCBUaGUgaWQgb2YgdGhlIHN0ZXBwZXIgdG8gaG9vayBpbnRvLlxuICAgKi9cbiAgZ2V0QnlJZCQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtcyQucGlwZShcbiAgICAgIGZpbHRlcigoc3RlcHMpID0+IHN0ZXBzLmxlbmd0aCA+IDApLFxuICAgICAgbWFwKChzdGVwcykgPT4gc3RlcHMuZmlsdGVyKChjbXApID0+IGNtcC5zdGVwcGVySWQgPT09IGlkKSksXG4gICAgICB0YWtlKDEpXG4gICAgKTtcbiAgfVxufVxuIl19