import { Component, Input, Output, ContentChildren, EventEmitter, ChangeDetectorRef, ElementRef } from '@angular/core';
import { CdkStepper, STEP_STATE } from '@angular/cdk/stepper';
import { C8yStepperIcon } from './stepper-icon.directive';
import { Subject } from 'rxjs';
import { Directionality } from '@angular/cdk/bidi';
/**
 * C8yStepper extends the CdkStepper. You can use cdk based functionality and inputs.
 * Additional to that you are able to modify the behavior and also the look and feel when
 * using the C8yStepper.
 *
 * The C8yStepper is used to present any step-based process to the user.
 * A stepper, C8yStepper and/or CdkStepper is the parent of cdk-steps.
 * Each cdk-step represents one step in the whole process that you want to provide to the user.
 *
 * The C8yStepper will create, based on the given cdk-steps, a kind of stepper-progress which looks like this:
 * (1)---(2)---(3)---(n)
 * The stepper will handle the state of each step and provides styles for active steps, done-steps or in edit-mode.
 * You are able to override icons for each step in the stepper-progress with a template. You are also able to activate
 * default-icons for states like 'edit' and 'done'.
 *
 * To force users through every provided step, set the stepper to 'linear'.
 * This will disable the possibility to move for example from step one to step three.
 *
 * Whenever it comes to validation try to use formGroups. It is possible to
 * assign a formGroup to a cdk-step input called [stepControl], which automatically respects the
 * validation-rules that you created for this formGroup. If fields are required but not filled or
 * any other validation, like a pattern, is not matched the formGroup will be invalid. In this case
 * stepping in a linear stepper to the next step gets impossible.
 *
 * If there is the need to execute asynchronous code you have at least two possibilities.
 * First: As you learned, a cdk-step works with formGroups and Validators, so you are able to use
 * asyncValidators as well.
 * Second: The C8yStepper provides an event-emitter onStepChange which is called whenever a step-button (1)--(2)--(n)
 * in the stepper-progress is clicked. The event of this emitter holds the index of the step as number. You can
 * use this EventEmitter to call for example a custom navigate-method which performs first any async-call and then moves
 * on to the given step.
 *
 * @example
 * ```
 * <c8y-stepper
 * (onStepChange)="navigate($event)"
 * [disableDefaultIcons]="{ edit: true, done: false }"
 * [customClasses]="['m-l-40', 'm-r-40', 'm-t-32']"
 * linear
 * >
 * <!-- override icons -->
 * <ng-template c8yStepperIcon="final">
 *   <span [c8yIcon]="'hand-peace-o'"></span>
 * </ng-template>
 *
 * <cdk-step [stepControl]="formGroupStepOne" label="Name of the hero">
 *   <div class="m-l-40 m-r-40 m-t-32">
 *     <h4 class="p-b-8" translate>What is the name of your hero?</h4>
 *     <c8y-form-group>
 *      <div [formGroup]="formGroupStepOne">
 *       <input
 *         class="form-control"
 *         type="text"
 *         formControlName="name"
 *         placeholder="Mister X"
 *         #nameRef
 *         required
 *       />
 *       <c8y-messages>
 *         <c8y-message *ngIf="!formGroupStepOne.untouched && !nameRef.value" translate
 *           >Enter the name of the Superhero</c8y-message
 *         >
 *       </c8y-messages>
 *      </div>
 *     </c8y-form-group>
 *   </div>
 *   <c8y-stepper-buttons></c8y-stepper-buttons>
 * </cdk-step>
 * <cdk-step>
 *  ...
 * </cdk-step state="final">
 * </c8y-stepper>
 * ```
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/cdk/bidi';
import * as ɵngcc2 from '@angular/common';
import * as ɵngcc3 from './stepper-progress.component';
import * as ɵngcc4 from '../i18n/c8y-translate.pipe';

const _c0 = function (a0) { return { "active": a0 }; };
function C8yStepper_ul_0_li_1_Template(rf, ctx) { if (rf & 1) {
    const _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li");
    ɵngcc0.ɵɵelementStart(1, "c8y-stepper-progress", 4);
    ɵngcc0.ɵɵlistener("onStepClicked", function C8yStepper_ul_0_li_1_Template_c8y_stepper_progress_onStepClicked_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); const ctx_r4 = ɵngcc0.ɵɵnextContext(2); return ctx_r4.setIndex($event); });
    ɵngcc0.ɵɵpipe(2, "translate");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "div", 5);
    ɵngcc0.ɵɵpipe(4, "translate");
    ɵngcc0.ɵɵtext(5);
    ɵngcc0.ɵɵpipe(6, "translate");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const step_r2 = ctx.$implicit;
    const i_r3 = ctx.index;
    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵpropertyInterpolate("title", ɵngcc0.ɵɵpipeBind1(2, 9, step_r2.label));
    ɵngcc0.ɵɵproperty("iconOverrides", ctx_r1._iconOverrides)("state", ctx_r1.getIndicatorType(i_r3, step_r2.state))("index", i_r3)("selected", ctx_r1.selectedIndex === i_r3)("disabled", ctx_r1.disableProgressButtons)("ngClass", ɵngcc0.ɵɵpureFunction1(15, _c0, ctx_r1.selectedIndex === i_r3));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵpropertyInterpolate("title", ɵngcc0.ɵɵpipeBind1(4, 11, step_r2.label));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", ɵngcc0.ɵɵpipeBind1(6, 13, step_r2.label), " ");
} }
function C8yStepper_ul_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "ul", 2);
    ɵngcc0.ɵɵtemplate(1, C8yStepper_ul_0_li_1_Template, 7, 17, "li", 3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r0.customClasses);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r0.steps);
} }
export class C8yStepper extends CdkStepper {
    /**
     * @ignore
     */
    constructor(dir, changeDetectorRef, elementRef) {
        super(dir, changeDetectorRef, elementRef, document);
        this.dir = dir;
        this.changeDetectorRef = changeDetectorRef;
        this.elementRef = elementRef;
        /**
         * Optional
         * Indicator if icons for edit and done state should be shown in step-header buttons
         */
        this.disableDefaultIcons = { edit: true, done: true };
        /**
         * Optional
         * Possibility to hide the stepper progress completely.
         */
        this.hideStepProgress = false;
        /**
         * Will emit the step index number whenever a step-header button was clicked
         * It listens to the stepIndex Subject.
         */
        this.onStepChange = new EventEmitter();
        /** Consumer-specified template-refs to be used to override the header icons. */
        this._iconOverrides = {};
        this._stepIndex = new Subject();
    }
    /**
     * @ignore
     */
    ngAfterContentInit() {
        super.ngAfterContentInit();
        this._icons.forEach(({ name, templateRef }) => (this._iconOverrides[name] = templateRef));
        this._stepIndexSubscription = this._stepIndex.subscribe(index => this.onStepChange.emit(index));
    }
    /**
     * @ignore
     */
    ngOnDestroy() {
        if (this._stepIndexSubscription && !this._stepIndexSubscription.closed) {
            this._stepIndexSubscription.unsubscribe();
        }
    }
    /**
     * Manipulates the state based on the disabledDefaultIcons Input()
     * Changing edit or done to false will change the icons within step-header buttons
     * @param index step index
     * @param state step state, like 'done', 'edit', 'error'
     */
    getIndicatorType(index, state) {
        const stepState = this._getIndicatorType(index, state);
        let _state = state;
        switch (stepState) {
            case STEP_STATE.EDIT:
                if (!this.disableDefaultIcons.edit) {
                    _state = STEP_STATE.EDIT;
                }
                break;
            case STEP_STATE.DONE:
                if (!this.disableDefaultIcons.done) {
                    _state = STEP_STATE.DONE;
                }
                else {
                    _state = '_done';
                }
                break;
        }
        return _state;
    }
    /**
     * Pushes the step index to the subject
     * @param index step index
     */
    setIndex(index) {
        var _a, _b;
        const steps = this.steps.toArray();
        if (!((_b = (_a = steps[this.selectedIndex]) === null || _a === void 0 ? void 0 : _a.stepControl) === null || _b === void 0 ? void 0 : _b.invalid) || index < this.selectedIndex) {
            this.selectedIndex = index;
        }
    }
}
C8yStepper.ɵfac = function C8yStepper_Factory(t) { return new (t || C8yStepper)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Directionality), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
C8yStepper.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: C8yStepper, selectors: [["c8y-stepper"]], contentQueries: function C8yStepper_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, C8yStepperIcon, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._icons = _t);
    } }, inputs: { disableDefaultIcons: "disableDefaultIcons", hideStepProgress: "hideStepProgress", disableProgressButtons: "disableProgressButtons", customClasses: "customClasses" }, outputs: { onStepChange: "onStepChange" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: CdkStepper, useExisting: C8yStepper }]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 2, vars: 2, consts: [["class", "c8y-stepper", 3, "ngClass", 4, "ngIf"], [3, "ngTemplateOutlet"], [1, "c8y-stepper", 3, "ngClass"], [4, "ngFor", "ngForOf"], [3, "iconOverrides", "state", "index", "selected", "disabled", "title", "ngClass", "onStepClicked"], [1, "c8y-step__label", 3, "title"]], template: function C8yStepper_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, C8yStepper_ul_0_Template, 2, 2, "ul", 0);
        ɵngcc0.ɵɵelementContainer(1, 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.hideStepProgress);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.selected.content);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet, ɵngcc2.NgClass, ɵngcc2.NgForOf, ɵngcc3.C8yStepperProgress], pipes: [ɵngcc4.C8yTranslatePipe], encapsulation: 2 });
C8yStepper.ctorParameters = () => [
    { type: Directionality },
    { type: ChangeDetectorRef },
    { type: ElementRef }
];
C8yStepper.propDecorators = {
    disableDefaultIcons: [{ type: Input }],
    disableProgressButtons: [{ type: Input }],
    customClasses: [{ type: Input }],
    hideStepProgress: [{ type: Input }],
    onStepChange: [{ type: Output }],
    _icons: [{ type: ContentChildren, args: [C8yStepperIcon, { descendants: true },] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(C8yStepper, [{
        type: Component,
        args: [{
                selector: 'c8y-stepper',
                template: "<ul *ngIf=\"!hideStepProgress\" class=\"c8y-stepper\" [ngClass]=\"customClasses\">\n  <li *ngFor=\"let step of steps; let i = index\">\n    <c8y-stepper-progress\n      [iconOverrides]=\"_iconOverrides\"\n      [state]=\"getIndicatorType(i, step.state)\"\n      [index]=\"i\"\n      [selected]=\"selectedIndex === i\"\n      [disabled]=\"disableProgressButtons\"\n      (onStepClicked)=\"setIndex($event)\"\n      title=\"{{ step.label | translate }}\"\n      [ngClass]=\"{'active': selectedIndex === i}\"\n    >\n    </c8y-stepper-progress>\n    <div class=\"c8y-step__label\"  title=\"{{ step.label | translate }}\">\n      {{ step.label | translate }}\n    </div>\n  </li>\n</ul>\n<ng-container [ngTemplateOutlet]=\"selected.content\"></ng-container>\n",
                providers: [{ provide: CdkStepper, useExisting: C8yStepper }]
            }]
    }], function () { return [{ type: ɵngcc1.Directionality }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }]; }, { disableDefaultIcons: [{
            type: Input
        }], hideStepProgress: [{
            type: Input
        }], onStepChange: [{
            type: Output
        }], disableProgressButtons: [{
            type: Input
        }], customClasses: [{
            type: Input
        }], _icons: [{
            type: ContentChildren,
            args: [C8yStepperIcon, { descendants: true }]
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RlcHBlci5jb21wb25lbnQuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2NvcmUvc3RlcHBlci9zdGVwcGVyLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUVULEtBQUssRUFDTCxNQUFNLEVBQ04sZUFBZSxFQUlmLFlBQVksRUFDWixpQkFBaUIsRUFDakIsVUFBVSxFQUNYLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxVQUFVLEVBQWEsVUFBVSxFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDekUsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQzFELE9BQU8sRUFBRSxPQUFPLEVBQWdCLE1BQU0sTUFBTSxDQUFDO0FBQzdDLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFNSCxNQUFNLE9BQU8sVUFBVyxTQUFRLFVBQVU7QUFBRyxJQThEM0M7QUFDRjtBQUNFLE9BQUc7QUFDTCxJQUFFLFlBQ1Us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O0FBQW9CLFFBQWhCLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLENBQUM7QUFDdkMsUUFBSSxJQUFJLENBQUMsQ0FBQSxNQUFBLE1BQUEsS0FBSyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsMENBQUUsV0FBVywwQ0FBRSxPQUFPLENBQUEsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLGFBQWEsRUFBRTtBQUN4RixZQUFNLElBQUksQ0FBQyxhQUFhLEdBQUcsS0FBSyxDQUFDO0FBQ2pDLFNBQUs7QUFDTCxJQUFFLENBQUM7QUFDSDtzQ0FySUMsU0FBUyxTQUFDLGtCQUNULFFBQVEsRUFBRSxhQUFhLGtCQUN2Qjs7Ozs7OzRSQUF1QyxrQkFDdkMsU0FBUyxFQUFFLENBQUMsRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBRSxVQUFVLEVBQUUsQ0FBQyxjQUM5RDs7Ozs7Ozs4S0FDSTtBQUFDO0FBQW9DLFlBakZqQyxjQUFjO0FBQUksWUFOekIsaUJBQWlCO0FBQ2pCLFlBQUEsVUFBVTtBQUNWO0FBQUc7QUFDTSxrQ0F5RlIsS0FBSztBQUFLLHFDQU1WLEtBQUs7QUFBSyw0QkFLVixLQUFLO0FBQUssK0JBS1YsS0FBSztBQUFLLDJCQUtWLE1BQU07QUFBSyxxQkE0QlgsZUFBZSxTQUFDLGNBQWMsRUFBRSxFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUU7QUFBTTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDb21wb25lbnQsXG4gIFRlbXBsYXRlUmVmLFxuICBJbnB1dCxcbiAgT3V0cHV0LFxuICBDb250ZW50Q2hpbGRyZW4sXG4gIFF1ZXJ5TGlzdCxcbiAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgT25EZXN0cm95LFxuICBFdmVudEVtaXR0ZXIsXG4gIENoYW5nZURldGVjdG9yUmVmLFxuICBFbGVtZW50UmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2RrU3RlcHBlciwgU3RlcFN0YXRlLCBTVEVQX1NUQVRFIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3N0ZXBwZXInO1xuaW1wb3J0IHsgQzh5U3RlcHBlckljb24gfSBmcm9tICcuL3N0ZXBwZXItaWNvbi5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgU3ViamVjdCwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBEaXJlY3Rpb25hbGl0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9iaWRpJztcblxuLyoqXG4gKiBDOHlTdGVwcGVyIGV4dGVuZHMgdGhlIENka1N0ZXBwZXIuIFlvdSBjYW4gdXNlIGNkayBiYXNlZCBmdW5jdGlvbmFsaXR5IGFuZCBpbnB1dHMuXG4gKiBBZGRpdGlvbmFsIHRvIHRoYXQgeW91IGFyZSBhYmxlIHRvIG1vZGlmeSB0aGUgYmVoYXZpb3IgYW5kIGFsc28gdGhlIGxvb2sgYW5kIGZlZWwgd2hlblxuICogdXNpbmcgdGhlIEM4eVN0ZXBwZXIuXG4gKlxuICogVGhlIEM4eVN0ZXBwZXIgaXMgdXNlZCB0byBwcmVzZW50IGFueSBzdGVwLWJhc2VkIHByb2Nlc3MgdG8gdGhlIHVzZXIuXG4gKiBBIHN0ZXBwZXIsIEM4eVN0ZXBwZXIgYW5kL29yIENka1N0ZXBwZXIgaXMgdGhlIHBhcmVudCBvZiBjZGstc3RlcHMuXG4gKiBFYWNoIGNkay1zdGVwIHJlcHJlc2VudHMgb25lIHN0ZXAgaW4gdGhlIHdob2xlIHByb2Nlc3MgdGhhdCB5b3Ugd2FudCB0byBwcm92aWRlIHRvIHRoZSB1c2VyLlxuICpcbiAqIFRoZSBDOHlTdGVwcGVyIHdpbGwgY3JlYXRlLCBiYXNlZCBvbiB0aGUgZ2l2ZW4gY2RrLXN0ZXBzLCBhIGtpbmQgb2Ygc3RlcHBlci1wcm9ncmVzcyB3aGljaCBsb29rcyBsaWtlIHRoaXM6XG4gKiAoMSktLS0oMiktLS0oMyktLS0obilcbiAqIFRoZSBzdGVwcGVyIHdpbGwgaGFuZGxlIHRoZSBzdGF0ZSBvZiBlYWNoIHN0ZXAgYW5kIHByb3ZpZGVzIHN0eWxlcyBmb3IgYWN0aXZlIHN0ZXBzLCBkb25lLXN0ZXBzIG9yIGluIGVkaXQtbW9kZS5cbiAqIFlvdSBhcmUgYWJsZSB0byBvdmVycmlkZSBpY29ucyBmb3IgZWFjaCBzdGVwIGluIHRoZSBzdGVwcGVyLXByb2dyZXNzIHdpdGggYSB0ZW1wbGF0ZS4gWW91IGFyZSBhbHNvIGFibGUgdG8gYWN0aXZhdGVcbiAqIGRlZmF1bHQtaWNvbnMgZm9yIHN0YXRlcyBsaWtlICdlZGl0JyBhbmQgJ2RvbmUnLlxuICpcbiAqIFRvIGZvcmNlIHVzZXJzIHRocm91Z2ggZXZlcnkgcHJvdmlkZWQgc3RlcCwgc2V0IHRoZSBzdGVwcGVyIHRvICdsaW5lYXInLlxuICogVGhpcyB3aWxsIGRpc2FibGUgdGhlIHBvc3NpYmlsaXR5IHRvIG1vdmUgZm9yIGV4YW1wbGUgZnJvbSBzdGVwIG9uZSB0byBzdGVwIHRocmVlLlxuICpcbiAqIFdoZW5ldmVyIGl0IGNvbWVzIHRvIHZhbGlkYXRpb24gdHJ5IHRvIHVzZSBmb3JtR3JvdXBzLiBJdCBpcyBwb3NzaWJsZSB0b1xuICogYXNzaWduIGEgZm9ybUdyb3VwIHRvIGEgY2RrLXN0ZXAgaW5wdXQgY2FsbGVkIFtzdGVwQ29udHJvbF0sIHdoaWNoIGF1dG9tYXRpY2FsbHkgcmVzcGVjdHMgdGhlXG4gKiB2YWxpZGF0aW9uLXJ1bGVzIHRoYXQgeW91IGNyZWF0ZWQgZm9yIHRoaXMgZm9ybUdyb3VwLiBJZiBmaWVsZHMgYXJlIHJlcXVpcmVkIGJ1dCBub3QgZmlsbGVkIG9yXG4gKiBhbnkgb3RoZXIgdmFsaWRhdGlvbiwgbGlrZSBhIHBhdHRlcm4sIGlzIG5vdCBtYXRjaGVkIHRoZSBmb3JtR3JvdXAgd2lsbCBiZSBpbnZhbGlkLiBJbiB0aGlzIGNhc2VcbiAqIHN0ZXBwaW5nIGluIGEgbGluZWFyIHN0ZXBwZXIgdG8gdGhlIG5leHQgc3RlcCBnZXRzIGltcG9zc2libGUuXG4gKlxuICogSWYgdGhlcmUgaXMgdGhlIG5lZWQgdG8gZXhlY3V0ZSBhc3luY2hyb25vdXMgY29kZSB5b3UgaGF2ZSBhdCBsZWFzdCB0d28gcG9zc2liaWxpdGllcy5cbiAqIEZpcnN0OiBBcyB5b3UgbGVhcm5lZCwgYSBjZGstc3RlcCB3b3JrcyB3aXRoIGZvcm1Hcm91cHMgYW5kIFZhbGlkYXRvcnMsIHNvIHlvdSBhcmUgYWJsZSB0byB1c2VcbiAqIGFzeW5jVmFsaWRhdG9ycyBhcyB3ZWxsLlxuICogU2Vjb25kOiBUaGUgQzh5U3RlcHBlciBwcm92aWRlcyBhbiBldmVudC1lbWl0dGVyIG9uU3RlcENoYW5nZSB3aGljaCBpcyBjYWxsZWQgd2hlbmV2ZXIgYSBzdGVwLWJ1dHRvbiAoMSktLSgyKS0tKG4pXG4gKiBpbiB0aGUgc3RlcHBlci1wcm9ncmVzcyBpcyBjbGlja2VkLiBUaGUgZXZlbnQgb2YgdGhpcyBlbWl0dGVyIGhvbGRzIHRoZSBpbmRleCBvZiB0aGUgc3RlcCBhcyBudW1iZXIuIFlvdSBjYW5cbiAqIHVzZSB0aGlzIEV2ZW50RW1pdHRlciB0byBjYWxsIGZvciBleGFtcGxlIGEgY3VzdG9tIG5hdmlnYXRlLW1ldGhvZCB3aGljaCBwZXJmb3JtcyBmaXJzdCBhbnkgYXN5bmMtY2FsbCBhbmQgdGhlbiBtb3Zlc1xuICogb24gdG8gdGhlIGdpdmVuIHN0ZXAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICogPGM4eS1zdGVwcGVyXG4gKiAob25TdGVwQ2hhbmdlKT1cIm5hdmlnYXRlKCRldmVudClcIlxuICogW2Rpc2FibGVEZWZhdWx0SWNvbnNdPVwieyBlZGl0OiB0cnVlLCBkb25lOiBmYWxzZSB9XCJcbiAqIFtjdXN0b21DbGFzc2VzXT1cIlsnbS1sLTQwJywgJ20tci00MCcsICdtLXQtMzInXVwiXG4gKiBsaW5lYXJcbiAqID5cbiAqIDwhLS0gb3ZlcnJpZGUgaWNvbnMgLS0+XG4gKiA8bmctdGVtcGxhdGUgYzh5U3RlcHBlckljb249XCJmaW5hbFwiPlxuICogICA8c3BhbiBbYzh5SWNvbl09XCInaGFuZC1wZWFjZS1vJ1wiPjwvc3Bhbj5cbiAqIDwvbmctdGVtcGxhdGU+XG4gKlxuICogPGNkay1zdGVwIFtzdGVwQ29udHJvbF09XCJmb3JtR3JvdXBTdGVwT25lXCIgbGFiZWw9XCJOYW1lIG9mIHRoZSBoZXJvXCI+XG4gKiAgIDxkaXYgY2xhc3M9XCJtLWwtNDAgbS1yLTQwIG0tdC0zMlwiPlxuICogICAgIDxoNCBjbGFzcz1cInAtYi04XCIgdHJhbnNsYXRlPldoYXQgaXMgdGhlIG5hbWUgb2YgeW91ciBoZXJvPzwvaDQ+XG4gKiAgICAgPGM4eS1mb3JtLWdyb3VwPlxuICogICAgICA8ZGl2IFtmb3JtR3JvdXBdPVwiZm9ybUdyb3VwU3RlcE9uZVwiPlxuICogICAgICAgPGlucHV0XG4gKiAgICAgICAgIGNsYXNzPVwiZm9ybS1jb250cm9sXCJcbiAqICAgICAgICAgdHlwZT1cInRleHRcIlxuICogICAgICAgICBmb3JtQ29udHJvbE5hbWU9XCJuYW1lXCJcbiAqICAgICAgICAgcGxhY2Vob2xkZXI9XCJNaXN0ZXIgWFwiXG4gKiAgICAgICAgICNuYW1lUmVmXG4gKiAgICAgICAgIHJlcXVpcmVkXG4gKiAgICAgICAvPlxuICogICAgICAgPGM4eS1tZXNzYWdlcz5cbiAqICAgICAgICAgPGM4eS1tZXNzYWdlICpuZ0lmPVwiIWZvcm1Hcm91cFN0ZXBPbmUudW50b3VjaGVkICYmICFuYW1lUmVmLnZhbHVlXCIgdHJhbnNsYXRlXG4gKiAgICAgICAgICAgPkVudGVyIHRoZSBuYW1lIG9mIHRoZSBTdXBlcmhlcm88L2M4eS1tZXNzYWdlXG4gKiAgICAgICAgID5cbiAqICAgICAgIDwvYzh5LW1lc3NhZ2VzPlxuICogICAgICA8L2Rpdj5cbiAqICAgICA8L2M4eS1mb3JtLWdyb3VwPlxuICogICA8L2Rpdj5cbiAqICAgPGM4eS1zdGVwcGVyLWJ1dHRvbnM+PC9jOHktc3RlcHBlci1idXR0b25zPlxuICogPC9jZGstc3RlcD5cbiAqIDxjZGstc3RlcD5cbiAqICAuLi5cbiAqIDwvY2RrLXN0ZXAgc3RhdGU9XCJmaW5hbFwiPlxuICogPC9jOHktc3RlcHBlcj5cbiAqIGBgYFxuICovXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjOHktc3RlcHBlcicsXG4gIHRlbXBsYXRlVXJsOiAnLi9zdGVwcGVyLmNvbXBvbmVudC5odG1sJyxcbiAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBDZGtTdGVwcGVyLCB1c2VFeGlzdGluZzogQzh5U3RlcHBlciB9XVxufSlcbmV4cG9ydCBjbGFzcyBDOHlTdGVwcGVyIGV4dGVuZHMgQ2RrU3RlcHBlciBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG4gIC8qKlxuICAgKiBPcHRpb25hbFxuICAgKiBJbmRpY2F0b3IgaWYgaWNvbnMgZm9yIGVkaXQgYW5kIGRvbmUgc3RhdGUgc2hvdWxkIGJlIHNob3duIGluIHN0ZXAtaGVhZGVyIGJ1dHRvbnNcbiAgICovXG4gIEBJbnB1dCgpIGRpc2FibGVEZWZhdWx0SWNvbnM/OiB7IGVkaXQ6IGJvb2xlYW47IGRvbmU6IGJvb2xlYW4gfSA9IHsgZWRpdDogdHJ1ZSwgZG9uZTogdHJ1ZSB9O1xuICAvKipcbiAgICogT3B0aW9uYWxcbiAgICogRGlzYWJsZS9lbmFibGUgbmF2aWdhdGlvbiBieSBzdGVwcGVyIHByb2dyZXNzIGJ1dHRvbnNcbiAgICogZGVmYXVsdDogZmFsc2VcbiAgICovXG4gIEBJbnB1dCgpIGRpc2FibGVQcm9ncmVzc0J1dHRvbnM6IGZhbHNlO1xuICAvKipcbiAgICogT3B0aW9uYWxcbiAgICogUG9zc2liaWxpdHkgdG8gYWRkIGFueSBraW5kIG9mIGN1c3RvbSBjc3MgY2xhc3NlcyB0byB0aGUgc3RlcC1oZWFkZXJcbiAgICovXG4gIEBJbnB1dCgpIGN1c3RvbUNsYXNzZXM/OiBzdHJpbmdbXTtcbiAgLyoqXG4gICAqIE9wdGlvbmFsXG4gICAqIFBvc3NpYmlsaXR5IHRvIGhpZGUgdGhlIHN0ZXBwZXIgcHJvZ3Jlc3MgY29tcGxldGVseS5cbiAgICovXG4gIEBJbnB1dCgpIGhpZGVTdGVwUHJvZ3Jlc3M/OiBib29sZWFuID0gZmFsc2U7XG4gIC8qKlxuICAgKiBXaWxsIGVtaXQgdGhlIHN0ZXAgaW5kZXggbnVtYmVyIHdoZW5ldmVyIGEgc3RlcC1oZWFkZXIgYnV0dG9uIHdhcyBjbGlja2VkXG4gICAqIEl0IGxpc3RlbnMgdG8gdGhlIHN0ZXBJbmRleCBTdWJqZWN0LlxuICAgKi9cbiAgQE91dHB1dCgpIG9uU3RlcENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuXG4gIC8qKlxuICAgKiBIb2xkaW5nIGEgUXVlcnlMaXN0IG9mIEM4eVN0ZXBwZXJJY29uc1xuICAgKiBUaGVzZSBhcmUgdGVtcGxhdGVSZWZzIHdoaWNoIG92ZXJyaWRlcyBhbnkgc3RlcC1oZWFkZXIgYnV0dG9uIGljb24gd2l0aCBtYXRjaGluZyBzdGF0ZSBvZiBjZGstc3RlcFxuICAgKlxuICAgKiBAZXhhbXBsZTpcbiAgICogYGBgXG4gICAqIDwhLS0gb3ZlcnJpZGUgaWNvbnMgLS0+XG4gICAqICA8bmctdGVtcGxhdGUgYzh5U3RlcHBlckljb249XCJmaW5hbFwiPlxuICAgKiAgIDxzcGFuIFtjOHlJY29uXT1cIidoYW5kLXBlYWNlLW8nXCI+PC9zcGFuPlxuICAgKiAgPC9uZy10ZW1wbGF0ZT5cbiAgICpcbiAgICogPGNkay1zdGVwIHN0YXRlPVwiZmluYWxcIiBsYWJlbD1cIkpvYiBkb25lIVwiPlxuICAgKiAgPGRpdiBjbGFzcz1cIm0tbC00MCBtLXItNDAgbS10LTMyXCI+XG4gICAqICAgIDxoNCBjbGFzcz1cInAtYi0zMlwiIHN0eWxlPVwidGV4dC1hbGlnbjogY2VudGVyO1wiIHRyYW5zbGF0ZT5cbiAgICogICAgIFlvdXIgU3VwZXJoZXJvIGlzIG5vdyByZWFkeSB0byBzYXZlIHRoZSB3b3JsZCFcbiAgICogICA8L2g0PlxuICAgKiAgPC9kaXY+XG4gICAqICA8Yzh5LXN0ZXBwZXItYnV0dG9uc1xuICAgKiAgICBbaGlkZGVuXT1cIiFpc01vZGFsXCJcbiAgICogICAgKG9uQmFjayk9XCJjbG9zZSgpXCJcbiAgICogICAgW2xhYmVsc109XCJ7IGJhY2s6ICdHb3QgaXQhJyB9XCJcbiAgICogID48L2M4eS1zdGVwcGVyLWJ1dHRvbnM+XG4gICAqICA8Yzh5LXN0ZXBwZXItYnV0dG9ucyBbaGlkZGVuXT1cImlzTW9kYWxcIj48L2M4eS1zdGVwcGVyLWJ1dHRvbnM+XG4gICAqIDwvY2RrLXN0ZXA+XG4gICAqIGBgYFxuICAgKi9cbiAgQENvbnRlbnRDaGlsZHJlbihDOHlTdGVwcGVySWNvbiwgeyBkZXNjZW5kYW50czogdHJ1ZSB9KSBfaWNvbnM6IFF1ZXJ5TGlzdDxDOHlTdGVwcGVySWNvbj47XG5cbiAgLyoqIENvbnN1bWVyLXNwZWNpZmllZCB0ZW1wbGF0ZS1yZWZzIHRvIGJlIHVzZWQgdG8gb3ZlcnJpZGUgdGhlIGhlYWRlciBpY29ucy4gKi9cbiAgX2ljb25PdmVycmlkZXM6IHsgW2tleTogc3RyaW5nXTogVGVtcGxhdGVSZWY8YW55PiB9ID0ge307XG5cbiAgcHJpdmF0ZSBfc3RlcEluZGV4OiBTdWJqZWN0PG51bWJlcj4gPSBuZXcgU3ViamVjdCgpO1xuICBwcml2YXRlIF9zdGVwSW5kZXhTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBkaXI6IERpcmVjdGlvbmFsaXR5LFxuICAgIHByaXZhdGUgY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmLFxuICAgIHByaXZhdGUgZWxlbWVudFJlZj86IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+XG4gICkge1xuICAgIHN1cGVyKGRpciwgY2hhbmdlRGV0ZWN0b3JSZWYsIGVsZW1lbnRSZWYsIGRvY3VtZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgc3VwZXIubmdBZnRlckNvbnRlbnRJbml0KCk7XG4gICAgdGhpcy5faWNvbnMuZm9yRWFjaCgoeyBuYW1lLCB0ZW1wbGF0ZVJlZiB9KSA9PiAodGhpcy5faWNvbk92ZXJyaWRlc1tuYW1lXSA9IHRlbXBsYXRlUmVmKSk7XG4gICAgdGhpcy5fc3RlcEluZGV4U3Vic2NyaXB0aW9uID0gdGhpcy5fc3RlcEluZGV4LnN1YnNjcmliZShpbmRleCA9PiB0aGlzLm9uU3RlcENoYW5nZS5lbWl0KGluZGV4KSk7XG4gIH1cblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuX3N0ZXBJbmRleFN1YnNjcmlwdGlvbiAmJiAhdGhpcy5fc3RlcEluZGV4U3Vic2NyaXB0aW9uLmNsb3NlZCkge1xuICAgICAgdGhpcy5fc3RlcEluZGV4U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1hbmlwdWxhdGVzIHRoZSBzdGF0ZSBiYXNlZCBvbiB0aGUgZGlzYWJsZWREZWZhdWx0SWNvbnMgSW5wdXQoKVxuICAgKiBDaGFuZ2luZyBlZGl0IG9yIGRvbmUgdG8gZmFsc2Ugd2lsbCBjaGFuZ2UgdGhlIGljb25zIHdpdGhpbiBzdGVwLWhlYWRlciBidXR0b25zXG4gICAqIEBwYXJhbSBpbmRleCBzdGVwIGluZGV4XG4gICAqIEBwYXJhbSBzdGF0ZSBzdGVwIHN0YXRlLCBsaWtlICdkb25lJywgJ2VkaXQnLCAnZXJyb3InXG4gICAqL1xuICBnZXRJbmRpY2F0b3JUeXBlKGluZGV4OiBudW1iZXIsIHN0YXRlOiBTdGVwU3RhdGUpIHtcbiAgICBjb25zdCBzdGVwU3RhdGUgPSB0aGlzLl9nZXRJbmRpY2F0b3JUeXBlKGluZGV4LCBzdGF0ZSk7XG4gICAgbGV0IF9zdGF0ZSA9IHN0YXRlO1xuICAgIHN3aXRjaCAoc3RlcFN0YXRlKSB7XG4gICAgICBjYXNlIFNURVBfU1RBVEUuRURJVDpcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVEZWZhdWx0SWNvbnMuZWRpdCkge1xuICAgICAgICAgIF9zdGF0ZSA9IFNURVBfU1RBVEUuRURJVDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBTVEVQX1NUQVRFLkRPTkU6XG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlRGVmYXVsdEljb25zLmRvbmUpIHtcbiAgICAgICAgICBfc3RhdGUgPSBTVEVQX1NUQVRFLkRPTkU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3N0YXRlID0gJ19kb25lJztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIF9zdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdXNoZXMgdGhlIHN0ZXAgaW5kZXggdG8gdGhlIHN1YmplY3RcbiAgICogQHBhcmFtIGluZGV4IHN0ZXAgaW5kZXhcbiAgICovXG4gIHNldEluZGV4KGluZGV4OiBudW1iZXIpIHtcbiAgICBjb25zdCBzdGVwcyA9IHRoaXMuc3RlcHMudG9BcnJheSgpO1xuICAgIGlmICghc3RlcHNbdGhpcy5zZWxlY3RlZEluZGV4XT8uc3RlcENvbnRyb2w/LmludmFsaWQgfHwgaW5kZXggPCB0aGlzLnNlbGVjdGVkSW5kZXgpIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IGluZGV4O1xuICAgIH1cbiAgfVxufVxuIl19