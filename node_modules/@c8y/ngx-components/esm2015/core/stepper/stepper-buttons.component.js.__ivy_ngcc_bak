import { CdkStep } from '@angular/cdk/stepper';
import { Component, EventEmitter, Host, Input, Output } from '@angular/core';
import { C8yStepper } from './stepper.component';
/**
 * C8yStepperButtons provides a convenient way to have, according to
 * the C8yStepper and each cdk-step, buttons to navigate between steps or to cancel the whole
 * step-process. Buttons rendered with the help of this component will use the branding css.
 *
 * By default all steps with this component in use will render a next button, expect the last step.
 * The other way around, every step using this component will render a back button, expect the first step.
 * To get a cancel button rendered you need to handle the onCancel event.
 * For next and back button you don't need to handle the available events onNext and onBack because default behavior
 * is implemented. The default will just call, according to the button, the stepper.next() or stepper.previous()
 * methods and moves the stepper forth or back. Using the EventEmitter onNext and onBack will emit for you the following
 * object: {stepper: C8yStepper, step: CdkStep}. This is useful if you need to implement custom logic before moving
 * to the next step or sending data to a backend. In this case you need to tell the stepper to move forward or back
 * on your own.
 *
 * With the component input [labels] you can change the label of each button in each step. It takes an object like this:
 * {next?: string, back?: string, cancel?: string}
 *
 * The [pending] input is of type boolean and will enable css animation for the next button when true.
 *
 * If the cdk-step provides a stepControl the component will set the next button disabled when the formGroup
 * behind it is invalid. As long as the [pending] input is true the back and next button is also disabled.
 * This will prevent multiple clicks while running a request or stepping back while a request is ongoing.
 *
 * **Example**
 * ```
 * <c8y-stepper>
 *  <cdk-step>
 *    <!--
 *      your html code
 *          ...
 *          ...    -->
 *    <c8y-stepper-buttons
 *     (onNext)="save()"
 *     [labels]="{ next: 'Save' }"
 *     [pending]="pendingStatus"
 *     ></c8y-stepper-buttons>
 *  </cdk-step>
 * </c8y-stepper>
 *
 * // in your component:
 * async save() {
 *   this.pendingStatus = true;
 *   // your async request goes here ...
 *   // await something();
 *   this.pendingStatus = false;
 *   this.stepper.next();
 * }
 * ```
 */
export class C8yStepperButtons {
    constructor(stepper, step) {
        this.stepper = stepper;
        this.step = step;
        /**
         * Optional
         * Indicates if a request is pending and sets the next button
         * to disabled when true
         */
        this.pending = false;
        /**
         * Disabled state of a button
         */
        this.disabled = false;
        /**
         * EventEmitter which emits when cancel button is clicked
         */
        this.onCancel = new EventEmitter();
        /**
         * EventEmitter which emits {stepper: C8yStepper; step: CdkStep} when next button is clicked.
         */
        this.onNext = new EventEmitter();
        /**
         * EventEmitter which emits {stepper: C8yStepper; step: CdkStep} when back button is clicked.
         */
        this.onBack = new EventEmitter();
        /**
         * EventEmitter which emits when the optional custom button is clicked
         */
        this.onCustom = new EventEmitter();
        /**
         * Indicator which button should be shown.
         * Based on the cdk-steps within the c8y-stepper
         * next and back buttons are rendered.
         */
        this.showBtns = {
            cancel: false,
            back: false,
            next: false,
            custom: false
        };
        /**
         * Flag that indicates that the default settings defined in the showBtns have been overwritten.
         */
        this.forceShowBtns = false;
    }
    /**
     * This option forces the display of the buttons passed by the input.
     * It will override the default settings and take precedence over the standard settings.
     * @param btns An object that contains options for displaying buttons.
     *
     * **Example**
     * ```html
     *
     * <c8y-stepper-buttons
     *   [labels]="{ custom: 'Custom btn', cancel: 'Cancel btn' }"
     *   [showButtons]="{ custom: true, cancel: true }"
     * ></c8y-stepper-buttons>
     *
     * ```
     */
    set showButtons(btns) {
        if (btns) {
            this.showBtns = btns;
            this.forceShowBtns = true;
        }
    }
    /**
     * @ignore
     */
    ngAfterContentInit() {
        if (!this.forceShowBtns) {
            this.showBtns.cancel = this.onCancel.observers.length > 0;
            this.showBtns.custom = this.onCustom.observers.length > 0;
        }
        if (this.stepper && this.stepper._steps && this.step && !this.forceShowBtns) {
            this.showBtns.back = this.stepper._steps.first !== this.step;
            this.showBtns.next = this.stepper._steps.last !== this.step;
        }
        if (this.step && this.step.stepControl) {
            this.disabled = this.step.stepControl.invalid;
            this.statusChangeSubscription = this.step.stepControl.statusChanges.subscribe(status => {
                this.disabled = this.step.stepControl.invalid;
            });
        }
    }
    /**
     * @ignore
     */
    ngOnChanges(changes) {
        /**
         * Disable save/next button while the status is pending
         * This will prevent multiple clicks and therefore multiple requests
         */
        if (changes && changes.pending) {
            this.disabled = changes.pending.currentValue;
        }
    }
    ngOnDestroy() {
        if (this.statusChangeSubscription && !this.statusChangeSubscription.closed) {
            this.statusChangeSubscription.unsubscribe();
        }
    }
    /**
     * Gets called when cancel button is clicked.
     * It will emit immediate.
     */
    cancel() {
        this.onCancel.emit();
    }
    /**
     * Gets called when next button is clicked. When onNext EventEmitter has an observer registered
     * it will emit the following object {stepper: C8yStepper; step: CdkStep}.
     * Otherwise it will call stepper.next() as default.
     */
    next() {
        if (this.onNext.observers.length > 0) {
            this.onNext.emit({ stepper: this.stepper, step: this.step });
        }
        else {
            this.stepper.next();
        }
    }
    /**
     * Gets called when back button is clicked. When onBack EventEmitter has an observer registered
     * it will emit the following object {stepper: C8yStepper; step: CdkStep}.
     * Otherwise it will call stepper.previous() as default.
     */
    back() {
        this.stepper.selected.completed = false;
        if (this.onBack.observers.length > 0) {
            this.onBack.emit({ stepper: this.stepper, step: this.step });
        }
        else {
            this.stepper.previous();
        }
    }
    /**
     * Gets called when the custom button is clicked.
     * It will emit immediately.
     */
    custom() {
        this.onCustom.emit();
    }
}
C8yStepperButtons.decorators = [
    { type: Component, args: [{
                selector: 'c8y-stepper-buttons',
                template: "<div class=\"text-center\">\n  <button *ngIf=\"showBtns.cancel\" (click)=\"cancel()\" type=\"button\" class=\"btn btn-default\">\n    <span *ngIf=\"labels?.cancel; else cancelLabel\" title=\"{{ labels?.cancel | translate }}\">{{\n      labels?.cancel | translate\n    }}</span>\n    <ng-template #cancelLabel>\n      <span title=\"{{ 'Cancel' | translate }}\">{{ 'Cancel' | translate }}</span>\n    </ng-template>\n  </button>\n  <button\n    *ngIf=\"showBtns.back\"\n    type=\"button\"\n    (click)=\"back()\"\n    class=\"btn btn-default\"\n    [disabled]=\"pending\"\n  >\n    <span *ngIf=\"labels?.back; else backLabel\" title=\"{{ labels?.back | translate }}\">{{\n      labels?.back | translate\n    }}</span>\n    <ng-template #backLabel>\n      <span title=\"{{ 'Back' | translate }}\">{{ 'Back' | translate }}</span>\n    </ng-template>\n  </button>\n  <button\n    *ngIf=\"showBtns.custom\"\n    (click)=\"custom()\"\n    type=\"button\"\n    class=\"btn\"\n    [ngClass]=\"{\n      'btn-default': showBtns.next,\n      'btn-primary': !showBtns.next,\n      'btn-pending': pending\n    }\"\n    [disabled]=\"pending || disabled\"\n  >\n    <span *ngIf=\"labels?.custom; else customLabel\" title=\"{{ labels?.custom | translate }}\">{{\n      labels?.custom | translate\n    }}</span>\n    <ng-template #customLabel>\n      <span title=\"{{ 'Complete' | translate }}\">{{ 'Complete' | translate }}</span>\n    </ng-template>\n  </button>\n  <button\n    (click)=\"next()\"\n    *ngIf=\"showBtns.next\"\n    type=\"button\"\n    class=\"btn btn-primary\"\n    [ngClass]=\"{ 'btn-pending': pending }\"\n    [disabled]=\"disabled\"\n  >\n    <span *ngIf=\"labels?.next; else nextLabel\" title=\"{{ labels?.next | translate }}\">{{\n      labels?.next | translate\n    }}</span>\n    <ng-template #nextLabel>\n      <span title=\"{{ 'Next' | translate }}\">{{ 'Next' | translate }}</span>\n    </ng-template>\n  </button>\n</div>\n"
            },] }
];
C8yStepperButtons.ctorParameters = () => [
    { type: C8yStepper, decorators: [{ type: Host }] },
    { type: CdkStep, decorators: [{ type: Host }] }
];
C8yStepperButtons.propDecorators = {
    labels: [{ type: Input }],
    pending: [{ type: Input }],
    disabled: [{ type: Input }],
    onCancel: [{ type: Output }],
    onNext: [{ type: Output }],
    onBack: [{ type: Output }],
    onCustom: [{ type: Output }],
    showButtons: [{ type: Input }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RlcHBlci1idXR0b25zLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2NvcmUvc3RlcHBlci9zdGVwcGVyLWJ1dHRvbnMuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUMvQyxPQUFPLEVBRUwsU0FBUyxFQUNULFlBQVksRUFDWixJQUFJLEVBQ0osS0FBSyxFQUdMLE1BQU0sRUFFUCxNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFHakQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FpREc7QUFLSCxNQUFNLE9BQU8saUJBQWlCO0lBc0Q1QixZQUNrQixPQUFtQixFQUNuQixJQUFhO1FBRGIsWUFBTyxHQUFQLE9BQU8sQ0FBWTtRQUNuQixTQUFJLEdBQUosSUFBSSxDQUFTO1FBbEQvQjs7OztXQUlHO1FBQ00sWUFBTyxHQUFhLEtBQUssQ0FBQztRQUVuQzs7V0FFRztRQUNNLGFBQVEsR0FBYSxLQUFLLENBQUM7UUFFcEM7O1dBRUc7UUFDTyxhQUFRLEdBQUcsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQUN4Qzs7V0FFRztRQUNPLFdBQU0sR0FBRyxJQUFJLFlBQVksRUFBMEMsQ0FBQztRQUU5RTs7V0FFRztRQUNPLFdBQU0sR0FBRyxJQUFJLFlBQVksRUFBMEMsQ0FBQztRQUU5RTs7V0FFRztRQUNPLGFBQVEsR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO1FBRXhDOzs7O1dBSUc7UUFDSCxhQUFRLEdBQTZCO1lBQ25DLE1BQU0sRUFBRSxLQUFLO1lBQ2IsSUFBSSxFQUFFLEtBQUs7WUFDWCxJQUFJLEVBQUUsS0FBSztZQUNYLE1BQU0sRUFBRSxLQUFLO1NBQ2QsQ0FBQztRQUNGOztXQUVHO1FBQ0gsa0JBQWEsR0FB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Q0FBQyxFQUFFO1lBQ3BDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsT0FBTyxFQUFFLElBQUksQ0FBQyxPQUFPLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO1NBQzlEO2FBQU07WUFDTCxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxDQUFDO1NBQ3pCO0lBQ0gsQ0FBQztJQUVEOzs7T0FHRztJQUNILE1BQU07UUFDSixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxDQUFDO0lBQ3ZCLENBQUM7OztZQXhLRixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLHFCQUFxQjtnQkFDL0IsNjVEQUErQzthQUNoRDs7O1lBeERRLFVBQVUsdUJBZ0hkLElBQUk7WUE3SEEsT0FBTyx1QkE4SFgsSUFBSTs7O3FCQW5ETixLQUFLO3NCQU1MLEtBQUs7dUJBS0wsS0FBSzt1QkFLTCxNQUFNO3FCQUlOLE1BQU07cUJBS04sTUFBTTt1QkFLTixNQUFNOzBCQXVDTixLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2RrU3RlcCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9zdGVwcGVyJztcbmltcG9ydCB7XG4gIEFmdGVyQ29udGVudEluaXQsXG4gIENvbXBvbmVudCxcbiAgRXZlbnRFbWl0dGVyLFxuICBIb3N0LFxuICBJbnB1dCxcbiAgT25DaGFuZ2VzLFxuICBPbkRlc3Ryb3ksXG4gIE91dHB1dCxcbiAgU2ltcGxlQ2hhbmdlc1xufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgQzh5U3RlcHBlciB9IGZyb20gJy4vc3RlcHBlci5jb21wb25lbnQnO1xuaW1wb3J0IHsgU3RlcHBlckJ1dHRvbnNWaXNpYmlsaXR5IH0gZnJvbSAnLi9zdGVwcGVyLm1vZGVsJztcblxuLyoqXG4gKiBDOHlTdGVwcGVyQnV0dG9ucyBwcm92aWRlcyBhIGNvbnZlbmllbnQgd2F5IHRvIGhhdmUsIGFjY29yZGluZyB0b1xuICogdGhlIEM4eVN0ZXBwZXIgYW5kIGVhY2ggY2RrLXN0ZXAsIGJ1dHRvbnMgdG8gbmF2aWdhdGUgYmV0d2VlbiBzdGVwcyBvciB0byBjYW5jZWwgdGhlIHdob2xlXG4gKiBzdGVwLXByb2Nlc3MuIEJ1dHRvbnMgcmVuZGVyZWQgd2l0aCB0aGUgaGVscCBvZiB0aGlzIGNvbXBvbmVudCB3aWxsIHVzZSB0aGUgYnJhbmRpbmcgY3NzLlxuICpcbiAqIEJ5IGRlZmF1bHQgYWxsIHN0ZXBzIHdpdGggdGhpcyBjb21wb25lbnQgaW4gdXNlIHdpbGwgcmVuZGVyIGEgbmV4dCBidXR0b24sIGV4cGVjdCB0aGUgbGFzdCBzdGVwLlxuICogVGhlIG90aGVyIHdheSBhcm91bmQsIGV2ZXJ5IHN0ZXAgdXNpbmcgdGhpcyBjb21wb25lbnQgd2lsbCByZW5kZXIgYSBiYWNrIGJ1dHRvbiwgZXhwZWN0IHRoZSBmaXJzdCBzdGVwLlxuICogVG8gZ2V0IGEgY2FuY2VsIGJ1dHRvbiByZW5kZXJlZCB5b3UgbmVlZCB0byBoYW5kbGUgdGhlIG9uQ2FuY2VsIGV2ZW50LlxuICogRm9yIG5leHQgYW5kIGJhY2sgYnV0dG9uIHlvdSBkb24ndCBuZWVkIHRvIGhhbmRsZSB0aGUgYXZhaWxhYmxlIGV2ZW50cyBvbk5leHQgYW5kIG9uQmFjayBiZWNhdXNlIGRlZmF1bHQgYmVoYXZpb3JcbiAqIGlzIGltcGxlbWVudGVkLiBUaGUgZGVmYXVsdCB3aWxsIGp1c3QgY2FsbCwgYWNjb3JkaW5nIHRvIHRoZSBidXR0b24sIHRoZSBzdGVwcGVyLm5leHQoKSBvciBzdGVwcGVyLnByZXZpb3VzKClcbiAqIG1ldGhvZHMgYW5kIG1vdmVzIHRoZSBzdGVwcGVyIGZvcnRoIG9yIGJhY2suIFVzaW5nIHRoZSBFdmVudEVtaXR0ZXIgb25OZXh0IGFuZCBvbkJhY2sgd2lsbCBlbWl0IGZvciB5b3UgdGhlIGZvbGxvd2luZ1xuICogb2JqZWN0OiB7c3RlcHBlcjogQzh5U3RlcHBlciwgc3RlcDogQ2RrU3RlcH0uIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSBuZWVkIHRvIGltcGxlbWVudCBjdXN0b20gbG9naWMgYmVmb3JlIG1vdmluZ1xuICogdG8gdGhlIG5leHQgc3RlcCBvciBzZW5kaW5nIGRhdGEgdG8gYSBiYWNrZW5kLiBJbiB0aGlzIGNhc2UgeW91IG5lZWQgdG8gdGVsbCB0aGUgc3RlcHBlciB0byBtb3ZlIGZvcndhcmQgb3IgYmFja1xuICogb24geW91ciBvd24uXG4gKlxuICogV2l0aCB0aGUgY29tcG9uZW50IGlucHV0IFtsYWJlbHNdIHlvdSBjYW4gY2hhbmdlIHRoZSBsYWJlbCBvZiBlYWNoIGJ1dHRvbiBpbiBlYWNoIHN0ZXAuIEl0IHRha2VzIGFuIG9iamVjdCBsaWtlIHRoaXM6XG4gKiB7bmV4dD86IHN0cmluZywgYmFjaz86IHN0cmluZywgY2FuY2VsPzogc3RyaW5nfVxuICpcbiAqIFRoZSBbcGVuZGluZ10gaW5wdXQgaXMgb2YgdHlwZSBib29sZWFuIGFuZCB3aWxsIGVuYWJsZSBjc3MgYW5pbWF0aW9uIGZvciB0aGUgbmV4dCBidXR0b24gd2hlbiB0cnVlLlxuICpcbiAqIElmIHRoZSBjZGstc3RlcCBwcm92aWRlcyBhIHN0ZXBDb250cm9sIHRoZSBjb21wb25lbnQgd2lsbCBzZXQgdGhlIG5leHQgYnV0dG9uIGRpc2FibGVkIHdoZW4gdGhlIGZvcm1Hcm91cFxuICogYmVoaW5kIGl0IGlzIGludmFsaWQuIEFzIGxvbmcgYXMgdGhlIFtwZW5kaW5nXSBpbnB1dCBpcyB0cnVlIHRoZSBiYWNrIGFuZCBuZXh0IGJ1dHRvbiBpcyBhbHNvIGRpc2FibGVkLlxuICogVGhpcyB3aWxsIHByZXZlbnQgbXVsdGlwbGUgY2xpY2tzIHdoaWxlIHJ1bm5pbmcgYSByZXF1ZXN0IG9yIHN0ZXBwaW5nIGJhY2sgd2hpbGUgYSByZXF1ZXN0IGlzIG9uZ29pbmcuXG4gKlxuICogKipFeGFtcGxlKipcbiAqIGBgYFxuICogPGM4eS1zdGVwcGVyPlxuICogIDxjZGstc3RlcD5cbiAqICAgIDwhLS1cbiAqICAgICAgeW91ciBodG1sIGNvZGVcbiAqICAgICAgICAgIC4uLlxuICogICAgICAgICAgLi4uICAgIC0tPlxuICogICAgPGM4eS1zdGVwcGVyLWJ1dHRvbnNcbiAqICAgICAob25OZXh0KT1cInNhdmUoKVwiXG4gKiAgICAgW2xhYmVsc109XCJ7IG5leHQ6ICdTYXZlJyB9XCJcbiAqICAgICBbcGVuZGluZ109XCJwZW5kaW5nU3RhdHVzXCJcbiAqICAgICA+PC9jOHktc3RlcHBlci1idXR0b25zPlxuICogIDwvY2RrLXN0ZXA+XG4gKiA8L2M4eS1zdGVwcGVyPlxuICpcbiAqIC8vIGluIHlvdXIgY29tcG9uZW50OlxuICogYXN5bmMgc2F2ZSgpIHtcbiAqICAgdGhpcy5wZW5kaW5nU3RhdHVzID0gdHJ1ZTtcbiAqICAgLy8geW91ciBhc3luYyByZXF1ZXN0IGdvZXMgaGVyZSAuLi5cbiAqICAgLy8gYXdhaXQgc29tZXRoaW5nKCk7XG4gKiAgIHRoaXMucGVuZGluZ1N0YXR1cyA9IGZhbHNlO1xuICogICB0aGlzLnN0ZXBwZXIubmV4dCgpO1xuICogfVxuICogYGBgXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2M4eS1zdGVwcGVyLWJ1dHRvbnMnLFxuICB0ZW1wbGF0ZVVybDogJy4vc3RlcHBlci1idXR0b25zLmNvbXBvbmVudC5odG1sJ1xufSlcbmV4cG9ydCBjbGFzcyBDOHlTdGVwcGVyQnV0dG9ucyBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSwgT25DaGFuZ2VzIHtcbiAgLyoqXG4gICAqIE9wdGlvbmFsXG4gICAqIFNwZWNpZnkgY3VzdG9tIGxhYmVscyBmb3IgZWFjaCBidXR0b24gKGNhbmNlbCwgYmFjayBvciBuZXh0KVxuICAgKi9cbiAgQElucHV0KCkgbGFiZWxzPzogeyBjYW5jZWw/OiBzdHJpbmc7IGJhY2s/OiBzdHJpbmc7IG5leHQ/OiBzdHJpbmc7IGN1c3RvbT86IHN0cmluZyB9O1xuICAvKipcbiAgICogT3B0aW9uYWxcbiAgICogSW5kaWNhdGVzIGlmIGEgcmVxdWVzdCBpcyBwZW5kaW5nIGFuZCBzZXRzIHRoZSBuZXh0IGJ1dHRvblxuICAgKiB0byBkaXNhYmxlZCB3aGVuIHRydWVcbiAgICovXG4gIEBJbnB1dCgpIHBlbmRpbmc/OiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIERpc2FibGVkIHN0YXRlIG9mIGEgYnV0dG9uXG4gICAqL1xuICBASW5wdXQoKSBkaXNhYmxlZD86IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKipcbiAgICogRXZlbnRFbWl0dGVyIHdoaWNoIGVtaXRzIHdoZW4gY2FuY2VsIGJ1dHRvbiBpcyBjbGlja2VkXG4gICAqL1xuICBAT3V0cHV0KCkgb25DYW5jZWwgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIC8qKlxuICAgKiBFdmVudEVtaXR0ZXIgd2hpY2ggZW1pdHMge3N0ZXBwZXI6IEM4eVN0ZXBwZXI7IHN0ZXA6IENka1N0ZXB9IHdoZW4gbmV4dCBidXR0b24gaXMgY2xpY2tlZC5cbiAgICovXG4gIEBPdXRwdXQoKSBvbk5leHQgPSBuZXcgRXZlbnRFbWl0dGVyPHsgc3RlcHBlcjogQzh5U3RlcHBlcjsgc3RlcDogQ2RrU3RlcCB9PigpO1xuXG4gIC8qKlxuICAgKiBFdmVudEVtaXR0ZXIgd2hpY2ggZW1pdHMge3N0ZXBwZXI6IEM4eVN0ZXBwZXI7IHN0ZXA6IENka1N0ZXB9IHdoZW4gYmFjayBidXR0b24gaXMgY2xpY2tlZC5cbiAgICovXG4gIEBPdXRwdXQoKSBvbkJhY2sgPSBuZXcgRXZlbnRFbWl0dGVyPHsgc3RlcHBlcjogQzh5U3RlcHBlcjsgc3RlcDogQ2RrU3RlcCB9PigpO1xuXG4gIC8qKlxuICAgKiBFdmVudEVtaXR0ZXIgd2hpY2ggZW1pdHMgd2hlbiB0aGUgb3B0aW9uYWwgY3VzdG9tIGJ1dHRvbiBpcyBjbGlja2VkXG4gICAqL1xuICBAT3V0cHV0KCkgb25DdXN0b20gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgLyoqXG4gICAqIEluZGljYXRvciB3aGljaCBidXR0b24gc2hvdWxkIGJlIHNob3duLlxuICAgKiBCYXNlZCBvbiB0aGUgY2RrLXN0ZXBzIHdpdGhpbiB0aGUgYzh5LXN0ZXBwZXJcbiAgICogbmV4dCBhbmQgYmFjayBidXR0b25zIGFyZSByZW5kZXJlZC5cbiAgICovXG4gIHNob3dCdG5zOiBTdGVwcGVyQnV0dG9uc1Zpc2liaWxpdHkgPSB7XG4gICAgY2FuY2VsOiBmYWxzZSxcbiAgICBiYWNrOiBmYWxzZSxcbiAgICBuZXh0OiBmYWxzZSxcbiAgICBjdXN0b206IGZhbHNlXG4gIH07XG4gIC8qKlxuICAgKiBGbGFnIHRoYXQgaW5kaWNhdGVzIHRoYXQgdGhlIGRlZmF1bHQgc2V0dGluZ3MgZGVmaW5lZCBpbiB0aGUgc2hvd0J0bnMgaGF2ZSBiZWVuIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgZm9yY2VTaG93QnRuczogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIHByaXZhdGUgc3RhdHVzQ2hhbmdlU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG4gIGNvbnN0cnVjdG9yKFxuICAgIEBIb3N0KCkgcHJpdmF0ZSBzdGVwcGVyOiBDOHlTdGVwcGVyLFxuICAgIEBIb3N0KCkgcHJpdmF0ZSBzdGVwOiBDZGtTdGVwXG4gICkge31cblxuICAvKipcbiAgICogVGhpcyBvcHRpb24gZm9yY2VzIHRoZSBkaXNwbGF5IG9mIHRoZSBidXR0b25zIHBhc3NlZCBieSB0aGUgaW5wdXQuXG4gICAqIEl0IHdpbGwgb3ZlcnJpZGUgdGhlIGRlZmF1bHQgc2V0dGluZ3MgYW5kIHRha2UgcHJlY2VkZW5jZSBvdmVyIHRoZSBzdGFuZGFyZCBzZXR0aW5ncy5cbiAgICogQHBhcmFtIGJ0bnMgQW4gb2JqZWN0IHRoYXQgY29udGFpbnMgb3B0aW9ucyBmb3IgZGlzcGxheWluZyBidXR0b25zLlxuICAgKlxuICAgKiAqKkV4YW1wbGUqKlxuICAgKiBgYGBodG1sXG4gICAqXG4gICAqIDxjOHktc3RlcHBlci1idXR0b25zXG4gICAqICAgW2xhYmVsc109XCJ7IGN1c3RvbTogJ0N1c3RvbSBidG4nLCBjYW5jZWw6ICdDYW5jZWwgYnRuJyB9XCJcbiAgICogICBbc2hvd0J1dHRvbnNdPVwieyBjdXN0b206IHRydWUsIGNhbmNlbDogdHJ1ZSB9XCJcbiAgICogPjwvYzh5LXN0ZXBwZXItYnV0dG9ucz5cbiAgICpcbiAgICogYGBgXG4gICAqL1xuICBASW5wdXQoKSBzZXQgc2hvd0J1dHRvbnMoYnRuczogU3RlcHBlckJ1dHRvbnNWaXNpYmlsaXR5KSB7XG4gICAgaWYgKGJ0bnMpIHtcbiAgICAgIHRoaXMuc2hvd0J0bnMgPSBidG5zO1xuICAgICAgdGhpcy5mb3JjZVNob3dCdG5zID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIGlmICghdGhpcy5mb3JjZVNob3dCdG5zKSB7XG4gICAgICB0aGlzLnNob3dCdG5zLmNhbmNlbCA9IHRoaXMub25DYW5jZWwub2JzZXJ2ZXJzLmxlbmd0aCA+IDA7XG4gICAgICB0aGlzLnNob3dCdG5zLmN1c3RvbSA9IHRoaXMub25DdXN0b20ub2JzZXJ2ZXJzLmxlbmd0aCA+IDA7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3RlcHBlciAmJiB0aGlzLnN0ZXBwZXIuX3N0ZXBzICYmIHRoaXMuc3RlcCAmJiAhdGhpcy5mb3JjZVNob3dCdG5zKSB7XG4gICAgICB0aGlzLnNob3dCdG5zLmJhY2sgPSB0aGlzLnN0ZXBwZXIuX3N0ZXBzLmZpcnN0ICE9PSB0aGlzLnN0ZXA7XG4gICAgICB0aGlzLnNob3dCdG5zLm5leHQgPSB0aGlzLnN0ZXBwZXIuX3N0ZXBzLmxhc3QgIT09IHRoaXMuc3RlcDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdGVwICYmIHRoaXMuc3RlcC5zdGVwQ29udHJvbCkge1xuICAgICAgdGhpcy5kaXNhYmxlZCA9IHRoaXMuc3RlcC5zdGVwQ29udHJvbC5pbnZhbGlkO1xuXG4gICAgICB0aGlzLnN0YXR1c0NoYW5nZVN1YnNjcmlwdGlvbiA9IHRoaXMuc3RlcC5zdGVwQ29udHJvbC5zdGF0dXNDaGFuZ2VzLnN1YnNjcmliZShzdGF0dXMgPT4ge1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gdGhpcy5zdGVwLnN0ZXBDb250cm9sLmludmFsaWQ7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgIC8qKlxuICAgICAqIERpc2FibGUgc2F2ZS9uZXh0IGJ1dHRvbiB3aGlsZSB0aGUgc3RhdHVzIGlzIHBlbmRpbmdcbiAgICAgKiBUaGlzIHdpbGwgcHJldmVudCBtdWx0aXBsZSBjbGlja3MgYW5kIHRoZXJlZm9yZSBtdWx0aXBsZSByZXF1ZXN0c1xuICAgICAqL1xuICAgIGlmIChjaGFuZ2VzICYmIGNoYW5nZXMucGVuZGluZykge1xuICAgICAgdGhpcy5kaXNhYmxlZCA9IGNoYW5nZXMucGVuZGluZy5jdXJyZW50VmFsdWU7XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzQ2hhbmdlU3Vic2NyaXB0aW9uICYmICF0aGlzLnN0YXR1c0NoYW5nZVN1YnNjcmlwdGlvbi5jbG9zZWQpIHtcbiAgICAgIHRoaXMuc3RhdHVzQ2hhbmdlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gY2FuY2VsIGJ1dHRvbiBpcyBjbGlja2VkLlxuICAgKiBJdCB3aWxsIGVtaXQgaW1tZWRpYXRlLlxuICAgKi9cbiAgY2FuY2VsKCkge1xuICAgIHRoaXMub25DYW5jZWwuZW1pdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gbmV4dCBidXR0b24gaXMgY2xpY2tlZC4gV2hlbiBvbk5leHQgRXZlbnRFbWl0dGVyIGhhcyBhbiBvYnNlcnZlciByZWdpc3RlcmVkXG4gICAqIGl0IHdpbGwgZW1pdCB0aGUgZm9sbG93aW5nIG9iamVjdCB7c3RlcHBlcjogQzh5U3RlcHBlcjsgc3RlcDogQ2RrU3RlcH0uXG4gICAqIE90aGVyd2lzZSBpdCB3aWxsIGNhbGwgc3RlcHBlci5uZXh0KCkgYXMgZGVmYXVsdC5cbiAgICovXG4gIG5leHQoKSB7XG4gICAgaWYgKHRoaXMub25OZXh0Lm9ic2VydmVycy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLm9uTmV4dC5lbWl0KHsgc3RlcHBlcjogdGhpcy5zdGVwcGVyLCBzdGVwOiB0aGlzLnN0ZXAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RlcHBlci5uZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gYmFjayBidXR0b24gaXMgY2xpY2tlZC4gV2hlbiBvbkJhY2sgRXZlbnRFbWl0dGVyIGhhcyBhbiBvYnNlcnZlciByZWdpc3RlcmVkXG4gICAqIGl0IHdpbGwgZW1pdCB0aGUgZm9sbG93aW5nIG9iamVjdCB7c3RlcHBlcjogQzh5U3RlcHBlcjsgc3RlcDogQ2RrU3RlcH0uXG4gICAqIE90aGVyd2lzZSBpdCB3aWxsIGNhbGwgc3RlcHBlci5wcmV2aW91cygpIGFzIGRlZmF1bHQuXG4gICAqL1xuICBiYWNrKCkge1xuICAgIHRoaXMuc3RlcHBlci5zZWxlY3RlZC5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5vbkJhY2sub2JzZXJ2ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMub25CYWNrLmVtaXQoeyBzdGVwcGVyOiB0aGlzLnN0ZXBwZXIsIHN0ZXA6IHRoaXMuc3RlcCB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGVwcGVyLnByZXZpb3VzKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIGN1c3RvbSBidXR0b24gaXMgY2xpY2tlZC5cbiAgICogSXQgd2lsbCBlbWl0IGltbWVkaWF0ZWx5LlxuICAgKi9cbiAgY3VzdG9tKCkge1xuICAgIHRoaXMub25DdXN0b20uZW1pdCgpO1xuICB9XG59XG4iXX0=