import { Injectable } from '@angular/core';
import { MeasurementService } from '@c8y/client';
import { from, merge } from 'rxjs';
import { filter, map, switchMap } from 'rxjs/operators';
import { RealtimeSubjectService } from './realtime-subject.service';
import { RealtimeService } from './realtime.service';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './realtime-subject.service';
import * as ɵngcc2 from '@c8y/client';
export class MeasurementRealtimeService extends RealtimeService {
    constructor(realtimeSubject, measurementService) {
        super(realtimeSubject);
        this.realtimeSubject = realtimeSubject;
        this.measurementService = measurementService;
    }
    /**
     * Get an Observable of all measurements filtered by fragment and series.
     *
     * @param {string} fragment Measurement fragment
     *
     * @param {string} series Measurement series
     *
     * @param {string | number | IIdentified} entityOrId Entity object or id
     *
     * @returns An [[Observable]] of newly created entity objects.
     */
    onCreateOfSpecificMeasurement$(fragment, series, entityOrId) {
        return this.onCreate$(entityOrId).pipe(filter(msg => msg[fragment] && msg[fragment][series]));
    }
    /**
     * Get an Observable of all measurements filtered by fragment and series.
     * Combines the latest value from measurement API and future values via realtime API.
     *
     * @param {string} fragment Measurement fragment
     *
     * @param {string} series Measurement series
     *
     * @param {string | number | IIdentified} entityOrId Entity object or id
     *
     * @param {number} pageSize Number of measurements to initially retrieve from backend
     *
     * @param {boolean} emitNullIfInitialValuesWereNotFound Flag that if set to true will initially emit value of null in case no measurement could have been retrieved from backend
     *
     * @returns An [[Observable]] of newly created entity objects.
     */
    latestValueOfSpecificMeasurement$(fragment, series, entityOrId, pageSize = 1, emitNullIfInitialValuesWereNotFound = false) {
        const realtime$ = this.onCreateOfSpecificMeasurement$(fragment, series, entityOrId);
        const lastMeasurement$ = this.lastMeasurement$(fragment, series, entityOrId, pageSize, emitNullIfInitialValuesWereNotFound);
        return merge(lastMeasurement$, realtime$);
    }
    lastMeasurement$(fragment, series, entityOrId, pageSize, emitNullIfInitialValuesWereNotFound = false) {
        return from(this.measurementService.list({
            valueFragmentSeries: series,
            valueFragmentType: fragment,
            source: this.getIdString(entityOrId),
            dateFrom: '1970-01-01',
            revert: true,
            pageSize
        })).pipe(
        // emit null in case no value could have been retrieved so we are able to note that in certain cases.
        map(result => !emitNullIfInitialValuesWereNotFound || result.data.length ? result.data : [null]), 
        // reverse required, so that measurements are received ordered by time (ascending).
        // from ensures values are sent as single measurements and not a measurement array.
        switchMap(result => from(result.reverse())));
    }
    channel() {
        return '/measurements/*';
    }
}
MeasurementRealtimeService.ɵfac = function MeasurementRealtimeService_Factory(t) { return new (t || MeasurementRealtimeService)(ɵngcc0.ɵɵinject(ɵngcc1.RealtimeSubjectService), ɵngcc0.ɵɵinject(ɵngcc2.MeasurementService)); };
MeasurementRealtimeService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: MeasurementRealtimeService, factory: MeasurementRealtimeService.ɵfac });
MeasurementRealtimeService.ctorParameters = () => [
    { type: RealtimeSubjectService },
    { type: MeasurementService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MeasurementRealtimeService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.RealtimeSubjectService }, { type: ɵngcc2.MeasurementService }]; }, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWVhc3VyZW1lbnQtcmVhbHRpbWUuc2VydmljZS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vY29yZS9yZWFsdGltZS9tZWFzdXJlbWVudC1yZWFsdGltZS5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUE2QixrQkFBa0IsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUM1RSxPQUFPLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBYyxNQUFNLE1BQU0sQ0FBQztBQUMvQyxPQUFPLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUN4RCxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUNwRSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sb0JBQW9CLENBQUM7Ozs7QUFHckQsTUFBTSxPQUFPLDBCQUEyQixTQUFRLGVBQTZCO0FBQzdFLElBQUUsWUFDWSxlQUF1QyxFQUN2QyxrQkFBc0M7QUFDakQsUUFDQyxLQUFLLENBQUMsZUFBZSxDQUFDLENBQUM7QUFDM0IsUUFKYyxvQkFBZSxHQUFmLGVBQWUsQ0FBd0I7QUFBQyxRQUN4Qyx1QkFBa0IsR0FBbEIsa0JBQWtCLENBQW9CO0FBQ3BELElBRUUsQ0FBQztBQUNILElBQ0U7QUFDRjtBQUNFO0FBQ0U7QUFFSDtBQUFPO0FBRUg7QUFBTztBQUVIO0FBQU87QUFFSixPQURQO0FBQ0wsSUFBRSw4QkFBOEIsQ0FDNUIsUUFBZ0IsRUFDaEIsTUFBYyxFQUNkLFVBQTBDO0FBQzNDLFFBQ0MsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLElBQUksR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNsRyxJQUFFLENBQUM7QUFDSCxJQUNFO0FBQ0Y7QUFDRTtBQUNFO0FBQ0U7QUFFSDtBQUFPO0FBRUg7QUFBTztBQUVIO0FBQU87QUFFSDtBQUFPO0FBRUg7QUFBTztBQUVKLE9BRGpCO0FBQ0wsSUFBRSxpQ0FBaUMsQ0FDL0IsUUFBZ0IsRUFDaEIsTUFBYyxFQUNkLFVBQXlDLEVBQ3pDLFFBQVEsR0FBRyxDQUFDLEVBQ1osbUNBQW1DLEdBQUcsS0FBSztBQUM1QyxRQUNDLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyw4QkFBOEIsQ0FBQyxRQUFRLEVBQUUsTUFBTSxFQUFFLFVBQVUsQ0FBQyxDQUFDO0FBQ3hGLFFBQUksTUFBTSxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQzVDLFFBQVEsRUFDUixNQUFNLEVBQ04sVUFBVSxFQUNWLFFBQVEsRUFDUixtQ0FBbUMsQ0FDcEMsQ0FBQztBQUNOLFFBQUksT0FBTyxLQUFLLENBQUMsZ0JBQWdCLEVBQUUsU0FBUyxDQUFDLENBQUM7QUFDOUMsSUFBRSxDQUFDO0FBQ0gsSUFDWSxnQkFBZ0IsQ0FDeEIsUUFBZ0IsRUFDaEIsTUFBYyxFQUNkLFVBQXlDLEVBQ3pDLFFBQWdCLEVBQ2hCLG1DQUFtQyxHQUFHLEtBQUs7QUFDNUMsUUFDQyxPQUFPLElBQUksQ0FDVCxJQUFJLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDO0FBQ25DLFlBQVEsbUJBQW1CLEVBQUUsTUFBTTtBQUNuQyxZQUFRLGlCQUFpQixFQUFFLFFBQVE7QUFDbkMsWUFBUSxNQUFNLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUM7QUFDNUMsWUFBUSxRQUFRLEVBQUUsWUFBWTtBQUM5QixZQUFRLE1BQU0sRUFBRSxJQUFJO0FBQ3BCLFlBQVEsUUFBUTtBQUNoQixTQUFPLENBQUMsQ0FDSCxDQUFDLElBQUk7QUFDVixRQUFNLHFHQUFxRztBQUMzRyxRQUFNLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUNYLENBQUMsbUNBQW1DLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQ2xGO0FBQ04sUUFBSyxtRkFBbUY7QUFDekYsUUFBTSxtRkFBbUY7QUFDekYsUUFBTSxTQUFTLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FDNUMsQ0FBQztBQUNOLElBQUUsQ0FBQztBQUNILElBQ1ksT0FBTztBQUFLLFFBQ3BCLE9BQU8saUJBQWlCLENBQUM7QUFDN0IsSUFBRSxDQUFDO0FBQ0g7c0RBNUZDLFVBQVU7NEpBQ1Q7QUFBQztBQUFvRCxZQUo5QyxzQkFBc0I7QUFBSSxZQUhDLGtCQUFrQjtBQUFHOzs7NEhBQUU7QUFBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElJZGVudGlmaWVkLCBJTWVhc3VyZW1lbnQsIE1lYXN1cmVtZW50U2VydmljZSB9IGZyb20gJ0BjOHkvY2xpZW50JztcbmltcG9ydCB7IGZyb20sIG1lcmdlLCBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBmaWx0ZXIsIG1hcCwgc3dpdGNoTWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgUmVhbHRpbWVTdWJqZWN0U2VydmljZSB9IGZyb20gJy4vcmVhbHRpbWUtc3ViamVjdC5zZXJ2aWNlJztcbmltcG9ydCB7IFJlYWx0aW1lU2VydmljZSB9IGZyb20gJy4vcmVhbHRpbWUuc2VydmljZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBNZWFzdXJlbWVudFJlYWx0aW1lU2VydmljZSBleHRlbmRzIFJlYWx0aW1lU2VydmljZTxJTWVhc3VyZW1lbnQ+IHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJvdGVjdGVkIHJlYWx0aW1lU3ViamVjdDogUmVhbHRpbWVTdWJqZWN0U2VydmljZSxcbiAgICBwcm90ZWN0ZWQgbWVhc3VyZW1lbnRTZXJ2aWNlOiBNZWFzdXJlbWVudFNlcnZpY2VcbiAgKSB7XG4gICAgc3VwZXIocmVhbHRpbWVTdWJqZWN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gT2JzZXJ2YWJsZSBvZiBhbGwgbWVhc3VyZW1lbnRzIGZpbHRlcmVkIGJ5IGZyYWdtZW50IGFuZCBzZXJpZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmcmFnbWVudCBNZWFzdXJlbWVudCBmcmFnbWVudFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VyaWVzIE1lYXN1cmVtZW50IHNlcmllc1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlciB8IElJZGVudGlmaWVkfSBlbnRpdHlPcklkIEVudGl0eSBvYmplY3Qgb3IgaWRcbiAgICpcbiAgICogQHJldHVybnMgQW4gW1tPYnNlcnZhYmxlXV0gb2YgbmV3bHkgY3JlYXRlZCBlbnRpdHkgb2JqZWN0cy5cbiAgICovXG4gIG9uQ3JlYXRlT2ZTcGVjaWZpY01lYXN1cmVtZW50JChcbiAgICBmcmFnbWVudDogc3RyaW5nLFxuICAgIHNlcmllczogc3RyaW5nLFxuICAgIGVudGl0eU9ySWQ/OiBzdHJpbmcgfCBudW1iZXIgfCBJSWRlbnRpZmllZFxuICApOiBPYnNlcnZhYmxlPElNZWFzdXJlbWVudD4ge1xuICAgIHJldHVybiB0aGlzLm9uQ3JlYXRlJChlbnRpdHlPcklkKS5waXBlKGZpbHRlcihtc2cgPT4gbXNnW2ZyYWdtZW50XSAmJiBtc2dbZnJhZ21lbnRdW3Nlcmllc10pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gT2JzZXJ2YWJsZSBvZiBhbGwgbWVhc3VyZW1lbnRzIGZpbHRlcmVkIGJ5IGZyYWdtZW50IGFuZCBzZXJpZXMuXG4gICAqIENvbWJpbmVzIHRoZSBsYXRlc3QgdmFsdWUgZnJvbSBtZWFzdXJlbWVudCBBUEkgYW5kIGZ1dHVyZSB2YWx1ZXMgdmlhIHJlYWx0aW1lIEFQSS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZyYWdtZW50IE1lYXN1cmVtZW50IGZyYWdtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZXJpZXMgTWVhc3VyZW1lbnQgc2VyaWVzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyIHwgSUlkZW50aWZpZWR9IGVudGl0eU9ySWQgRW50aXR5IG9iamVjdCBvciBpZFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGFnZVNpemUgTnVtYmVyIG9mIG1lYXN1cmVtZW50cyB0byBpbml0aWFsbHkgcmV0cmlldmUgZnJvbSBiYWNrZW5kXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW1pdE51bGxJZkluaXRpYWxWYWx1ZXNXZXJlTm90Rm91bmQgRmxhZyB0aGF0IGlmIHNldCB0byB0cnVlIHdpbGwgaW5pdGlhbGx5IGVtaXQgdmFsdWUgb2YgbnVsbCBpbiBjYXNlIG5vIG1lYXN1cmVtZW50IGNvdWxkIGhhdmUgYmVlbiByZXRyaWV2ZWQgZnJvbSBiYWNrZW5kXG4gICAqXG4gICAqIEByZXR1cm5zIEFuIFtbT2JzZXJ2YWJsZV1dIG9mIG5ld2x5IGNyZWF0ZWQgZW50aXR5IG9iamVjdHMuXG4gICAqL1xuICBsYXRlc3RWYWx1ZU9mU3BlY2lmaWNNZWFzdXJlbWVudCQoXG4gICAgZnJhZ21lbnQ6IHN0cmluZyxcbiAgICBzZXJpZXM6IHN0cmluZyxcbiAgICBlbnRpdHlPcklkOiBzdHJpbmcgfCBudW1iZXIgfCBJSWRlbnRpZmllZCxcbiAgICBwYWdlU2l6ZSA9IDEsXG4gICAgZW1pdE51bGxJZkluaXRpYWxWYWx1ZXNXZXJlTm90Rm91bmQgPSBmYWxzZVxuICApIHtcbiAgICBjb25zdCByZWFsdGltZSQgPSB0aGlzLm9uQ3JlYXRlT2ZTcGVjaWZpY01lYXN1cmVtZW50JChmcmFnbWVudCwgc2VyaWVzLCBlbnRpdHlPcklkKTtcbiAgICBjb25zdCBsYXN0TWVhc3VyZW1lbnQkID0gdGhpcy5sYXN0TWVhc3VyZW1lbnQkKFxuICAgICAgZnJhZ21lbnQsXG4gICAgICBzZXJpZXMsXG4gICAgICBlbnRpdHlPcklkLFxuICAgICAgcGFnZVNpemUsXG4gICAgICBlbWl0TnVsbElmSW5pdGlhbFZhbHVlc1dlcmVOb3RGb3VuZFxuICAgICk7XG4gICAgcmV0dXJuIG1lcmdlKGxhc3RNZWFzdXJlbWVudCQsIHJlYWx0aW1lJCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgbGFzdE1lYXN1cmVtZW50JChcbiAgICBmcmFnbWVudDogc3RyaW5nLFxuICAgIHNlcmllczogc3RyaW5nLFxuICAgIGVudGl0eU9ySWQ6IHN0cmluZyB8IG51bWJlciB8IElJZGVudGlmaWVkLFxuICAgIHBhZ2VTaXplOiBudW1iZXIsXG4gICAgZW1pdE51bGxJZkluaXRpYWxWYWx1ZXNXZXJlTm90Rm91bmQgPSBmYWxzZVxuICApIHtcbiAgICByZXR1cm4gZnJvbShcbiAgICAgIHRoaXMubWVhc3VyZW1lbnRTZXJ2aWNlLmxpc3Qoe1xuICAgICAgICB2YWx1ZUZyYWdtZW50U2VyaWVzOiBzZXJpZXMsXG4gICAgICAgIHZhbHVlRnJhZ21lbnRUeXBlOiBmcmFnbWVudCxcbiAgICAgICAgc291cmNlOiB0aGlzLmdldElkU3RyaW5nKGVudGl0eU9ySWQpLFxuICAgICAgICBkYXRlRnJvbTogJzE5NzAtMDEtMDEnLFxuICAgICAgICByZXZlcnQ6IHRydWUsXG4gICAgICAgIHBhZ2VTaXplXG4gICAgICB9KVxuICAgICkucGlwZShcbiAgICAgIC8vIGVtaXQgbnVsbCBpbiBjYXNlIG5vIHZhbHVlIGNvdWxkIGhhdmUgYmVlbiByZXRyaWV2ZWQgc28gd2UgYXJlIGFibGUgdG8gbm90ZSB0aGF0IGluIGNlcnRhaW4gY2FzZXMuXG4gICAgICBtYXAocmVzdWx0ID0+XG4gICAgICAgICFlbWl0TnVsbElmSW5pdGlhbFZhbHVlc1dlcmVOb3RGb3VuZCB8fCByZXN1bHQuZGF0YS5sZW5ndGggPyByZXN1bHQuZGF0YSA6IFtudWxsXVxuICAgICAgKSxcbiAgICAgIC8vIHJldmVyc2UgcmVxdWlyZWQsIHNvIHRoYXQgbWVhc3VyZW1lbnRzIGFyZSByZWNlaXZlZCBvcmRlcmVkIGJ5IHRpbWUgKGFzY2VuZGluZykuXG4gICAgICAvLyBmcm9tIGVuc3VyZXMgdmFsdWVzIGFyZSBzZW50IGFzIHNpbmdsZSBtZWFzdXJlbWVudHMgYW5kIG5vdCBhIG1lYXN1cmVtZW50IGFycmF5LlxuICAgICAgc3dpdGNoTWFwKHJlc3VsdCA9PiBmcm9tKHJlc3VsdC5yZXZlcnNlKCkpKVxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgY2hhbm5lbCgpOiBzdHJpbmcge1xuICAgIHJldHVybiAnL21lYXN1cmVtZW50cy8qJztcbiAgfVxufVxuIl19