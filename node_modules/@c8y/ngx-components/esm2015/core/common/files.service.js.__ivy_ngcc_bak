import { __awaiter } from "tslib";
import { Injectable } from '@angular/core';
import { InventoryBinaryService, SystemOptionsService } from '@c8y/client';
import { every, first, flatten, get, isNaN, isUndefined, keys, map, uniq } from 'lodash-es';
import { saveAs } from 'file-saver';
import * as i0 from "@angular/core";
import * as i1 from "@c8y/client/lib/src/system-options/SystemOptionsService";
import * as i2 from "@c8y/client/lib/src/inventory/InventoryBinaryService";
export var GENERIC_FILE_TYPE;
(function (GENERIC_FILE_TYPE) {
    GENERIC_FILE_TYPE["ARCHIVE"] = "archive";
    GENERIC_FILE_TYPE["AUDIO"] = "audio";
    GENERIC_FILE_TYPE["CODE"] = "code";
    GENERIC_FILE_TYPE["EXCEL"] = "excel";
    GENERIC_FILE_TYPE["IMAGE"] = "image";
    GENERIC_FILE_TYPE["PDF"] = "pdf";
    GENERIC_FILE_TYPE["POWERPOINT"] = "powerpoint";
    GENERIC_FILE_TYPE["TEXT"] = "text";
    GENERIC_FILE_TYPE["VIDEO"] = "video";
    GENERIC_FILE_TYPE["WORD"] = "word";
    GENERIC_FILE_TYPE["EPL"] = "epl";
})(GENERIC_FILE_TYPE || (GENERIC_FILE_TYPE = {}));
export class FilesService {
    constructor(systemOptionsService, inventoryBinaryService) {
        this.systemOptionsService = systemOptionsService;
        this.inventoryBinaryService = inventoryBinaryService;
        this.DEFAULT_BYTES_LIMIT = 52428800;
        this.FILENAME_MAX_LENGTH = 128;
        this.fileTypeExtensionsMap = {
            [GENERIC_FILE_TYPE.ARCHIVE]: {
                exts: ['7z', 'apk', 'cab', 'gz', 'iso', 'jar', 'rar', 'tar', 'zip']
            },
            [GENERIC_FILE_TYPE.AUDIO]: {
                exts: ['3gp', 'aiff', 'aac', 'amr', 'm4a', 'm4p', 'mp3', 'oga', 'ogg', 'raw', 'wav', 'wma']
            },
            [GENERIC_FILE_TYPE.CODE]: {
                exts: ['aspx', 'exe', 'htm', 'html', 'jad', 'js', 'json', 'jsp', 'php', 'xml']
            },
            [GENERIC_FILE_TYPE.EXCEL]: {
                exts: ['xls', 'xlsx']
            },
            [GENERIC_FILE_TYPE.IMAGE]: {
                exts: ['bmp', 'gif', 'jpeg', 'jpg', 'png', 'tiff', 'svg', 'ico']
            },
            [GENERIC_FILE_TYPE.PDF]: {
                exts: ['pdf']
            },
            [GENERIC_FILE_TYPE.POWERPOINT]: {
                exts: ['ppt', 'pptx']
            },
            [GENERIC_FILE_TYPE.TEXT]: {
                exts: ['txt']
            },
            [GENERIC_FILE_TYPE.VIDEO]: {
                exts: ['asf', 'avi', 'flv', 'mov', 'mp4', 'ogv', 'qt', 'rm', 'rmvb', 'wmv', '3gp']
            },
            [GENERIC_FILE_TYPE.WORD]: {
                exts: ['doc', 'docx']
            },
            [GENERIC_FILE_TYPE.EPL]: {
                exts: ['mon']
            }
        };
        this.fileSizeLimitCfg = {
            systemOption: {
                category: 'files',
                key: 'max.size'
            },
            defaultBytesLimit: this.DEFAULT_BYTES_LIMIT,
            actualBytesLimit: undefined
        };
    }
    /**
     * Checks if files have valid size.
     * @param files Files to check.
     * @returns Returns true if each file has the correct size.
     */
    haveValidSizes(files) {
        return __awaiter(this, void 0, void 0, function* () {
            const limit = yield this.loadBytesSizeLimit();
            return every(files, (f) => {
                return this.size(f) <= limit;
            });
        });
    }
    /**
     * Checks the system file size limit, if not available returns the default value.
     * Default limit: [DEFAULT_BYTES_LIMIT]{@link DEFAULT_BYTES_LIMIT}
     * @returns Returns promise with the limit value.
     */
    loadBytesSizeLimit() {
        return __awaiter(this, void 0, void 0, function* () {
            let bytesLimit = this.DEFAULT_BYTES_LIMIT;
            if (this.fileSizeLimitCfg.actualBytesLimit) {
                return this.fileSizeLimitCfg.actualBytesLimit;
            }
            const { systemOption } = this.fileSizeLimitCfg;
            try {
                const { data: { value: actualBytesLimit } } = yield this.systemOptionsService.detail(systemOption);
                if (!actualBytesLimit) {
                    return bytesLimit;
                }
                const parsedActualBytesLimit = parseInt(actualBytesLimit, 10);
                if (isNaN(parsedActualBytesLimit)) {
                    return bytesLimit;
                }
                this.fileSizeLimitCfg.actualBytesLimit = parsedActualBytesLimit;
                bytesLimit = parsedActualBytesLimit;
            }
            catch (error) {
                // do nothing
            }
            return bytesLimit;
        });
    }
    /**
     * Checks the size of the file
     * @param file File to check.
     * @returns Returns size of the file in bytes.
     */
    size(file) {
        const fileLength = get(file, 'length') || get(file, 'size');
        const attachments = get(file, '_attachments');
        const attachmentsObj = get(attachments, first(keys(attachments)));
        return isUndefined(fileLength) ? get(attachmentsObj, 'length') : fileLength;
    }
    /**
     * Checks whether files have allowed extensions.
     * If the accept parameter is not specified, all extensions are accepted.
     * @param files Files to check.
     * @param accept String of comma separated file extensions and generic types ([GENERIC_FILE_TYPE]{@link GENERIC_FILE_TYPE}), e.g. .zip,.7z,excel.
     * @returns  Returns true if each file has allowed extension.
     */
    haveValidExtensions(files, accept) {
        if (!accept) {
            return true;
        }
        const filesArray = files.item
            ? Array.from(files)
            : Array.isArray(files)
                ? files
                : [files];
        const filesExts = filesArray.map((file) => { var _a; return (_a = this.getFileExtension(file)) === null || _a === void 0 ? void 0 : _a.toLowerCase(); });
        const allowedExts = this.extractFileExtensions(accept);
        return filesExts.every(ext => allowedExts.includes(ext));
    }
    /**
     * Checks if each file has a valid filename length.
     * @param files Files to check.
     * @returns Returns true if each file has a valid filename length.
     */
    checkMaxLength(files) {
        return every(files, (f) => {
            return this.FILENAME_MAX_LENGTH > f.name.length;
        });
    }
    /**
     * Extracts the file extension.
     * @param file File from which the extension should be extracted.
     * @returns Returns the file extension or undefined if the file has no extension.
     */
    getFileExtension(file) {
        const fileNameAndFileExt = file.name.split('.');
        if (fileNameAndFileExt.length === 1) {
            // no file ext
            return undefined;
        }
        return fileNameAndFileExt.pop();
    }
    /**
     * List of file extensions.
     * @returns Returns list of file extensions.
     */
    getFileExtensions() {
        return uniq(flatten(map(this.fileTypeExtensionsMap, ({ exts }) => exts)));
    }
    /**
     * The list of generic file types.
     * @returns Returns the list of generic file types.
     */
    getGenericFileTypes() {
        return Object.keys(this.fileTypeExtensionsMap);
    }
    /**
     * @ignore
     */
    mapGenericFileTypesToExtensions(genericFileTypes = []) {
        const fileExts = genericFileTypes.map(gT => {
            const { exts } = this.fileTypeExtensionsMap[gT];
            return exts;
        });
        return uniq(flatten(fileExts));
    }
    /**
     * Extracts a list of file extensions from a string.
     * Can accept generic file types check: [GENERIC_FILE_TYPE]{@link GENERIC_FILE_TYPE}.
     *
     * @param str String from which the file extensions are extracted (comma separated values).
     * Accepted string format:
     * * ".zip,.iso",
     * * "zip,ISO",
     * * "archive".
     * Important: generic types cannot contain a dot. All values with a dot are treated as a normal extension.
     * @returns Returns a list of the file extensions.
     */
    extractFileExtensions(str) {
        if (!str) {
            return [];
        }
        const types = str.split(',').map(t => t.toLowerCase().trim());
        const genericTypes = types.filter((t) => this.isGenericType(t));
        const defaultFileExts = types.filter((t) => !this.isGenericType(t));
        const allTypes = [
            ...this.mapGenericFileTypesToExtensions(genericTypes),
            ...defaultFileExts
        ].map(t => t.replace('.', ''));
        return uniq(allTypes);
    }
    /**
     * Converts a file to a base64 image string.
     *
     * @param file The file to convert to base 64.
     * @returns The image string in base64 format.
     */
    toBase64(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = () => resolve(reader.result);
            reader.onerror = error => reject(error);
        });
    }
    /**
     * Allows to get a File representation of an managed object binary. Can be used
     * to convert this file toBase64 to show it to the end-user.
     * @param binary The binary managed object
     * @returns The file representation.
     */
    getFile(binary) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.inventoryBinaryService.download(binary.id);
            const arrayBuffer = yield res.arrayBuffer();
            return new File([arrayBuffer], binary.name, { type: binary.contentType });
        });
    }
    /**
     * Allows to download a file (opens the browser download prompt).
     * @param binary The binary managed object.
     */
    download(binary) {
        return __awaiter(this, void 0, void 0, function* () {
            const file = yield this.getFile(binary);
            saveAs(file);
        });
    }
    isGenericType(type) {
        return Object.values(GENERIC_FILE_TYPE).includes(type);
    }
}
FilesService.ɵprov = i0.ɵɵdefineInjectable({ factory: function FilesService_Factory() { return new FilesService(i0.ɵɵinject(i1.SystemOptionsService), i0.ɵɵinject(i2.InventoryBinaryService)); }, token: FilesService, providedIn: "root" });
FilesService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
FilesService.ctorParameters = () => [
    { type: SystemOptionsService },
    { type: InventoryBinaryService }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZXMuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2NvcmUvY29tbW9uL2ZpbGVzLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUF3QixzQkFBc0IsRUFBRSxvQkFBb0IsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUNqRyxPQUFPLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxXQUFXLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFDNUYsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLFlBQVksQ0FBQzs7OztBQUVwQyxNQUFNLENBQU4sSUFBWSxpQkFZWDtBQVpELFdBQVksaUJBQWlCO0lBQzNCLHdDQUFtQixDQUFBO0lBQ25CLG9DQUFlLENBQUE7SUFDZixrQ0FBYSxDQUFBO0lBQ2Isb0NBQWUsQ0FBQTtJQUNmLG9DQUFlLENBQUE7SUFDZixnQ0FBVyxDQUFBO0lBQ1gsOENBQXlCLENBQUE7SUFDekIsa0NBQWEsQ0FBQTtJQUNiLG9DQUFlLENBQUE7SUFDZixrQ0FBYSxDQUFBO0lBQ2IsZ0NBQVcsQ0FBQTtBQUNiLENBQUMsRUFaVyxpQkFBaUIsS0FBakIsaUJBQWlCLFFBWTVCO0FBRUQsTUFBTSxPQUFPLFlBQVk7SUFpRHZCLFlBQ1Usb0JBQTBDLEVBQzFDLHNCQUE4QztRQUQ5Qyx5QkFBb0IsR0FBcEIsb0JBQW9CLENBQXNCO1FBQzFDLDJCQUFzQixHQUF0QixzQkFBc0IsQ0FBd0I7UUFsRC9DLHdCQUFtQixHQUFHLFFBQVEsQ0FBQztRQUMvQix3QkFBbUIsR0FBRyxHQUFHLENBQUM7UUFFbkMsMEJBQXFCLEdBQTBDO1lBQzdELENBQUMsaUJBQWlCLENBQUMsT0FBTyxDQUFDLEVBQUU7Z0JBQzNCLElBQUksRUFBRSxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDO2FBQ3BFO1lBQ0QsQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsRUFBRTtnQkFDekIsSUFBSSxFQUFFLENBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUM7YUFDNUY7WUFDRCxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUN4QixJQUFJLEVBQUUsQ0FBQyxNQUFNLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUM7YUFDL0U7WUFDRCxDQUFDLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxFQUFFO2dCQUN6QixJQUFJLEVBQUUsQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDO2FBQ3RCO1lBQ0QsQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsRUFBRTtnQkFDekIsSUFBSSxFQUFFLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLEtBQUssQ0FBQzthQUNqRTtZQUNELENBQUMsaUJBQWlCLENBQUMsR0FBRyxDQUFDLEVBQUU7Z0JBQ3ZCLElBQUksRUFBRSxDQUFDLEtBQUssQ0FBQzthQUNkO1lBQ0QsQ0FBQyxpQkFBaUIsQ0FBQyxVQUFVLENBQUMsRUFBRTtnQkFDOUIsSUFBSSxFQUFFLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQzthQUN0QjtZQUNELENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLEVBQUU7Z0JBQ3hCLElBQUksRUFBRSxDQUFDLEtBQUssQ0FBQzthQUNkO1lBQ0QsQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsRUFBRTtnQkFDekIsSUFBSSxFQUFFLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLEtBQUssQ0FBQzthQUNuRjtZQUNELENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLEVBQUU7Z0JBQ3hCLElBQUksRUFBRSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUM7YUFDdEI7WUFDRCxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxFQUFFO2dCQUN2QixJQUFJLEVBQUUsQ0FBQyxLQUFLLENBQUM7YUFDZDtTQUNGLENBQUM7UUFFTSxxQkFBZ0IsR0FBRztZQUN6QixZQUFZLEVBQUU7Z0JBQ1osUUFBUSxFQUFFLE9BQU87Z0JBQ2pCLEdBQUcsRUFBRSxVQUFVO2FBQ2hCO1lBQ0QsaUJBQWlCLEVBQUUsSUFBSSxDQUFDLG1CQUFtQjtZQUMzQyxnQkFBZ0IsRUFBRSxTQUFTO1NBQzVCLENBQUM7SUFLQyxDQUFDO0lBRUo7Ozs7T0FJRztJQUNHLGNBQWMsQ0FBQyxLQUFlOztZQUNsQyxNQUFNLEtBQUssR0FBRyxNQUFNLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1lBRTlDLE9BQU8sS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQU8sRUFBRSxFQUFFO2dCQUM5QixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDO1lBQy9CLENBQUMsQ0FBQyxDQUFDO1FBQ0wsQ0FBQztLQUFBO0lBRUQ7Ozs7T0FJRztJQUNHLGtCQUFrQjs7WUFDdEIsSUFBSSxVQUFVLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixDQUFDO1lBQzFDLElBQUksSUFBSSxDQUFDLGdCQUFnQixDQUFDLGdCQUFnQixFQUFFO2dCQUMxQyxPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxnQkFBZ0IsQ0FBQzthQUMvQztZQUNELE1BQU0sRUFBRSxZQUFZLEVBQUUsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUM7WUFFL0MsSUFBSTtnQkFDRixNQUFNLEVBQ0osSUFBSSxFQUFFLEVBQUUsS0FBSyxFQUFFLGdCQUFnQixFQUFFLEVBQ2xDLEdBQUcsTUFBTSxJQUFJLENBQUMsb0JBQW9CLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDO2dCQUV6RCxJQUFJLENBQUMsZ0JBQWdCLEVBQUU7b0JBQ3JCLE9BQU8sVUFBVSxDQUFDO2lCQUNuQjtnQkFFRCxNQUFNLHNCQUFzQixHQUFHLFFBQVEsQ0FBQyxnQkFBZ0IsRUFBRSxFQUFFLENBQUMsQ0FBQztnQkFDOUQsSUFBSSxLQUFLLENBQUMsc0JBQXNCLENBQUMsRUFBRTtvQkFDakMsT0FBTyxVQUFVLENBQUM7aUJBQ25CO2dCQUVELElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxnQkFBZ0IsR0FBRyxzQkFBc0IsQ0FBQztnQkFDaEUsVUFBVSxHQUFHLHNCQUFzQixDQUFDO2FBQ3JDO1lBQUMsT0FBTyxLQUFLLEVBQUU7Z0JBQ2QsYUFBYTthQUNkO1lBQ0QsT0FBTyxVQUFVLENBQUM7UUFDcEIsQ0FBQztLQUFBO0lBRUQ7Ozs7T0FJRztJQUNILElBQUksQ0FBQyxJQUFpQztRQUNwQyxNQUFNLFVBQVUsR0FBRyxHQUFHLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDNUQsTUFBTSxXQUFXLEdBQUcsR0FBRyxDQUFDLElBQUksRUFBRSxjQUFjLENBQUMsQ0FBQztRQUM5QyxNQUFNLGNBQWMsR0FBRyxHQUFHLENBQUMsV0FBVyxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2xFLE9BQU8sV0FBVyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsY0FBYyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUM7SUFDOUUsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILG1CQUFtQixDQUFDLEtBQStCLEVBQUUsTUFBYztRQUNqRSxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ1gsT0FBTyxJQUFJLENBQUM7U0FDYjtRQUNELE1BQU0sVUFBVSxHQUFJLEtBQWtCLENBQUMsSUFBSTtZQUN6QyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFpQixDQUFDO1lBQy9CLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQztnQkFDdEIsQ0FBQyxDQUFDLEtBQUs7Z0JBQ1AsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFWixNQUFNLFNBQVMsR0FBRyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBVSxFQUFFLEVBQUUsV0FBQyxPQUFBLE1BQUEsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQywwQ0FBRSxXQUFXLEVBQUUsQ0FBQSxFQUFBLENBQUMsQ0FBQztRQUM3RixNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMscUJBQXFCLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDdkQsT0FBTyxTQUFTLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQzNELENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsY0FBYyxDQUFDLEtBQWU7UUFDNUIsT0FBTyxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBTyxFQUFFLEVBQUU7WUFDOUIsT0FBTyxJQUFJLENBQUMsbUJBQW1CLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7UUFDbEQsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILGdCQUFnQixDQUFDLElBQVU7UUFDekIsTUFBTSxrQkFBa0IsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNoRCxJQUFJLGtCQUFrQixDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDbkMsY0FBYztZQUNkLE9BQU8sU0FBUyxDQUFDO1NBQ2xCO1FBQ0QsT0FBTyxrQkFBa0IsQ0FBQyxHQUFHLEVBQUUsQ0FBQztJQUNsQyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsaUJBQWlCO1FBQ2YsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMscUJBQXFCLEVBQUUsQ0FBQyxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDNUUsQ0FBQztJQUVEOzs7T0FHRztJQUNILG1CQUFtQjtRQUNqQixPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLHFCQUFxQixDQUF3QixDQUFDO0lBQ3hFLENBQUM7SUFFRDs7T0FFRztJQUNILCtCQUErQixDQUFDLG1CQUF3QyxFQUFFO1FBQ3hFLE1BQU0sUUFBUSxHQUFHLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRTtZQUN6QyxNQUFNLEVBQUUsSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLHFCQUFxQixDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ2hELE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQyxDQUFDLENBQUM7UUFFSCxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztJQUNqQyxDQUFDO0lBQ0Q7Ozs7Ozs7Ozs7O09BV0c7SUFDSCxxQkFBcUIsQ0FBQyxHQUFXO1FBQy9CLElBQUksQ0FBQyxHQUFHLEVBQUU7WUFDUixPQUFPLEVBQUUsQ0FBQztTQUNYO1FBQ0QsTUFBTSxLQUFLLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQztRQUU5RCxNQUFNLFlBQVksR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBUyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDeEUsTUFBTSxlQUFlLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQVMsRUFBRSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFNUUsTUFBTSxRQUFRLEdBQUc7WUFDZixHQUFHLElBQUksQ0FBQywrQkFBK0IsQ0FBQyxZQUFtQyxDQUFDO1lBQzVFLEdBQUcsZUFBZTtTQUNuQixDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFFL0IsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDeEIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsUUFBUSxDQUFDLElBQVU7UUFDakIsT0FBTyxJQUFJLE9BQU8sQ0FBQyxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsRUFBRTtZQUNyQyxNQUFNLE1BQU0sR0FBRyxJQUFJLFVBQVUsRUFBRSxDQUFDO1lBQ2hDLE1BQU0sQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDM0IsTUFBTSxDQUFDLE1BQU0sR0FBRyxHQUFHLEVBQUUsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQzdDLE1BQU0sQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDMUMsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDRyxPQUFPLENBQUMsTUFBNEI7O1lBQ3hDLE1BQU0sR0FBRyxHQUFHLE1BQU0sSUFBSSxDQUFDLHNCQUFzQixDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDbEUsTUFBTSxXQUFXLEdBQUcsTUFBTSxHQUFHLENBQUMsV0FBVyxFQUFFLENBQUM7WUFDNUMsT0FBTyxJQUFJLElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxJQUFJLEVBQUUsRUFBRSxJQUFJLEVBQUUsTUFBTSxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUM7UUFDNUUsQ0FBQztLQUFBO0lBRUQ7OztPQUdHO0lBQ0csUUFBUSxDQUFDLE1BQTRCOztZQUN6QyxNQUFNLElBQUksR0FBRyxNQUFNLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDeEMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2YsQ0FBQztLQUFBO0lBRU8sYUFBYSxDQUFDLElBQVk7UUFDaEMsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDLGlCQUFpQixDQUFDLENBQUMsUUFBUSxDQUFDLElBQXlCLENBQUMsQ0FBQztJQUM5RSxDQUFDOzs7O1lBL1BGLFVBQVUsU0FBQyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUU7OztZQWpCcUIsb0JBQW9CO1lBQTVDLHNCQUFzQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElNYW5hZ2VkT2JqZWN0QmluYXJ5LCBJbnZlbnRvcnlCaW5hcnlTZXJ2aWNlLCBTeXN0ZW1PcHRpb25zU2VydmljZSB9IGZyb20gJ0BjOHkvY2xpZW50JztcbmltcG9ydCB7IGV2ZXJ5LCBmaXJzdCwgZmxhdHRlbiwgZ2V0LCBpc05hTiwgaXNVbmRlZmluZWQsIGtleXMsIG1hcCwgdW5pcSB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBzYXZlQXMgfSBmcm9tICdmaWxlLXNhdmVyJztcblxuZXhwb3J0IGVudW0gR0VORVJJQ19GSUxFX1RZUEUge1xuICBBUkNISVZFID0gJ2FyY2hpdmUnLFxuICBBVURJTyA9ICdhdWRpbycsXG4gIENPREUgPSAnY29kZScsXG4gIEVYQ0VMID0gJ2V4Y2VsJyxcbiAgSU1BR0UgPSAnaW1hZ2UnLFxuICBQREYgPSAncGRmJyxcbiAgUE9XRVJQT0lOVCA9ICdwb3dlcnBvaW50JyxcbiAgVEVYVCA9ICd0ZXh0JyxcbiAgVklERU8gPSAndmlkZW8nLFxuICBXT1JEID0gJ3dvcmQnLFxuICBFUEwgPSAnZXBsJ1xufVxuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBGaWxlc1NlcnZpY2Uge1xuICByZWFkb25seSBERUZBVUxUX0JZVEVTX0xJTUlUID0gNTI0Mjg4MDA7XG4gIHJlYWRvbmx5IEZJTEVOQU1FX01BWF9MRU5HVEggPSAxMjg7XG5cbiAgZmlsZVR5cGVFeHRlbnNpb25zTWFwOiB7IFtrZXk6IHN0cmluZ106IHsgZXh0czogc3RyaW5nW10gfSB9ID0ge1xuICAgIFtHRU5FUklDX0ZJTEVfVFlQRS5BUkNISVZFXToge1xuICAgICAgZXh0czogWyc3eicsICdhcGsnLCAnY2FiJywgJ2d6JywgJ2lzbycsICdqYXInLCAncmFyJywgJ3RhcicsICd6aXAnXVxuICAgIH0sXG4gICAgW0dFTkVSSUNfRklMRV9UWVBFLkFVRElPXToge1xuICAgICAgZXh0czogWyczZ3AnLCAnYWlmZicsICdhYWMnLCAnYW1yJywgJ200YScsICdtNHAnLCAnbXAzJywgJ29nYScsICdvZ2cnLCAncmF3JywgJ3dhdicsICd3bWEnXVxuICAgIH0sXG4gICAgW0dFTkVSSUNfRklMRV9UWVBFLkNPREVdOiB7XG4gICAgICBleHRzOiBbJ2FzcHgnLCAnZXhlJywgJ2h0bScsICdodG1sJywgJ2phZCcsICdqcycsICdqc29uJywgJ2pzcCcsICdwaHAnLCAneG1sJ11cbiAgICB9LFxuICAgIFtHRU5FUklDX0ZJTEVfVFlQRS5FWENFTF06IHtcbiAgICAgIGV4dHM6IFsneGxzJywgJ3hsc3gnXVxuICAgIH0sXG4gICAgW0dFTkVSSUNfRklMRV9UWVBFLklNQUdFXToge1xuICAgICAgZXh0czogWydibXAnLCAnZ2lmJywgJ2pwZWcnLCAnanBnJywgJ3BuZycsICd0aWZmJywgJ3N2ZycsICdpY28nXVxuICAgIH0sXG4gICAgW0dFTkVSSUNfRklMRV9UWVBFLlBERl06IHtcbiAgICAgIGV4dHM6IFsncGRmJ11cbiAgICB9LFxuICAgIFtHRU5FUklDX0ZJTEVfVFlQRS5QT1dFUlBPSU5UXToge1xuICAgICAgZXh0czogWydwcHQnLCAncHB0eCddXG4gICAgfSxcbiAgICBbR0VORVJJQ19GSUxFX1RZUEUuVEVYVF06IHtcbiAgICAgIGV4dHM6IFsndHh0J11cbiAgICB9LFxuICAgIFtHRU5FUklDX0ZJTEVfVFlQRS5WSURFT106IHtcbiAgICAgIGV4dHM6IFsnYXNmJywgJ2F2aScsICdmbHYnLCAnbW92JywgJ21wNCcsICdvZ3YnLCAncXQnLCAncm0nLCAncm12YicsICd3bXYnLCAnM2dwJ11cbiAgICB9LFxuICAgIFtHRU5FUklDX0ZJTEVfVFlQRS5XT1JEXToge1xuICAgICAgZXh0czogWydkb2MnLCAnZG9jeCddXG4gICAgfSxcbiAgICBbR0VORVJJQ19GSUxFX1RZUEUuRVBMXToge1xuICAgICAgZXh0czogWydtb24nXVxuICAgIH1cbiAgfTtcblxuICBwcml2YXRlIGZpbGVTaXplTGltaXRDZmcgPSB7XG4gICAgc3lzdGVtT3B0aW9uOiB7XG4gICAgICBjYXRlZ29yeTogJ2ZpbGVzJyxcbiAgICAgIGtleTogJ21heC5zaXplJ1xuICAgIH0sXG4gICAgZGVmYXVsdEJ5dGVzTGltaXQ6IHRoaXMuREVGQVVMVF9CWVRFU19MSU1JVCxcbiAgICBhY3R1YWxCeXRlc0xpbWl0OiB1bmRlZmluZWRcbiAgfTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHN5c3RlbU9wdGlvbnNTZXJ2aWNlOiBTeXN0ZW1PcHRpb25zU2VydmljZSxcbiAgICBwcml2YXRlIGludmVudG9yeUJpbmFyeVNlcnZpY2U6IEludmVudG9yeUJpbmFyeVNlcnZpY2VcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgZmlsZXMgaGF2ZSB2YWxpZCBzaXplLlxuICAgKiBAcGFyYW0gZmlsZXMgRmlsZXMgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIFJldHVybnMgdHJ1ZSBpZiBlYWNoIGZpbGUgaGFzIHRoZSBjb3JyZWN0IHNpemUuXG4gICAqL1xuICBhc3luYyBoYXZlVmFsaWRTaXplcyhmaWxlczogRmlsZUxpc3QpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBsaW1pdCA9IGF3YWl0IHRoaXMubG9hZEJ5dGVzU2l6ZUxpbWl0KCk7XG5cbiAgICByZXR1cm4gZXZlcnkoZmlsZXMsIChmOiBGaWxlKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5zaXplKGYpIDw9IGxpbWl0O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB0aGUgc3lzdGVtIGZpbGUgc2l6ZSBsaW1pdCwgaWYgbm90IGF2YWlsYWJsZSByZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlLlxuICAgKiBEZWZhdWx0IGxpbWl0OiBbREVGQVVMVF9CWVRFU19MSU1JVF17QGxpbmsgREVGQVVMVF9CWVRFU19MSU1JVH1cbiAgICogQHJldHVybnMgUmV0dXJucyBwcm9taXNlIHdpdGggdGhlIGxpbWl0IHZhbHVlLlxuICAgKi9cbiAgYXN5bmMgbG9hZEJ5dGVzU2l6ZUxpbWl0KCk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgbGV0IGJ5dGVzTGltaXQgPSB0aGlzLkRFRkFVTFRfQllURVNfTElNSVQ7XG4gICAgaWYgKHRoaXMuZmlsZVNpemVMaW1pdENmZy5hY3R1YWxCeXRlc0xpbWl0KSB7XG4gICAgICByZXR1cm4gdGhpcy5maWxlU2l6ZUxpbWl0Q2ZnLmFjdHVhbEJ5dGVzTGltaXQ7XG4gICAgfVxuICAgIGNvbnN0IHsgc3lzdGVtT3B0aW9uIH0gPSB0aGlzLmZpbGVTaXplTGltaXRDZmc7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRhOiB7IHZhbHVlOiBhY3R1YWxCeXRlc0xpbWl0IH1cbiAgICAgIH0gPSBhd2FpdCB0aGlzLnN5c3RlbU9wdGlvbnNTZXJ2aWNlLmRldGFpbChzeXN0ZW1PcHRpb24pO1xuXG4gICAgICBpZiAoIWFjdHVhbEJ5dGVzTGltaXQpIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVzTGltaXQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhcnNlZEFjdHVhbEJ5dGVzTGltaXQgPSBwYXJzZUludChhY3R1YWxCeXRlc0xpbWl0LCAxMCk7XG4gICAgICBpZiAoaXNOYU4ocGFyc2VkQWN0dWFsQnl0ZXNMaW1pdCkpIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVzTGltaXQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZmlsZVNpemVMaW1pdENmZy5hY3R1YWxCeXRlc0xpbWl0ID0gcGFyc2VkQWN0dWFsQnl0ZXNMaW1pdDtcbiAgICAgIGJ5dGVzTGltaXQgPSBwYXJzZWRBY3R1YWxCeXRlc0xpbWl0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBkbyBub3RoaW5nXG4gICAgfVxuICAgIHJldHVybiBieXRlc0xpbWl0O1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB0aGUgc2l6ZSBvZiB0aGUgZmlsZVxuICAgKiBAcGFyYW0gZmlsZSBGaWxlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIHNpemUgb2YgdGhlIGZpbGUgaW4gYnl0ZXMuXG4gICAqL1xuICBzaXplKGZpbGU6IEZpbGUgfCBJTWFuYWdlZE9iamVjdEJpbmFyeSk6IG51bWJlciB7XG4gICAgY29uc3QgZmlsZUxlbmd0aCA9IGdldChmaWxlLCAnbGVuZ3RoJykgfHwgZ2V0KGZpbGUsICdzaXplJyk7XG4gICAgY29uc3QgYXR0YWNobWVudHMgPSBnZXQoZmlsZSwgJ19hdHRhY2htZW50cycpO1xuICAgIGNvbnN0IGF0dGFjaG1lbnRzT2JqID0gZ2V0KGF0dGFjaG1lbnRzLCBmaXJzdChrZXlzKGF0dGFjaG1lbnRzKSkpO1xuICAgIHJldHVybiBpc1VuZGVmaW5lZChmaWxlTGVuZ3RoKSA/IGdldChhdHRhY2htZW50c09iaiwgJ2xlbmd0aCcpIDogZmlsZUxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBmaWxlcyBoYXZlIGFsbG93ZWQgZXh0ZW5zaW9ucy5cbiAgICogSWYgdGhlIGFjY2VwdCBwYXJhbWV0ZXIgaXMgbm90IHNwZWNpZmllZCwgYWxsIGV4dGVuc2lvbnMgYXJlIGFjY2VwdGVkLlxuICAgKiBAcGFyYW0gZmlsZXMgRmlsZXMgdG8gY2hlY2suXG4gICAqIEBwYXJhbSBhY2NlcHQgU3RyaW5nIG9mIGNvbW1hIHNlcGFyYXRlZCBmaWxlIGV4dGVuc2lvbnMgYW5kIGdlbmVyaWMgdHlwZXMgKFtHRU5FUklDX0ZJTEVfVFlQRV17QGxpbmsgR0VORVJJQ19GSUxFX1RZUEV9KSwgZS5nLiAuemlwLC43eixleGNlbC5cbiAgICogQHJldHVybnMgIFJldHVybnMgdHJ1ZSBpZiBlYWNoIGZpbGUgaGFzIGFsbG93ZWQgZXh0ZW5zaW9uLlxuICAgKi9cbiAgaGF2ZVZhbGlkRXh0ZW5zaW9ucyhmaWxlczogRmlsZUxpc3QgfCBGaWxlIHwgRmlsZVtdLCBhY2NlcHQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGlmICghYWNjZXB0KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgZmlsZXNBcnJheSA9IChmaWxlcyBhcyBGaWxlTGlzdCkuaXRlbVxuICAgICAgPyBBcnJheS5mcm9tKGZpbGVzIGFzIEZpbGVMaXN0KVxuICAgICAgOiBBcnJheS5pc0FycmF5KGZpbGVzKVxuICAgICAgPyBmaWxlc1xuICAgICAgOiBbZmlsZXNdO1xuXG4gICAgY29uc3QgZmlsZXNFeHRzID0gZmlsZXNBcnJheS5tYXAoKGZpbGU6IEZpbGUpID0+IHRoaXMuZ2V0RmlsZUV4dGVuc2lvbihmaWxlKT8udG9Mb3dlckNhc2UoKSk7XG4gICAgY29uc3QgYWxsb3dlZEV4dHMgPSB0aGlzLmV4dHJhY3RGaWxlRXh0ZW5zaW9ucyhhY2NlcHQpO1xuICAgIHJldHVybiBmaWxlc0V4dHMuZXZlcnkoZXh0ID0+IGFsbG93ZWRFeHRzLmluY2x1ZGVzKGV4dCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBlYWNoIGZpbGUgaGFzIGEgdmFsaWQgZmlsZW5hbWUgbGVuZ3RoLlxuICAgKiBAcGFyYW0gZmlsZXMgRmlsZXMgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIFJldHVybnMgdHJ1ZSBpZiBlYWNoIGZpbGUgaGFzIGEgdmFsaWQgZmlsZW5hbWUgbGVuZ3RoLlxuICAgKi9cbiAgY2hlY2tNYXhMZW5ndGgoZmlsZXM6IEZpbGVMaXN0KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGV2ZXJ5KGZpbGVzLCAoZjogRmlsZSkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuRklMRU5BTUVfTUFYX0xFTkdUSCA+IGYubmFtZS5sZW5ndGg7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRXh0cmFjdHMgdGhlIGZpbGUgZXh0ZW5zaW9uLlxuICAgKiBAcGFyYW0gZmlsZSBGaWxlIGZyb20gd2hpY2ggdGhlIGV4dGVuc2lvbiBzaG91bGQgYmUgZXh0cmFjdGVkLlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIHRoZSBmaWxlIGV4dGVuc2lvbiBvciB1bmRlZmluZWQgaWYgdGhlIGZpbGUgaGFzIG5vIGV4dGVuc2lvbi5cbiAgICovXG4gIGdldEZpbGVFeHRlbnNpb24oZmlsZTogRmlsZSk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgZmlsZU5hbWVBbmRGaWxlRXh0ID0gZmlsZS5uYW1lLnNwbGl0KCcuJyk7XG4gICAgaWYgKGZpbGVOYW1lQW5kRmlsZUV4dC5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIG5vIGZpbGUgZXh0XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gZmlsZU5hbWVBbmRGaWxlRXh0LnBvcCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgZmlsZSBleHRlbnNpb25zLlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIGxpc3Qgb2YgZmlsZSBleHRlbnNpb25zLlxuICAgKi9cbiAgZ2V0RmlsZUV4dGVuc2lvbnMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiB1bmlxKGZsYXR0ZW4obWFwKHRoaXMuZmlsZVR5cGVFeHRlbnNpb25zTWFwLCAoeyBleHRzIH0pID0+IGV4dHMpKSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGxpc3Qgb2YgZ2VuZXJpYyBmaWxlIHR5cGVzLlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIHRoZSBsaXN0IG9mIGdlbmVyaWMgZmlsZSB0eXBlcy5cbiAgICovXG4gIGdldEdlbmVyaWNGaWxlVHlwZXMoKTogR0VORVJJQ19GSUxFX1RZUEVbXSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZmlsZVR5cGVFeHRlbnNpb25zTWFwKSBhcyBHRU5FUklDX0ZJTEVfVFlQRVtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG1hcEdlbmVyaWNGaWxlVHlwZXNUb0V4dGVuc2lvbnMoZ2VuZXJpY0ZpbGVUeXBlczogR0VORVJJQ19GSUxFX1RZUEVbXSA9IFtdKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IGZpbGVFeHRzID0gZ2VuZXJpY0ZpbGVUeXBlcy5tYXAoZ1QgPT4ge1xuICAgICAgY29uc3QgeyBleHRzIH0gPSB0aGlzLmZpbGVUeXBlRXh0ZW5zaW9uc01hcFtnVF07XG4gICAgICByZXR1cm4gZXh0cztcbiAgICB9KTtcblxuICAgIHJldHVybiB1bmlxKGZsYXR0ZW4oZmlsZUV4dHMpKTtcbiAgfVxuICAvKipcbiAgICogRXh0cmFjdHMgYSBsaXN0IG9mIGZpbGUgZXh0ZW5zaW9ucyBmcm9tIGEgc3RyaW5nLlxuICAgKiBDYW4gYWNjZXB0IGdlbmVyaWMgZmlsZSB0eXBlcyBjaGVjazogW0dFTkVSSUNfRklMRV9UWVBFXXtAbGluayBHRU5FUklDX0ZJTEVfVFlQRX0uXG4gICAqXG4gICAqIEBwYXJhbSBzdHIgU3RyaW5nIGZyb20gd2hpY2ggdGhlIGZpbGUgZXh0ZW5zaW9ucyBhcmUgZXh0cmFjdGVkIChjb21tYSBzZXBhcmF0ZWQgdmFsdWVzKS5cbiAgICogQWNjZXB0ZWQgc3RyaW5nIGZvcm1hdDpcbiAgICogKiBcIi56aXAsLmlzb1wiLFxuICAgKiAqIFwiemlwLElTT1wiLFxuICAgKiAqIFwiYXJjaGl2ZVwiLlxuICAgKiBJbXBvcnRhbnQ6IGdlbmVyaWMgdHlwZXMgY2Fubm90IGNvbnRhaW4gYSBkb3QuIEFsbCB2YWx1ZXMgd2l0aCBhIGRvdCBhcmUgdHJlYXRlZCBhcyBhIG5vcm1hbCBleHRlbnNpb24uXG4gICAqIEByZXR1cm5zIFJldHVybnMgYSBsaXN0IG9mIHRoZSBmaWxlIGV4dGVuc2lvbnMuXG4gICAqL1xuICBleHRyYWN0RmlsZUV4dGVuc2lvbnMoc3RyOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgaWYgKCFzdHIpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgdHlwZXMgPSBzdHIuc3BsaXQoJywnKS5tYXAodCA9PiB0LnRvTG93ZXJDYXNlKCkudHJpbSgpKTtcblxuICAgIGNvbnN0IGdlbmVyaWNUeXBlcyA9IHR5cGVzLmZpbHRlcigodDogc3RyaW5nKSA9PiB0aGlzLmlzR2VuZXJpY1R5cGUodCkpO1xuICAgIGNvbnN0IGRlZmF1bHRGaWxlRXh0cyA9IHR5cGVzLmZpbHRlcigodDogc3RyaW5nKSA9PiAhdGhpcy5pc0dlbmVyaWNUeXBlKHQpKTtcblxuICAgIGNvbnN0IGFsbFR5cGVzID0gW1xuICAgICAgLi4udGhpcy5tYXBHZW5lcmljRmlsZVR5cGVzVG9FeHRlbnNpb25zKGdlbmVyaWNUeXBlcyBhcyBHRU5FUklDX0ZJTEVfVFlQRVtdKSxcbiAgICAgIC4uLmRlZmF1bHRGaWxlRXh0c1xuICAgIF0ubWFwKHQgPT4gdC5yZXBsYWNlKCcuJywgJycpKTtcblxuICAgIHJldHVybiB1bmlxKGFsbFR5cGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIGZpbGUgdG8gYSBiYXNlNjQgaW1hZ2Ugc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0gZmlsZSBUaGUgZmlsZSB0byBjb252ZXJ0IHRvIGJhc2UgNjQuXG4gICAqIEByZXR1cm5zIFRoZSBpbWFnZSBzdHJpbmcgaW4gYmFzZTY0IGZvcm1hdC5cbiAgICovXG4gIHRvQmFzZTY0KGZpbGU6IEZpbGUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xuICAgICAgcmVhZGVyLm9ubG9hZCA9ICgpID0+IHJlc29sdmUocmVhZGVyLnJlc3VsdCk7XG4gICAgICByZWFkZXIub25lcnJvciA9IGVycm9yID0+IHJlamVjdChlcnJvcik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWxsb3dzIHRvIGdldCBhIEZpbGUgcmVwcmVzZW50YXRpb24gb2YgYW4gbWFuYWdlZCBvYmplY3QgYmluYXJ5LiBDYW4gYmUgdXNlZFxuICAgKiB0byBjb252ZXJ0IHRoaXMgZmlsZSB0b0Jhc2U2NCB0byBzaG93IGl0IHRvIHRoZSBlbmQtdXNlci5cbiAgICogQHBhcmFtIGJpbmFyeSBUaGUgYmluYXJ5IG1hbmFnZWQgb2JqZWN0XG4gICAqIEByZXR1cm5zIFRoZSBmaWxlIHJlcHJlc2VudGF0aW9uLlxuICAgKi9cbiAgYXN5bmMgZ2V0RmlsZShiaW5hcnk6IElNYW5hZ2VkT2JqZWN0QmluYXJ5KTogUHJvbWlzZTxGaWxlPiB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5pbnZlbnRvcnlCaW5hcnlTZXJ2aWNlLmRvd25sb2FkKGJpbmFyeS5pZCk7XG4gICAgY29uc3QgYXJyYXlCdWZmZXIgPSBhd2FpdCByZXMuYXJyYXlCdWZmZXIoKTtcbiAgICByZXR1cm4gbmV3IEZpbGUoW2FycmF5QnVmZmVyXSwgYmluYXJ5Lm5hbWUsIHsgdHlwZTogYmluYXJ5LmNvbnRlbnRUeXBlIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93cyB0byBkb3dubG9hZCBhIGZpbGUgKG9wZW5zIHRoZSBicm93c2VyIGRvd25sb2FkIHByb21wdCkuXG4gICAqIEBwYXJhbSBiaW5hcnkgVGhlIGJpbmFyeSBtYW5hZ2VkIG9iamVjdC5cbiAgICovXG4gIGFzeW5jIGRvd25sb2FkKGJpbmFyeTogSU1hbmFnZWRPYmplY3RCaW5hcnkpIHtcbiAgICBjb25zdCBmaWxlID0gYXdhaXQgdGhpcy5nZXRGaWxlKGJpbmFyeSk7XG4gICAgc2F2ZUFzKGZpbGUpO1xuICB9XG5cbiAgcHJpdmF0ZSBpc0dlbmVyaWNUeXBlKHR5cGU6IHN0cmluZykge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKEdFTkVSSUNfRklMRV9UWVBFKS5pbmNsdWRlcyh0eXBlIGFzIEdFTkVSSUNfRklMRV9UWVBFKTtcbiAgfVxufVxuIl19