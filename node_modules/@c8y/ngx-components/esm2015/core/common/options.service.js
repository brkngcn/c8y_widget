import { __awaiter } from "tslib";
import { InjectionToken, Optional, Inject, Injectable } from '@angular/core';
import { camelCase, isUndefined } from 'lodash-es';
import { ApplicationOptions } from './ApplicationOptions';
import { SystemOptionsService, TenantOptionsService } from '@c8y/ngx-components/api';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@c8y/ngx-components/api';
export const HOOK_OPTIONS = new InjectionToken('App options');
/**
 * A service that allows to set or get application options
 * which configure the default behavior of the UI.
 */
export class OptionsService extends ApplicationOptions {
    constructor(options, systemOptionsService, tenantOptionService) {
        super();
        this.systemOptionsService = systemOptionsService;
        this.tenantOptionService = tenantOptionService;
        this.setupOptions(options);
    }
    /**
     * Returns an application option used to configure the UI.
     * @param optionKey The application options key.
     * @param defaultValue A value to return if non is set.
     * @param attemptParse Indicates whether the value should be parsed with JSON.parse.
     */
    get(optionKey, defaultValue, attemptParse) {
        let value = this[optionKey];
        if (typeof value === 'undefined') {
            value = this[camelCase(optionKey)];
        }
        if (attemptParse) {
            return this.parseOptionRawValue(value, defaultValue);
        }
        return typeof value !== 'undefined' ? value : defaultValue;
    }
    /**
     * Sets an application option.
     * @param key The key to set.
     * @param value The value to set.
     */
    set(key, value) {
        this[camelCase(key)] = value;
    }
    /**
     * Gets support url from tenant options.
     * If response returns '404 not found' it gets the support url from application options.
     * If the support link within application options is not provided the UI will use the system options.
     * Is the support link explicitly set to false it will be hidden.
     *
     * @returns Returns support url or false.
     */
    getSupportUrl() {
        return __awaiter(this, void 0, void 0, function* () {
            let url = yield this.getTenantOption('configuration', 'system.support.url');
            if (isUndefined(url)) {
                url = this.supportUrl;
            }
            this.supportUrl = isUndefined(url)
                ? (yield this.getSystemOption('support', 'url')) || false
                : url;
            return this.supportUrl;
        });
    }
    /**
     * Returns if the tenant allows to show the activate-support user menu entry.
     * Note: Only if system-level support-user/enabled is false we can activate it at tenant level.
     */
    getActivateSupportUser() {
        return __awaiter(this, void 0, void 0, function* () {
            const option = yield this.getSystemOption('support-user', 'enabled', true);
            return !option;
        });
    }
    /**
     * Gets a value from the system service and parses it.
     *
     * @param category The category for this option.
     * @param key The key for that option.
     * @param defaultValue The default if the option was not found.
     */
    getSystemOption(category, key, defaultValue) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getOptionFromService(category, key, this.systemOptionsService, defaultValue);
        });
    }
    /**
     * Gets a value from the tenant service and parses it.
     *
     * @param category The category for this option.
     * @param key The key for that option.
     * @param defaultValue The default if the option was not found.
     */
    getTenantOption(category, key, defaultValue) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getOptionFromService(category, key, this.tenantOptionService, defaultValue);
        });
    }
    setupOptions(options) {
        if (options) {
            if (!Array.isArray(options)) {
                options = [options];
            }
            options.forEach(optionMap => {
                if (optionMap) {
                    Object.keys(optionMap).forEach(key => {
                        this[camelCase(key)] = optionMap[key];
                    });
                }
            });
        }
    }
    getOptionFromService(category, key, service, defaultValue) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { data } = yield service.detail({ category, key });
                return this.parseOptionRawValue(data.value, defaultValue);
            }
            catch (ex) {
                return defaultValue;
            }
        });
    }
    parseOptionRawValue(rawValue, defaultValue) {
        let value;
        try {
            value = JSON.parse(rawValue);
        }
        catch (e) {
            value = isUndefined(rawValue) ? defaultValue : rawValue;
        }
        return value;
    }
}
OptionsService.ɵfac = function OptionsService_Factory(t) { return new (t || OptionsService)(ɵngcc0.ɵɵinject(HOOK_OPTIONS, 8), ɵngcc0.ɵɵinject(ɵngcc1.SystemOptionsService), ɵngcc0.ɵɵinject(ɵngcc1.TenantOptionsService)); };
OptionsService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: OptionsService, factory: OptionsService.ɵfac });
OptionsService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [HOOK_OPTIONS,] }] },
    { type: SystemOptionsService },
    { type: TenantOptionsService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(OptionsService, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [HOOK_OPTIONS]
            }] }, { type: ɵngcc1.SystemOptionsService }, { type: ɵngcc1.TenantOptionsService }]; }, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3B0aW9ucy5zZXJ2aWNlLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9jb3JlL2NvbW1vbi9vcHRpb25zLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxjQUFjLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDN0UsT0FBTyxFQUFFLFNBQVMsRUFBRSxXQUFXLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFDbkQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFFMUQsT0FBTyxFQUFFLG9CQUFvQixFQUFFLG9CQUFvQixFQUFFLE1BQU0seUJBQXlCLENBQUM7OztBQUVyRixNQUFNLENBQUMsTUFBTSxZQUFZLEdBQUcsSUFBSSxjQUFjLENBQXVDLGFBQWEsQ0FBQyxDQUFDO0FBRXBHO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFFSCxNQUFNLE9BQU8sY0FBZSxTQUFRLGtCQUFrQjtBQUN0RCxJQUNFLFlBQ29DLE9BQU8sRUFDakMsb0JBQTBDLEVBQzFDLG1CQUF5QztBQUNsRCxRQUNDLEtBQUssRUFBRSxDQUFDO0FBQ1osUUFKWSx5QkFBb0IsR0FBcEIsb0JBQW9CLENBQXNCO0FBQUMsUUFDM0Msd0JBQW1CLEdBQW5CLG1CQUFtQixDQUFzQjtBQUNyRCxRQUVJLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDL0IsSUFBRSxDQUFDO0FBQ0gsSUFDRTtBQUNGO0FBQ0U7QUFDRTtBQUNFO0FBRUosT0FERztBQUNMLElBQUUsR0FBRyxDQUFDLFNBQStCLEVBQUUsWUFBa0IsRUFBRSxZQUFzQjtBQUNqRixRQUFJLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUNoQyxRQUFJLElBQUksT0FBTyxLQUFLLEtBQUssV0FBVyxFQUFFO0FBQ3RDLFlBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsU0FB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RixvQkFBb0I7QUFBRzs7Ozs7Ozs7Z0hBQUU7QUFBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGlvblRva2VuLCBPcHRpb25hbCwgSW5qZWN0LCBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBjYW1lbENhc2UsIGlzVW5kZWZpbmVkIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IEFwcGxpY2F0aW9uT3B0aW9ucyB9IGZyb20gJy4vQXBwbGljYXRpb25PcHRpb25zJztcbmltcG9ydCB7IEV4dGVuc2lvbkZhY3RvcnkgfSBmcm9tICcuL2V4dGVuc2lvbi1ob29rcyc7XG5pbXBvcnQgeyBTeXN0ZW1PcHRpb25zU2VydmljZSwgVGVuYW50T3B0aW9uc1NlcnZpY2UgfSBmcm9tICdAYzh5L25neC1jb21wb25lbnRzL2FwaSc7XG5cbmV4cG9ydCBjb25zdCBIT09LX09QVElPTlMgPSBuZXcgSW5qZWN0aW9uVG9rZW48RXh0ZW5zaW9uRmFjdG9yeTxBcHBsaWNhdGlvbk9wdGlvbnM+PignQXBwIG9wdGlvbnMnKTtcblxuLyoqXG4gKiBBIHNlcnZpY2UgdGhhdCBhbGxvd3MgdG8gc2V0IG9yIGdldCBhcHBsaWNhdGlvbiBvcHRpb25zXG4gKiB3aGljaCBjb25maWd1cmUgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgdGhlIFVJLlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgT3B0aW9uc1NlcnZpY2UgZXh0ZW5kcyBBcHBsaWNhdGlvbk9wdGlvbnMge1xuICBba2V5OiBzdHJpbmddOiBhbnk7XG4gIGNvbnN0cnVjdG9yKFxuICAgIEBPcHRpb25hbCgpIEBJbmplY3QoSE9PS19PUFRJT05TKSBvcHRpb25zLFxuICAgIHByaXZhdGUgc3lzdGVtT3B0aW9uc1NlcnZpY2U6IFN5c3RlbU9wdGlvbnNTZXJ2aWNlLFxuICAgIHByaXZhdGUgdGVuYW50T3B0aW9uU2VydmljZTogVGVuYW50T3B0aW9uc1NlcnZpY2VcbiAgKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNldHVwT3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFwcGxpY2F0aW9uIG9wdGlvbiB1c2VkIHRvIGNvbmZpZ3VyZSB0aGUgVUkuXG4gICAqIEBwYXJhbSBvcHRpb25LZXkgVGhlIGFwcGxpY2F0aW9uIG9wdGlvbnMga2V5LlxuICAgKiBAcGFyYW0gZGVmYXVsdFZhbHVlIEEgdmFsdWUgdG8gcmV0dXJuIGlmIG5vbiBpcyBzZXQuXG4gICAqIEBwYXJhbSBhdHRlbXB0UGFyc2UgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHZhbHVlIHNob3VsZCBiZSBwYXJzZWQgd2l0aCBKU09OLnBhcnNlLlxuICAgKi9cbiAgZ2V0KG9wdGlvbktleToga2V5b2YgT3B0aW9uc1NlcnZpY2UsIGRlZmF1bHRWYWx1ZT86IGFueSwgYXR0ZW1wdFBhcnNlPzogYm9vbGVhbikge1xuICAgIGxldCB2YWx1ZSA9IHRoaXNbb3B0aW9uS2V5XTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFsdWUgPSB0aGlzW2NhbWVsQ2FzZShvcHRpb25LZXkpXTtcbiAgICB9XG4gICAgaWYgKGF0dGVtcHRQYXJzZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcHRpb25SYXdWYWx1ZSh2YWx1ZSwgZGVmYXVsdFZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgPyB2YWx1ZSA6IGRlZmF1bHRWYWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGFuIGFwcGxpY2F0aW9uIG9wdGlvbi5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIHNldC5cbiAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAqL1xuICBzZXQoa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpIHtcbiAgICB0aGlzW2NhbWVsQ2FzZShrZXkpXSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgc3VwcG9ydCB1cmwgZnJvbSB0ZW5hbnQgb3B0aW9ucy5cbiAgICogSWYgcmVzcG9uc2UgcmV0dXJucyAnNDA0IG5vdCBmb3VuZCcgaXQgZ2V0cyB0aGUgc3VwcG9ydCB1cmwgZnJvbSBhcHBsaWNhdGlvbiBvcHRpb25zLlxuICAgKiBJZiB0aGUgc3VwcG9ydCBsaW5rIHdpdGhpbiBhcHBsaWNhdGlvbiBvcHRpb25zIGlzIG5vdCBwcm92aWRlZCB0aGUgVUkgd2lsbCB1c2UgdGhlIHN5c3RlbSBvcHRpb25zLlxuICAgKiBJcyB0aGUgc3VwcG9ydCBsaW5rIGV4cGxpY2l0bHkgc2V0IHRvIGZhbHNlIGl0IHdpbGwgYmUgaGlkZGVuLlxuICAgKlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIHN1cHBvcnQgdXJsIG9yIGZhbHNlLlxuICAgKi9cbiAgYXN5bmMgZ2V0U3VwcG9ydFVybCgpIHtcbiAgICBsZXQgdXJsID0gYXdhaXQgdGhpcy5nZXRUZW5hbnRPcHRpb24oJ2NvbmZpZ3VyYXRpb24nLCAnc3lzdGVtLnN1cHBvcnQudXJsJyk7XG4gICAgaWYgKGlzVW5kZWZpbmVkKHVybCkpIHtcbiAgICAgIHVybCA9IHRoaXMuc3VwcG9ydFVybDtcbiAgICB9XG4gICAgdGhpcy5zdXBwb3J0VXJsID0gaXNVbmRlZmluZWQodXJsKVxuICAgICAgPyAoYXdhaXQgdGhpcy5nZXRTeXN0ZW1PcHRpb24oJ3N1cHBvcnQnLCAndXJsJykpIHx8IGZhbHNlXG4gICAgICA6IHVybDtcbiAgICByZXR1cm4gdGhpcy5zdXBwb3J0VXJsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaWYgdGhlIHRlbmFudCBhbGxvd3MgdG8gc2hvdyB0aGUgYWN0aXZhdGUtc3VwcG9ydCB1c2VyIG1lbnUgZW50cnkuXG4gICAqIE5vdGU6IE9ubHkgaWYgc3lzdGVtLWxldmVsIHN1cHBvcnQtdXNlci9lbmFibGVkIGlzIGZhbHNlIHdlIGNhbiBhY3RpdmF0ZSBpdCBhdCB0ZW5hbnQgbGV2ZWwuXG4gICAqL1xuICBhc3luYyBnZXRBY3RpdmF0ZVN1cHBvcnRVc2VyKCkge1xuICAgIGNvbnN0IG9wdGlvbiA9IGF3YWl0IHRoaXMuZ2V0U3lzdGVtT3B0aW9uKCdzdXBwb3J0LXVzZXInLCAnZW5hYmxlZCcsIHRydWUpO1xuICAgIHJldHVybiAhb3B0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYSB2YWx1ZSBmcm9tIHRoZSBzeXN0ZW0gc2VydmljZSBhbmQgcGFyc2VzIGl0LlxuICAgKlxuICAgKiBAcGFyYW0gY2F0ZWdvcnkgVGhlIGNhdGVnb3J5IGZvciB0aGlzIG9wdGlvbi5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IGZvciB0aGF0IG9wdGlvbi5cbiAgICogQHBhcmFtIGRlZmF1bHRWYWx1ZSBUaGUgZGVmYXVsdCBpZiB0aGUgb3B0aW9uIHdhcyBub3QgZm91bmQuXG4gICAqL1xuICBhc3luYyBnZXRTeXN0ZW1PcHRpb24oY2F0ZWdvcnk6IHN0cmluZywga2V5OiBzdHJpbmcsIGRlZmF1bHRWYWx1ZT86IGFueSkge1xuICAgIHJldHVybiB0aGlzLmdldE9wdGlvbkZyb21TZXJ2aWNlKGNhdGVnb3J5LCBrZXksIHRoaXMuc3lzdGVtT3B0aW9uc1NlcnZpY2UsIGRlZmF1bHRWYWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhIHZhbHVlIGZyb20gdGhlIHRlbmFudCBzZXJ2aWNlIGFuZCBwYXJzZXMgaXQuXG4gICAqXG4gICAqIEBwYXJhbSBjYXRlZ29yeSBUaGUgY2F0ZWdvcnkgZm9yIHRoaXMgb3B0aW9uLlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgZm9yIHRoYXQgb3B0aW9uLlxuICAgKiBAcGFyYW0gZGVmYXVsdFZhbHVlIFRoZSBkZWZhdWx0IGlmIHRoZSBvcHRpb24gd2FzIG5vdCBmb3VuZC5cbiAgICovXG4gIGFzeW5jIGdldFRlbmFudE9wdGlvbihjYXRlZ29yeTogc3RyaW5nLCBrZXk6IHN0cmluZywgZGVmYXVsdFZhbHVlPzogYW55KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9uRnJvbVNlcnZpY2UoY2F0ZWdvcnksIGtleSwgdGhpcy50ZW5hbnRPcHRpb25TZXJ2aWNlLCBkZWZhdWx0VmFsdWUpO1xuICB9XG5cbiAgcHJpdmF0ZSBzZXR1cE9wdGlvbnMob3B0aW9uczogYW55W10gfCBudWxsKSB7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICBvcHRpb25zID0gW29wdGlvbnNdO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy5mb3JFYWNoKG9wdGlvbk1hcCA9PiB7XG4gICAgICAgIGlmIChvcHRpb25NYXApIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25NYXApLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIHRoaXNbY2FtZWxDYXNlKGtleSldID0gb3B0aW9uTWFwW2tleV07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZ2V0T3B0aW9uRnJvbVNlcnZpY2UoY2F0ZWdvcnksIGtleSwgc2VydmljZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgc2VydmljZS5kZXRhaWwoeyBjYXRlZ29yeSwga2V5IH0pO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcHRpb25SYXdWYWx1ZShkYXRhLnZhbHVlLCBkZWZhdWx0VmFsdWUpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcGFyc2VPcHRpb25SYXdWYWx1ZShyYXdWYWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgbGV0IHZhbHVlO1xuICAgIHRyeSB7XG4gICAgICB2YWx1ZSA9IEpTT04ucGFyc2UocmF3VmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHZhbHVlID0gaXNVbmRlZmluZWQocmF3VmFsdWUpID8gZGVmYXVsdFZhbHVlIDogcmF3VmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuIl19