import { __awaiter, __decorate } from "tslib";
import { Injectable } from '@angular/core';
import { AppStateService } from './ui-state.service';
import { InventoryService } from '@c8y/client';
import { property } from 'lodash-es';
import { memoize } from './memoize.decorator';
import { UserService } from '@c8y/client';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './ui-state.service';
import * as ɵngcc2 from '@c8y/client';
export class Permissions {
    constructor(appState, inventory, user) {
        this.appState = appState;
        this.inventory = inventory;
        this.user = user;
    }
    /**
     * Checks if the current user has write permissions for the given mo.
     * (either through global role, individual device permissions or via inventory roles).
     *
     * @param {array} roleIds Array of roles which the current user should have.
     * @param {IManagedObject | IIdentified} mo The managed object for which we are checking whether the user has access.
     */
    canEdit(roleIds, mo) {
        return this.checkIfCanEdit(roleIds, mo);
    }
    hasRole(roleId) {
        const currentUser = this.appState.currentUser.value;
        if (!currentUser) {
            throw new Error('Roles can only be requested if the user is logged in.');
        }
        return this.user.hasRole(currentUser, roleId);
    }
    hasAllRoles(roleIds) {
        const currentUser = this.appState.currentUser.value;
        if (!currentUser) {
            throw new Error('Roles can only be requested if the user is logged in.');
        }
        return this.user.hasAllRoles(currentUser, roleIds);
    }
    hasAnyRole(roleIds) {
        const currentUser = this.appState.currentUser.value;
        if (!currentUser) {
            throw new Error('Roles can only be requested if the user is logged in.');
        }
        return this.user.hasAnyRole(currentUser, roleIds);
    }
    checkIfOwner(mo) {
        return __awaiter(this, void 0, void 0, function* () {
            const currentUserName = yield this.appState.currentUser.value.userName;
            const { data, res } = yield this.inventory.detail(mo.id);
            return currentUserName === data.owner;
        });
    }
    checkWithRequest(mo) {
        const moName = mo.name;
        const moId = mo.id;
        const partialUpdateObject = {
            id: moId,
            name: moName
        };
        return this.inventory
            .update(partialUpdateObject)
            .then(success => {
            return true;
        })
            .catch(err => {
            return false;
        });
    }
    checkIfCanEdit(roleIds, mo) {
        return __awaiter(this, void 0, void 0, function* () {
            if (yield this.hasAnyRole(roleIds)) {
                return true;
            }
            else if (yield this.checkIfOwner(mo)) {
                return true;
            }
            else if (yield this.checkWithRequest(mo)) {
                return true;
            }
            return false;
        });
    }
}
Permissions.ɵfac = function Permissions_Factory(t) { return new (t || Permissions)(ɵngcc0.ɵɵinject(ɵngcc1.AppStateService), ɵngcc0.ɵɵinject(ɵngcc2.InventoryService), ɵngcc0.ɵɵinject(ɵngcc2.UserService)); };
Permissions.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: Permissions, factory: Permissions.ɵfac });
Permissions.ctorParameters = () => [
    { type: AppStateService },
    { type: InventoryService },
    { type: UserService }
];
__decorate([
    memoize(property('id'))
], Permissions.prototype, "checkIfOwner", null);
__decorate([
    memoize(property('id'))
], Permissions.prototype, "checkWithRequest", null);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Permissions, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.AppStateService }, { type: ɵngcc2.InventoryService }, { type: ɵngcc2.UserService }]; }, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGVybWlzc2lvbnMuc2VydmljZS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vY29yZS9jb21tb24vcGVybWlzc2lvbnMuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDckQsT0FBTyxFQUErQixnQkFBZ0IsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUM1RSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sV0FBVyxDQUFDO0FBQ3JDLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUM5QyxPQUFPLEVBQVMsV0FBVyxFQUFFLE1BQU0sYUFBYSxDQUFDOzs7O0FBR2pELE1BQU0sT0FBTyxXQUFXO0FBQ3hCLElBQUUsWUFDVSxRQUF5QixFQUN6QixTQUEyQixFQUMzQixJQUFpQjtBQUMxQixRQUhTLGFBQVEsR0FBUixRQUFRLENBQWlCO0FBQUMsUUFDMUIsY0FBUyxHQUFULFNBQVMsQ0FBa0I7QUFBQyxRQUM1QixTQUFJLEdBQUosSUFBSSxDQUFhO0FBQzdCLElBQUssQ0FBQztBQUNOLElBQ0U7QUFDRjtBQUNFO0FBQ0U7QUFDRTtBQUNFO0FBRUosT0FEQztBQUNMLElBQUUsT0FBTyxDQUFDLE9BQU8sRUFBRSxFQUFnQztBQUNuRCxRQUFJLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDNUMsSUFBRSxDQUFDO0FBQ0gsSUFDRSxPQUFPLENBQUMsTUFBYztBQUN4QixRQUFJLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQztBQUN4RCxRQUFJLElBQUksQ0FBQyxXQUFXLEVBQUU7QUFDdEIsWUFBTSxNQUFNLElBQUksS0FBSyxDQUFDLHVEQUF1RCxDQUFDLENBQUM7QUFDL0UsU0FB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QUksWUFDVSxnQkFBZ0I7QUFBSSxZQUcxQyxXQUFXO0FBQUc7QUE4QzVCO0FBQWEsSUFEWixPQUFPLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQzFCLCtDQUlHO0FBR0Q7QUFBYSxJQURaLE9BQU8sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDMUIsbURBZUc7OztpSkFDSDtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQXBwU3RhdGVTZXJ2aWNlIH0gZnJvbSAnLi91aS1zdGF0ZS5zZXJ2aWNlJztcbmltcG9ydCB7IElJZGVudGlmaWVkLCBJTWFuYWdlZE9iamVjdCwgSW52ZW50b3J5U2VydmljZSB9IGZyb20gJ0BjOHkvY2xpZW50JztcbmltcG9ydCB7IHByb3BlcnR5IH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IG1lbW9pemUgfSBmcm9tICcuL21lbW9pemUuZGVjb3JhdG9yJztcbmltcG9ydCB7IElVc2VyLCBVc2VyU2VydmljZSB9IGZyb20gJ0BjOHkvY2xpZW50JztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFBlcm1pc3Npb25zIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBhcHBTdGF0ZTogQXBwU3RhdGVTZXJ2aWNlLFxuICAgIHByaXZhdGUgaW52ZW50b3J5OiBJbnZlbnRvcnlTZXJ2aWNlLFxuICAgIHByaXZhdGUgdXNlcjogVXNlclNlcnZpY2VcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGN1cnJlbnQgdXNlciBoYXMgd3JpdGUgcGVybWlzc2lvbnMgZm9yIHRoZSBnaXZlbiBtby5cbiAgICogKGVpdGhlciB0aHJvdWdoIGdsb2JhbCByb2xlLCBpbmRpdmlkdWFsIGRldmljZSBwZXJtaXNzaW9ucyBvciB2aWEgaW52ZW50b3J5IHJvbGVzKS5cbiAgICpcbiAgICogQHBhcmFtIHthcnJheX0gcm9sZUlkcyBBcnJheSBvZiByb2xlcyB3aGljaCB0aGUgY3VycmVudCB1c2VyIHNob3VsZCBoYXZlLlxuICAgKiBAcGFyYW0ge0lNYW5hZ2VkT2JqZWN0IHwgSUlkZW50aWZpZWR9IG1vIFRoZSBtYW5hZ2VkIG9iamVjdCBmb3Igd2hpY2ggd2UgYXJlIGNoZWNraW5nIHdoZXRoZXIgdGhlIHVzZXIgaGFzIGFjY2Vzcy5cbiAgICovXG4gIGNhbkVkaXQocm9sZUlkcywgbW86IElNYW5hZ2VkT2JqZWN0IHwgSUlkZW50aWZpZWQpIHtcbiAgICByZXR1cm4gdGhpcy5jaGVja0lmQ2FuRWRpdChyb2xlSWRzLCBtbyk7XG4gIH1cblxuICBoYXNSb2xlKHJvbGVJZDogc3RyaW5nKSB7XG4gICAgY29uc3QgY3VycmVudFVzZXIgPSB0aGlzLmFwcFN0YXRlLmN1cnJlbnRVc2VyLnZhbHVlO1xuICAgIGlmICghY3VycmVudFVzZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUm9sZXMgY2FuIG9ubHkgYmUgcmVxdWVzdGVkIGlmIHRoZSB1c2VyIGlzIGxvZ2dlZCBpbi4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudXNlci5oYXNSb2xlKGN1cnJlbnRVc2VyLCByb2xlSWQpO1xuICB9XG5cbiAgaGFzQWxsUm9sZXMocm9sZUlkczogc3RyaW5nW10pIHtcbiAgICBjb25zdCBjdXJyZW50VXNlciA9IHRoaXMuYXBwU3RhdGUuY3VycmVudFVzZXIudmFsdWU7XG4gICAgaWYgKCFjdXJyZW50VXNlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSb2xlcyBjYW4gb25seSBiZSByZXF1ZXN0ZWQgaWYgdGhlIHVzZXIgaXMgbG9nZ2VkIGluLicpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy51c2VyLmhhc0FsbFJvbGVzKGN1cnJlbnRVc2VyLCByb2xlSWRzKTtcbiAgfVxuXG4gIGhhc0FueVJvbGUocm9sZUlkczogc3RyaW5nW10pIHtcbiAgICBjb25zdCBjdXJyZW50VXNlciA9IHRoaXMuYXBwU3RhdGUuY3VycmVudFVzZXIudmFsdWU7XG4gICAgaWYgKCFjdXJyZW50VXNlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSb2xlcyBjYW4gb25seSBiZSByZXF1ZXN0ZWQgaWYgdGhlIHVzZXIgaXMgbG9nZ2VkIGluLicpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy51c2VyLmhhc0FueVJvbGUoY3VycmVudFVzZXIsIHJvbGVJZHMpO1xuICB9XG5cbiAgQG1lbW9pemUocHJvcGVydHkoJ2lkJykpXG4gIHByb3RlY3RlZCBhc3luYyBjaGVja0lmT3duZXIobW8pIHtcbiAgICBjb25zdCBjdXJyZW50VXNlck5hbWUgPSBhd2FpdCB0aGlzLmFwcFN0YXRlLmN1cnJlbnRVc2VyLnZhbHVlLnVzZXJOYW1lO1xuICAgIGNvbnN0IHsgZGF0YSwgcmVzIH0gPSBhd2FpdCB0aGlzLmludmVudG9yeS5kZXRhaWwobW8uaWQpO1xuICAgIHJldHVybiBjdXJyZW50VXNlck5hbWUgPT09IGRhdGEub3duZXI7XG4gIH1cblxuICBAbWVtb2l6ZShwcm9wZXJ0eSgnaWQnKSlcbiAgcHJvdGVjdGVkIGNoZWNrV2l0aFJlcXVlc3QobW8pIHtcbiAgICBjb25zdCBtb05hbWUgPSBtby5uYW1lO1xuICAgIGNvbnN0IG1vSWQgPSBtby5pZDtcbiAgICBjb25zdCBwYXJ0aWFsVXBkYXRlT2JqZWN0OiBQYXJ0aWFsPElNYW5hZ2VkT2JqZWN0PiA9IHtcbiAgICAgIGlkOiBtb0lkLFxuICAgICAgbmFtZTogbW9OYW1lXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5pbnZlbnRvcnlcbiAgICAgIC51cGRhdGUocGFydGlhbFVwZGF0ZU9iamVjdClcbiAgICAgIC50aGVuKHN1Y2Nlc3MgPT4ge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGNoZWNrSWZDYW5FZGl0KHJvbGVJZHMsIG1vKSB7XG4gICAgaWYgKGF3YWl0IHRoaXMuaGFzQW55Um9sZShyb2xlSWRzKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChhd2FpdCB0aGlzLmNoZWNrSWZPd25lcihtbykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoYXdhaXQgdGhpcy5jaGVja1dpdGhSZXF1ZXN0KG1vKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuIl19