(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@c8y/client'), require('@c8y/ngx-components'), require('lodash-es'), require('rxjs'), require('rxjs/operators'), require('file-saver'), require('@ngx-translate/core'), require('@angular/forms'), require('@angular/common'), require('ngx-bootstrap/popover')) :
    typeof define === 'function' && define.amd ? define('@c8y/ngx-components/repository/shared', ['exports', '@angular/core', '@c8y/client', '@c8y/ngx-components', 'lodash-es', 'rxjs', 'rxjs/operators', 'file-saver', '@ngx-translate/core', '@angular/forms', '@angular/common', 'ngx-bootstrap/popover'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.c8y = global.c8y || {}, global.c8y["ngx-components"] = global.c8y["ngx-components"] || {}, global.c8y["ngx-components"].repository = global.c8y["ngx-components"].repository || {}, global.c8y["ngx-components"].repository.shared = {}), global.ng.core, global.client, global.c8y["ngx-components"], global.lodashEs, global.rxjs, global.rxjs.operators, global.fileSaver, global.core$1, global.ng.forms, global.ng.common, global.popover));
})(this, (function (exports, core, client, ngxComponents, lodashEs, rxjs, operators, fileSaver, core$1, forms, common, popover) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
                if (ar || !(i in from)) {
                    if (!ar)
                        ar = Array.prototype.slice.call(from, 0, i);
                    ar[i] = from[i];
                }
            }
        return to.concat(ar || Array.prototype.slice.call(from));
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m")
            throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    var AdvancedSoftwareService = /** @class */ (function (_super) {
        __extends(AdvancedSoftwareService, _super);
        function AdvancedSoftwareService(client, applicationService) {
            var _this = _super.call(this, client) || this;
            _this.applicationService = applicationService;
            _this.baseUrl = 'service/advanced-software-mgmt';
            _this.listUrl = 'software';
            _this.propertyName = 'softwareList';
            return _this;
        }
        AdvancedSoftwareService.prototype.list = function (filter) {
            if (filter === void 0) { filter = {}; }
            return _super.prototype.list.call(this, filter);
        };
        AdvancedSoftwareService.prototype.isASMAvailable = function () {
            if (this.isAvailable === undefined) {
                this.isAvailable = this.applicationService
                    .isAvailable(AdvancedSoftwareService.applicationName)
                    .then(function (result) { return !!(result === null || result === void 0 ? void 0 : result.data); });
            }
            return this.isAvailable;
        };
        return AdvancedSoftwareService;
    }(client.Service));
    AdvancedSoftwareService.applicationName = 'advanced-software-mgmt';
    AdvancedSoftwareService.decorators = [
        { type: core.Injectable }
    ];
    AdvancedSoftwareService.ctorParameters = function () { return [
        { type: client.FetchClient },
        { type: client.ApplicationService }
    ]; };

    var _a;
    exports.RepositoryType = void 0;
    (function (RepositoryType) {
        RepositoryType["FIRMWARE"] = "c8y_Firmware";
        RepositoryType["SOFTWARE"] = "c8y_Software";
        RepositoryType["CONFIGURATION"] = "c8y_ConfigurationDump";
    })(exports.RepositoryType || (exports.RepositoryType = {}));
    var REPOSITORY_BINARY_TYPES = (_a = {},
        _a[exports.RepositoryType.SOFTWARE] = 'c8y_SoftwareBinary',
        _a[exports.RepositoryType.FIRMWARE] = 'c8y_FirmwareBinary',
        _a[exports.RepositoryType.CONFIGURATION] = 'c8y_ConfigurationDumpBinary',
        _a);
    exports.DeviceConfigurationOperation = void 0;
    (function (DeviceConfigurationOperation) {
        DeviceConfigurationOperation["UPLOAD_CONFIG"] = "c8y_UploadConfigFile";
        DeviceConfigurationOperation["DOWNLOAD_CONFIG"] = "c8y_DownloadConfigFile";
        DeviceConfigurationOperation["CONFIG"] = "c8y_Configuration";
        DeviceConfigurationOperation["SEND_CONFIG"] = "c8y_SendConfiguration";
    })(exports.DeviceConfigurationOperation || (exports.DeviceConfigurationOperation = {}));

    var RepositoryService = /** @class */ (function () {
        function RepositoryService(inventory, inventoryBinary, operation, alert, event, operationRealtime, eventBinary, advancedSoftwareService) {
            this.inventory = inventory;
            this.inventoryBinary = inventoryBinary;
            this.operation = operation;
            this.alert = alert;
            this.event = event;
            this.operationRealtime = operationRealtime;
            this.eventBinary = eventBinary;
            this.advancedSoftwareService = advancedSoftwareService;
            this.dateFrom = new Date(0);
            this.dateTo = new Date(Date.now() + 86400000); // 1 day in the future
            this.queriesUtil = new client.QueriesUtil();
        }
        /**
         * Lists repository entries of given type.
         * @param type The type of repository entries to list.
         * @param options Extra listing options.
         */
        RepositoryService.prototype.listRepositoryEntries = function (type, options) {
            var defaultOrder = [{ name: 1 }];
            var defaultFilters = { type: type };
            var legacyFilters = { __has: "url" };
            var filters = {};
            var fullQuery = (options && options.query) || {};
            if (!options || (options && !options.skipDefaultOrder)) {
                fullQuery = this.queriesUtil.addOrderbys(fullQuery, defaultOrder, 'prepend');
            }
            fullQuery = this.queriesUtil.addAndFilter(fullQuery, defaultFilters);
            if (options && options.partialTextFilter) {
                var _b = options.partialTextFilter, partialText_1 = _b.partialText, properties = _b.properties;
                var orFilter = { __or: properties.map(function (property) {
                        var _b;
                        return (_b = {}, _b[property] = "*" + partialText_1 + "*", _b);
                    }) };
                fullQuery = this.queriesUtil.addAndFilter(fullQuery, orFilter);
            }
            if (options && options.partialName) {
                // backwards compatibility if
                fullQuery = this.queriesUtil.addAndFilter(fullQuery, { name: "*" + options.partialName + "*" });
            }
            if (options && options.skipLegacy) {
                fullQuery = this.queriesUtil.addAndFilter(fullQuery, { __not: legacyFilters });
            }
            filters = Object.assign({ query: this.queriesUtil.buildQuery(fullQuery), pageSize: 50, withTotalPages: true }, ((options && options.params) || {}));
            return this.inventory.list(filters);
        };
        // TODO: merge with create()
        RepositoryService.prototype.save = function (data, type, mo) {
            if (mo === void 0) { mo = {}; }
            return __awaiter(this, void 0, void 0, function () {
                var existingUrl, response;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            switch (type) {
                                case exports.RepositoryType.CONFIGURATION: {
                                    Object.assign(mo, {
                                        type: exports.RepositoryType.CONFIGURATION,
                                        configurationType: data.selected ? data.selected.configurationType : undefined,
                                        name: data.version,
                                        description: data.description,
                                        deviceType: data.deviceType,
                                        c8y_Global: {}
                                    });
                                    if (!data.deviceType && mo.id) {
                                        mo.deviceType = null;
                                    }
                                    if (!data.selected && mo.id) {
                                        mo.configurationType = null;
                                    }
                                    break;
                                }
                            }
                            existingUrl = mo.url;
                            if (!data.binary.url) return [3 /*break*/, 1];
                            mo.url = data.binary.url;
                            return [3 /*break*/, 3];
                        case 1:
                            if (!data.binary.file) return [3 /*break*/, 3];
                            return [4 /*yield*/, this.inventoryBinary.create(data.binary.file, {
                                    c8y_Global: {}
                                })];
                        case 2:
                            response = _b.sent();
                            mo.url = response.data.self;
                            _b.label = 3;
                        case 3:
                            if (mo.id) {
                                return [2 /*return*/, this.updateEntry(mo, existingUrl)];
                            }
                            return [2 /*return*/, this.createEntry(mo)];
                    }
                });
            });
        };
        RepositoryService.prototype.create = function (modal, type) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_b) {
                    switch (type) {
                        case exports.RepositoryType.FIRMWARE:
                        case exports.RepositoryType.SOFTWARE:
                            return [2 /*return*/, this.createFirmwareOrSoftware(modal, type)];
                    }
                    return [2 /*return*/];
                });
            });
        };
        RepositoryService.prototype.createFirmwareOrSoftware = function (modal, type) {
            return __awaiter(this, void 0, void 0, function () {
                var binary, binaryURL, repositoryEntry, repositoryBinary, mos, selectedId, _b, file, url, error_1;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            mos = [];
                            selectedId = modal.selected.id, _b = modal.binary, file = _b.file, url = _b.url;
                            _c.label = 1;
                        case 1:
                            _c.trys.push([1, 9, , 10]);
                            if (!file) return [3 /*break*/, 3];
                            return [4 /*yield*/, this.saveBinary(file)];
                        case 2:
                            (binary = (_c.sent()).data);
                            (binaryURL = binary.self);
                            mos.push(binary);
                            return [3 /*break*/, 4];
                        case 3:
                            binaryURL = url;
                            _c.label = 4;
                        case 4: return [4 /*yield*/, this.createOrUpdateRepositoryEntry(modal, type)];
                        case 5:
                            (repositoryEntry = (_c.sent()).data);
                            if (lodashEs.isNil(selectedId)) {
                                mos.push(repositoryEntry);
                            }
                            return [4 /*yield*/, this.createRepositoryBinary(modal, binaryURL, type, repositoryEntry)];
                        case 6:
                            (repositoryBinary = (_c.sent()).data);
                            mos.push(repositoryBinary);
                            if (!file) return [3 /*break*/, 8];
                            return [4 /*yield*/, this.linkBinary(repositoryBinary, binary)];
                        case 7:
                            _c.sent();
                            _c.label = 8;
                        case 8: return [2 /*return*/, repositoryEntry];
                        case 9:
                            error_1 = _c.sent();
                            this.cleanUp(mos);
                            this.errorMsg();
                            // Propagate error
                            throw error_1;
                        case 10: return [2 /*return*/];
                    }
                });
            });
        };
        RepositoryService.prototype.saveBinary = function (file) {
            return this.inventoryBinary.create(file, { c8y_Global: {} });
        };
        RepositoryService.prototype.createOrUpdateRepositoryEntry = function (modal, type) {
            var _b = modal.selected, id = _b.id, name = _b.name, description = modal.description, deviceType = modal.deviceType;
            var mo = {
                id: id,
                name: id ? undefined : name,
                description: description,
                type: id ? undefined : type,
                c8y_Global: {}
            };
            if (deviceType) {
                lodashEs.set(mo, 'c8y_Filter.type', deviceType);
            }
            if (modal.softwareType) {
                lodashEs.set(mo, 'softwareType', modal.softwareType.softwareType);
            }
            return id
                ? this.inventory.update(mo)
                : this.inventory.create(mo);
        };
        RepositoryService.prototype.createRepositoryBinary = function (modal, binaryURL, type, parent) {
            var mo = this.prepareRepositoryBinaryMO(modal, binaryURL, type);
            return this.inventory.childAdditionsCreate(mo, parent);
        };
        RepositoryService.prototype.prepareRepositoryBinaryMO = function (modal, binaryURL, type) {
            var _b;
            var version = modal.version, patchVersion = modal.patchVersion, dependency = modal.dependency;
            var result = (_b = {
                    type: REPOSITORY_BINARY_TYPES[type]
                },
                _b[type] = {
                    url: binaryURL
                },
                _b.c8y_Global = {},
                _b);
            if (dependency) {
                lodashEs.set(result, [type, 'version'], patchVersion);
                lodashEs.assign(result, {
                    c8y_Patch: {
                        dependency: dependency.c8y_Firmware.version
                    }
                });
            }
            else {
                lodashEs.set(result, [type, 'version'], version);
            }
            return result;
        };
        RepositoryService.prototype.linkBinary = function (repositoryBinary, binary) {
            return __awaiter(this, void 0, void 0, function () {
                var repositoryBinaryId, binaryId;
                return __generator(this, function (_b) {
                    repositoryBinaryId = repositoryBinary.id;
                    if (binary) {
                        binaryId = binary.id;
                        return [2 /*return*/, this.inventory.childAdditionsAdd(binaryId, repositoryBinaryId)];
                    }
                    return [2 /*return*/];
                });
            });
        };
        RepositoryService.prototype.cleanUp = function (mosToDelete) {
            var _this = this;
            mosToDelete.forEach(function (mo) {
                var c8y_IsBinary = mo.c8y_IsBinary;
                lodashEs.isUndefined(c8y_IsBinary) ? _this.delete(mo) : _this.inventoryBinary.delete(mo);
            });
        };
        RepositoryService.prototype.delete = function (entity) {
            return this.inventory.delete(entity, { forceCascade: true });
        };
        RepositoryService.prototype.errorMsg = function () {
            var msg = ngxComponents.gettext('Failed to save');
            this.alert.danger(msg);
        };
        RepositoryService.prototype.getBaseVersionsCount$ = function (entry) {
            if (this.isLegacyEntry(entry)) {
                return rxjs.of(1);
            }
            return rxjs.from(this.listBaseVersions(entry, { pageSize: 1, withTotalPages: true })).pipe(operators.map(function (_b) {
                var paging = _b.paging;
                return paging.totalPages;
            }));
        };
        RepositoryService.prototype.getBaseVersionFromMO = function (mo) {
            return this.isPatch(mo) ? lodashEs.get(mo, 'c8y_Patch.dependency') : lodashEs.get(mo, 'c8y_Firmware.version');
        };
        RepositoryService.prototype.isPatch = function (mo) {
            return !!lodashEs.get(mo, 'c8y_Patch.dependency');
        };
        RepositoryService.prototype.getPatchVersionsCount$ = function (entry, baseVersion) {
            if (this.isLegacyEntry(baseVersion)) {
                return rxjs.of(0);
            }
            return rxjs.from(this.listPatchVersions(entry, baseVersion, { pageSize: 1, withTotalPages: true })).pipe(operators.map(function (_b) {
                var paging = _b.paging;
                return paging.totalPages;
            }));
        };
        RepositoryService.prototype.isLegacyEntry = function (entry) {
            return Boolean(entry.url);
        };
        /**
         * Lists all versions (base and patch ones) of given top level entry.
         * Versions are ordered by creation time (assuming the earlier created, the older the version).
         * @param entry Top level repository entry.
         * @param params Additional query params.
         */
        RepositoryService.prototype.listAllVersions = function (entry, params) {
            if (params === void 0) { params = {}; }
            if (this.isLegacyEntry(entry)) {
                return this.getBaseVersionResultListForLegacyEntry(entry);
            }
            var VERSION_FILTER_ORDER = {
                __filter: {},
                __orderby: [{ 'creationTime.date': -1 }, { creationTime: -1 }]
            };
            return this.listChildren(entry, VERSION_FILTER_ORDER, params);
        };
        /**
         * Lists base versions of given top level entry.
         * Versions are ordered by creation time (assuming the earlier created, the older the version).
         * @param entry Top level repository entry.
         * @param params Additional query params.
         */
        RepositoryService.prototype.listBaseVersions = function (entry, params) {
            if (params === void 0) { params = {}; }
            if (this.isLegacyEntry(entry)) {
                return this.getBaseVersionResultListForLegacyEntry(entry);
            }
            var NO_PATCH_FILTER_ORDER = {
                __filter: {
                    __not: { __has: 'c8y_Patch' }
                },
                __orderby: [{ 'creationTime.date': -1 }, { creationTime: -1 }]
            };
            return this.listChildren(entry, NO_PATCH_FILTER_ORDER, params);
        };
        /**
         * Lists patch versions of given base version under the entry.
         * Versions are ordered by creation time (assuming the earlier created, the older the version).
         * @param entry Top level repository entry.
         * @param baseVersion Base version.
         * @param params Additional query params.
         */
        RepositoryService.prototype.listPatchVersions = function (entry, baseVersion, params) {
            if (params === void 0) { params = {}; }
            var version = lodashEs.isString(baseVersion) ? baseVersion : lodashEs.get(baseVersion, 'c8y_Firmware.version');
            var PATCH_FILTER_ORDER = {
                __filter: {
                    'c8y_Patch.dependency': version
                },
                __orderby: [{ 'creationTime.date': -1 }, { creationTime: -1 }]
            };
            return this.listChildren(entry, PATCH_FILTER_ORDER, params);
        };
        /**
         * Lists patch versions of given base version under the entry including the base version.
         * Versions are ordered by creation time (assuming the earlier created, the older the version).
         * In terms of legacy base version the entry gets transformed to fit the needed data model.
         * @param entry Top level repository entry.
         * @param baseVersion Base version.
         * @param params Additional query params.
         */
        RepositoryService.prototype.listBaseVersionAndPatches = function (entry, baseVersion, params) {
            if (params === void 0) { params = {}; }
            if (this.isLegacyEntry(entry)) {
                return Promise.resolve({
                    data: [
                        Object.assign({
                            c8y_Firmware: {
                                version: entry.version,
                                url: entry.url
                            }
                        }, entry)
                    ]
                });
            }
            var PATCH_FILTER_ORDER = {
                __filter: {
                    __or: {
                        'c8y_Patch.dependency': baseVersion.c8y_Firmware.version,
                        'c8y_Firmware.version': baseVersion.c8y_Firmware.version
                    }
                },
                __orderby: [{ 'c8y_Patch.dependency': 1 }, { 'c8y_Firmware.version': 1 }]
            };
            return this.listChildren(entry, PATCH_FILTER_ORDER, params);
        };
        RepositoryService.prototype.listChildren = function (entry, filters, params) {
            if (filters === void 0) { filters = {}; }
            if (params === void 0) { params = {}; }
            var childrenFilters = { __bygroupid: entry.id };
            var query = this.queriesUtil.addAndFilter(filters, childrenFilters);
            // FIXME: needed because of issue in forOf directive (...)
            params.withTotalPages = true;
            return this.inventory.listQuery(query, params);
        };
        /**
         * Fetches all items from the list starting with the provided page.
         * @param firstPage The first page of the list to fetch all items for.
         */
        RepositoryService.prototype.fetchAllItemsFromList = function (firstPage) {
            return __awaiter(this, void 0, void 0, function () {
                var allItems, _b, paging, items;
                var _c;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0:
                            if (!!firstPage.then) return [3 /*break*/, 1];
                            allItems = __spreadArray([], __read(firstPage));
                            return [3 /*break*/, 5];
                        case 1: return [4 /*yield*/, firstPage];
                        case 2:
                            _b = _d.sent(), paging = _b.paging, items = _b.data;
                            allItems = __spreadArray([], __read(items));
                            _d.label = 3;
                        case 3:
                            if (!(paging && paging.nextPage)) return [3 /*break*/, 5];
                            return [4 /*yield*/, paging.next()];
                        case 4:
                            (_c = _d.sent(), paging = _c.paging, items = _c.data);
                            allItems = __spreadArray(__spreadArray([], __read(allItems)), __read(items));
                            return [3 /*break*/, 3];
                        case 5: return [2 /*return*/, allItems];
                    }
                });
            });
        };
        /**
         * Gets top level repository entry managed object for base or patch version.
         * @param mo Base or patch version managed object with parents.
         */
        RepositoryService.prototype.getRepositoryEntryMO$ = function (mo) {
            if (!mo) {
                return rxjs.of(undefined);
            }
            var _b = __read(lodashEs.get(mo, 'additionParents.references'), 1), reference = _b[0];
            var id = lodashEs.get(reference, 'managedObject.id');
            return id
                ? rxjs.from(this.inventory.detail(id, { withChildren: false })).pipe(operators.map(function (_b) {
                    var data = _b.data;
                    return data;
                }))
                : rxjs.of(undefined);
        };
        /**
         * Gets base or patch version managed object.
         * @param deviceRepositoryFragment Device repository fragment.
         * @param type Top level repository entry type.
         * @param configuration Configuration object with options:
         * - **skipLegacy** - `boolean` - Exclude legacy entries.
         * - **filters** - `object` - Filter object.
         *
         * @deprecated as it doesn't support 'missing url' case
         */
        RepositoryService.prototype.getRepositoryBinaryMoByVersion = function (deviceRepositoryFragment, type, _b) {
            var _c;
            var _d = _b === void 0 ? {} : _b, _e = _d.skipLegacy, skipLegacy = _e === void 0 ? false : _e, _f = _d.filters, filters = _f === void 0 ? {} : _f;
            var version = deviceRepositoryFragment.version, url = deviceRepositoryFragment.url, name = deviceRepositoryFragment.name;
            var repositoryBinaryType = REPOSITORY_BINARY_TYPES[type];
            var query;
            var newModelBaseVersionQuery = (_c = {},
                _c[type + ".version"] = version,
                _c[type + ".url"] = url,
                _c.type = repositoryBinaryType,
                _c);
            var legacyVersionQuery = { url: url, type: type, name: name };
            filters = Object.assign({ withChildren: false, withParents: true }, filters);
            if (skipLegacy) {
                query = {
                    __and: Object.assign({}, newModelBaseVersionQuery)
                };
            }
            else {
                query = {
                    __or: [{ __and: Object.assign({}, newModelBaseVersionQuery) }, { __and: Object.assign({}, legacyVersionQuery) }]
                };
            }
            return this.inventory.listQuery(query, filters).then(function (_b) {
                var data = _b.data;
                return lodashEs.head(data);
            });
        };
        RepositoryService.prototype.getBinaryName$ = function (binaryUrl) {
            var _this = this;
            if (!binaryUrl) {
                return rxjs.of('---');
            }
            var binaryId = this.inventoryBinary.getIdFromUrl(binaryUrl);
            if (!binaryId) {
                return rxjs.of(binaryUrl);
            }
            return rxjs.defer(function () { return _this.inventory.detail(binaryId).then(function (result) { return result.data; }); }).pipe(operators.map(function (mo) { return mo.name; }));
        };
        /**
         * Generates an inventory query object which can be used to find
         * repository entries of specified type matching the type of provided device.
         * @param repositoryType The type of repository entries which will be queried with the generated query.
         * @param device The device for which matching repository entries will be queried with the generated query.
         */
        RepositoryService.prototype.getDeviceTypeQuery = function (repositoryType, device) {
            var result = { type: repositoryType };
            if (repositoryType === exports.RepositoryType.CONFIGURATION) {
                if (device.type) {
                    result = this.queriesUtil.addAndFilter(result, {
                        __or: [{ deviceType: device.type }, { __not: { __has: "deviceType" } }]
                    });
                }
            }
            else {
                result = this.queriesUtil.addAndFilter(result, {
                    __or: [
                        { 'c8y_Filter.type': device.type },
                        { 'c8y_Filter.type': '' },
                        { __not: { __has: "c8y_Filter.type" } }
                    ]
                });
            }
            return result;
        };
        /**
         * Generates an inventory query object which can be used to find
         * repository entries matching the predefined software types provided in the device.
         * @param device The device for which matching repository entries will be queried with the generated query.
         * @param query The query to which the software types filters will be attached. Default value is an object containg repository type software.
         */
        RepositoryService.prototype.getSoftwareTypeQuery = function (device, query) {
            var result = Object.assign(Object.assign({}, (query || {})), { type: exports.RepositoryType.SOFTWARE });
            if (device.c8y_SupportedSoftwareTypes) {
                result = this.queriesUtil.addAndFilter(result, {
                    __or: [device.c8y_SupportedSoftwareTypes.map(function (type) { return ({ softwareType: type }); })]
                });
            }
            return result;
        };
        /**
         * Generates an inventory query object which can be used to find configuration repository entries
         * matching the type of provided device and specified configuration type.
         * @param device The device for which matching repository entries will be queried with the generated query.
         * @param configurationType Configuration type for which matching repository entries will be queried with the generated query.
         */
        RepositoryService.prototype.getConfigurationTypeQuery = function (device, configurationType) {
            var query = this.getDeviceTypeQuery(exports.RepositoryType.CONFIGURATION, device);
            return this.queriesUtil.addAndFilter(query, {
                __or: [
                    { configurationType: configurationType },
                    { configurationType: '' },
                    { __not: { __has: "configurationType" } }
                ]
            });
        };
        /**
         * Gets the list of software installed in the device in the uniform format.
         * Supports c8y_SoftwareList and c8y_Software fragments.
         * @param device The device whose software list should be returned.
         */
        RepositoryService.prototype.getDeviceSoftwareList = function (device) {
            if (device.c8y_SoftwareList) {
                return lodashEs.cloneDeep(device.c8y_SoftwareList);
            }
            if (device.c8y_Software) {
                return lodashEs.map(device.c8y_Software, function (version, name) { return ({ name: name, version: version }); });
            }
            return [];
        };
        /**
         * Prepares a software update operation for given device and the list of changes, and sends it to the device.
         * @param device The device which the operation should be prepared for and sent to.
         * @param changes The list of software changes which should be applied.
         */
        RepositoryService.prototype.createSoftwareUpdateOperation = function (device, changes) {
            return __awaiter(this, void 0, void 0, function () {
                var operation;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, this.getSoftwareUpdateOperation(device, changes)];
                        case 1:
                            operation = _b.sent();
                            return [4 /*yield*/, this.operation.create(operation)];
                        case 2: return [2 /*return*/, (_b.sent()).data];
                    }
                });
            });
        };
        /**
         * Prepares a software update operation for given device and changes.
         * Returned operation type depends on device's supported operations.
         * Supports c8y_SoftwareUpdate, c8y_SoftwareList, and c8y_Software operations.
         * @param device The device for which operation should be prepared.
         * @param changes The list of software changes which should be applied.
         */
        RepositoryService.prototype.getSoftwareUpdateOperation = function (device, changes) {
            return __awaiter(this, void 0, void 0, function () {
                var operation, _b, _c, _d, _e;
                return __generator(this, function (_f) {
                    switch (_f.label) {
                        case 0:
                            operation = {
                                deviceId: device.id,
                                description: "Apply software changes: " + changes
                                    .map(function (change) { return change.action + " \"" + change.name + "\"" + (change.version ? " (version: " + change.version + ")" : ''); })
                                    .join(', ')
                            };
                            if (!device.c8y_SupportedOperations.includes('c8y_SoftwareUpdate')) return [3 /*break*/, 1];
                            operation.c8y_SoftwareUpdate = (lodashEs.cloneDeep(changes) || []).map(function (change) { return lodashEs.omitBy(change, lodashEs.isNil); });
                            return [3 /*break*/, 5];
                        case 1:
                            if (!device.c8y_SupportedOperations.includes('c8y_SoftwareList')) return [3 /*break*/, 3];
                            _b = operation;
                            _c = lodashEs.cloneDeep;
                            return [4 /*yield*/, this.getCurrentSoftware(device, 'c8y_SoftwareList', [])];
                        case 2:
                            _b.c8y_SoftwareList = _c.apply(void 0, [_f.sent()]);
                            changes.forEach(function (change) {
                                var deviceSoftware = lodashEs.pick(lodashEs.omitBy(change, lodashEs.isNil), [
                                    'name',
                                    'version',
                                    'url',
                                    'softwareType'
                                ]);
                                if (change.action === 'delete') {
                                    lodashEs.remove(operation.c8y_SoftwareList, deviceSoftware);
                                }
                                if (change.action === 'install') {
                                    var softwareItemToUpdateIdx = operation.c8y_SoftwareList.findIndex(function (item) { return item.name === change.name; });
                                    if (softwareItemToUpdateIdx > -1) {
                                        // update software
                                        operation.c8y_SoftwareList.splice(softwareItemToUpdateIdx, 1, deviceSoftware);
                                    }
                                    else {
                                        // install software
                                        operation.c8y_SoftwareList.push(deviceSoftware);
                                    }
                                }
                            });
                            return [3 /*break*/, 5];
                        case 3:
                            if (!device.c8y_SupportedOperations.includes('c8y_Software')) return [3 /*break*/, 5];
                            _d = operation;
                            _e = lodashEs.cloneDeep;
                            return [4 /*yield*/, this.getCurrentSoftware(device, 'c8y_Software', {})];
                        case 4:
                            _d.c8y_Software = _e.apply(void 0, [_f.sent()]);
                            changes.forEach(function (change) {
                                if (change.action === 'delete') {
                                    delete operation.c8y_Software[change.name];
                                }
                                if (change.action === 'install') {
                                    operation.c8y_Software[change.name] = change.version;
                                }
                            });
                            _f.label = 5;
                        case 5: return [2 /*return*/, operation];
                    }
                });
            });
        };
        /**
         * Extracts the list of device software changes from given operation in the context of given device.
         * @param operation The operation from which the list should be extracted.
         * @param device The target device of the operation.
         */
        RepositoryService.prototype.getDeviceSoftwareChangesFromOperation = function (operation, device) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            if (operation.c8y_SoftwareUpdate) {
                                return [2 /*return*/, lodashEs.cloneDeep(operation.c8y_SoftwareUpdate)];
                            }
                            if (!operation.c8y_SoftwareList) return [3 /*break*/, 2];
                            return [4 /*yield*/, this.getDeviceSoftwareChangesFromSoftwareListOperation(operation, device)];
                        case 1: return [2 /*return*/, _b.sent()];
                        case 2:
                            if (!operation.c8y_Software) return [3 /*break*/, 4];
                            return [4 /*yield*/, this.getDeviceSoftwareChangesFromSoftwareOperation(operation, device)];
                        case 3: return [2 /*return*/, _b.sent()];
                        case 4: return [2 /*return*/, []];
                    }
                });
            });
        };
        /**
         * Prepares a firmware update operation for given device and the selected repository binary, and sends it to the device.
         * @param device The device which the operation should be prepared for and sent to.
         * @param selectedOption The selected repository binary option.
         */
        RepositoryService.prototype.createFirmwareUpdateOperation = function (device, selectedOption) {
            return __awaiter(this, void 0, void 0, function () {
                var operation;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            operation = this.getFirmwareUpdateOperation(device, selectedOption);
                            return [4 /*yield*/, this.operation.create(operation)];
                        case 1: return [2 /*return*/, (_b.sent()).data];
                    }
                });
            });
        };
        /**
         * Prepares a firmware update operation for given device and selected version.
         * Supports c8y_Firmware operation.
         * @param device The device for which operation should be prepared.
         * @param selectedOption Selected firmware version.
         */
        RepositoryService.prototype.getFirmwareUpdateOperation = function (device, selectedOption) {
            delete selectedOption.id;
            var operation = {
                deviceId: device.id,
                description: "Update firmware to: \"" + selectedOption.name + "\"" + (selectedOption.version ? " (version: " + selectedOption.version + ")" : ''),
                c8y_Firmware: Object.assign({}, selectedOption)
            };
            return operation;
        };
        /**
         * Prepares a configuration file upload operation for given device and configuration type.
         * @param device The device for which operation should be prepared.
         * @param configurationType Selected configuration type.
         * @param isLegacy  A legacy operation is created without a configurationType.
         */
        RepositoryService.prototype.getUploadConfigurationFileOperation = function (device, configurationType, isLegacy) {
            if (isLegacy === void 0) { isLegacy = false; }
            if (isLegacy) {
                return {
                    deviceId: device.id,
                    description: "Retrieve configuration snapshot from device " + device.name,
                    c8y_UploadConfigFile: {}
                };
            }
            return {
                deviceId: device.id,
                description: "Retrieve " + configurationType + " configuration snapshot from device " + device.name,
                c8y_UploadConfigFile: {
                    type: configurationType
                }
            };
        };
        /**
         * Prepares a configuration file download operation for given device and configuration type.
         * @param device The device for which operation should be prepared.
         * @param configurationType Selected configuration type.
         * @param binaryUrl The url of a binary to be downloaded.
         * @param isLegacy A legacy operation is created without a configurationType.
         */
        RepositoryService.prototype.getDownloadConfigurationFileOperation = function (device, configurationType, configSnapshot, isLegacy) {
            if (isLegacy === void 0) { isLegacy = false; }
            if (isLegacy) {
                return {
                    deviceId: device.id,
                    description: "Send configuration snapshot " + configSnapshot.name + " to device " + device.name,
                    c8y_DownloadConfigFile: {
                        url: configSnapshot.binaryUrl,
                        c8y_ConfigurationDump: {
                            id: configSnapshot.id
                        }
                    }
                };
            }
            return {
                deviceId: device.id,
                description: "Send configuration snapshot " + configSnapshot.name + " of configuration type " + configurationType + " to device " + device.name,
                c8y_DownloadConfigFile: {
                    url: configSnapshot.binaryUrl,
                    type: configurationType
                }
            };
        };
        /**
         * Gets the last firmware update operation for given device.
         * Looks for c8y_Firmware operations.
         * @param deviceId The ID of the device to find an operation for.
         */
        RepositoryService.prototype.getLastFirmwareUpdateOperation = function (deviceId) {
            return __awaiter(this, void 0, void 0, function () {
                var filters;
                return __generator(this, function (_b) {
                    filters = {
                        deviceId: deviceId,
                        dateFrom: new Date(0).toISOString(),
                        dateTo: new Date(Date.now()).toISOString(),
                        revert: true,
                        pageSize: 1
                    };
                    return [2 /*return*/, this.getFirstMatchingOperation([Object.assign(Object.assign({}, filters), { fragmentType: 'c8y_Firmware' })])];
                });
            });
        };
        /**
         * Gets the last software update operation for given device.
         * Looks for c8y_SoftwareUpdate, c8y_SoftwareList, or c8y_Software operations.
         * @param deviceId The ID of the device to find an operation for.
         */
        RepositoryService.prototype.getLastSoftwareUpdateOperation = function (deviceId) {
            return __awaiter(this, void 0, void 0, function () {
                var filters;
                return __generator(this, function (_b) {
                    filters = {
                        deviceId: deviceId,
                        dateFrom: new Date(0).toISOString(),
                        dateTo: new Date(Date.now()).toISOString(),
                        revert: true,
                        pageSize: 1
                    };
                    return [2 /*return*/, this.getLatestMatchingOperation([
                            Object.assign(Object.assign({}, filters), { fragmentType: 'c8y_SoftwareUpdate' }),
                            Object.assign(Object.assign({}, filters), { fragmentType: 'c8y_SoftwareList' }),
                            Object.assign(Object.assign({}, filters), { fragmentType: 'c8y_Software' })
                        ])];
                });
            });
        };
        /**
         * Iterates over the list of filters and queries the operations.
         * If a query returns at least one operation, the first one will be returned.
         * Otherwise the next query will be performed.
         * If none of the queries returns any operation, null will be returned.
         * @param filtersList The list of filters for the queries.
         */
        RepositoryService.prototype.getFirstMatchingOperation = function (filtersList) {
            return __awaiter(this, void 0, void 0, function () {
                var matchingOperation, filtersList_1, filtersList_1_1, filters, operations, e_1_1;
                var e_1, _b;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            matchingOperation = null;
                            _c.label = 1;
                        case 1:
                            _c.trys.push([1, 6, 7, 8]);
                            filtersList_1 = __values(filtersList), filtersList_1_1 = filtersList_1.next();
                            _c.label = 2;
                        case 2:
                            if (!!filtersList_1_1.done) return [3 /*break*/, 5];
                            filters = filtersList_1_1.value;
                            return [4 /*yield*/, this.operation.list(filters)];
                        case 3:
                            operations = (_c.sent()).data;
                            if (operations.length) {
                                matchingOperation = operations[0];
                                return [3 /*break*/, 5];
                            }
                            _c.label = 4;
                        case 4:
                            filtersList_1_1 = filtersList_1.next();
                            return [3 /*break*/, 2];
                        case 5: return [3 /*break*/, 8];
                        case 6:
                            e_1_1 = _c.sent();
                            e_1 = { error: e_1_1 };
                            return [3 /*break*/, 8];
                        case 7:
                            try {
                                if (filtersList_1_1 && !filtersList_1_1.done && (_b = filtersList_1.return)) _b.call(filtersList_1);
                            }
                            finally { if (e_1) throw e_1.error; }
                            return [7 /*endfinally*/];
                        case 8: return [2 /*return*/, matchingOperation];
                    }
                });
            });
        };
        /**
         * Iterates over the list of filters and queries the operations.
         * It compares the operations retrieved by the queries by 'creationTime'
         * and return the latest one.
         * If none of the queries returns any operation, null will be returned.
         * @param filtersList The list of filters for the queries.
         */
        RepositoryService.prototype.getLatestMatchingOperation = function (filtersList) {
            return __awaiter(this, void 0, void 0, function () {
                var matchingOperation, filtersList_2, filtersList_2_1, filters, operations, e_2_1;
                var e_2, _b;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            matchingOperation = null;
                            _c.label = 1;
                        case 1:
                            _c.trys.push([1, 6, 7, 8]);
                            filtersList_2 = __values(filtersList), filtersList_2_1 = filtersList_2.next();
                            _c.label = 2;
                        case 2:
                            if (!!filtersList_2_1.done) return [3 /*break*/, 5];
                            filters = filtersList_2_1.value;
                            return [4 /*yield*/, this.operation.list(filters)];
                        case 3:
                            operations = (_c.sent()).data;
                            if (operations.length) {
                                if (matchingOperation) {
                                    matchingOperation =
                                        new Date(matchingOperation.creationTime).getTime() <
                                            new Date(operations[0].creationTime).getTime()
                                            ? operations[0]
                                            : matchingOperation;
                                }
                                else {
                                    matchingOperation = operations[0];
                                }
                            }
                            _c.label = 4;
                        case 4:
                            filtersList_2_1 = filtersList_2.next();
                            return [3 /*break*/, 2];
                        case 5: return [3 /*break*/, 8];
                        case 6:
                            e_2_1 = _c.sent();
                            e_2 = { error: e_2_1 };
                            return [3 /*break*/, 8];
                        case 7:
                            try {
                                if (filtersList_2_1 && !filtersList_2_1.done && (_b = filtersList_2.return)) _b.call(filtersList_2);
                            }
                            finally { if (e_2) throw e_2.error; }
                            return [7 /*endfinally*/];
                        case 8: return [2 /*return*/, matchingOperation];
                    }
                });
            });
        };
        /**
         * Creates the operation and returns an observable to track its progress.
         * Fails the observable when the operation returns FAILED status.
         * Completes the observable when the operation returns SUCCESSFUL status.
         * @param operation The operation to create and track.
         */
        RepositoryService.prototype.createObservedOperation = function (operation) {
            var _this = this;
            return rxjs.from(this.operation.create(operation)).pipe(operators.map(function (_b) {
                var data = _b.data;
                return data;
            }), operators.take(1), operators.switchMap(function (createdOperation) { return _this.observeOperation(createdOperation); }));
        };
        /**
         * Returns an observable to track progress of given operation.
         * Fails the observable when the operation returns FAILED status.
         * Completes the observable when the operation returns SUCCESSFUL status.
         * @param operation The operation to be observed.
         */
        RepositoryService.prototype.observeOperation = function (operation) {
            var _this = this;
            var observedOperation$ = rxjs.of(operation);
            var operationUpdates$ = observedOperation$.pipe(operators.switchMap(function (observedOperation) { return _this.operationRealtime.onAll$(observedOperation.deviceId); }), operators.map(function (_b) {
                var data = _b.data;
                return data;
            }), operators.withLatestFrom(observedOperation$), operators.filter(function (_b) {
                var _c = __read(_b, 2), operationUpdate = _c[0], observedOperation = _c[1];
                return operationUpdate.id === observedOperation.id;
            }), operators.switchMap(function (_b) {
                var _c = __read(_b, 1), operationUpdate = _c[0];
                if (operationUpdate.status === client.OperationStatus.FAILED) {
                    return rxjs.throwError(operationUpdate);
                }
                return rxjs.of(operationUpdate);
            }), operators.takeWhile(function (operationUpdate) { return operationUpdate.status !== client.OperationStatus.SUCCESSFUL; }, true));
            return rxjs.merge(observedOperation$, operationUpdates$);
        };
        /**
         * Gets a single event with latest creationTime for the given device Id and event type.
         * @param deviceId The device Id for which the events should be queried.
         * @param type Event type.
         */
        RepositoryService.prototype.getLatestConfigurationEvent = function (deviceId, type) {
            return __awaiter(this, void 0, void 0, function () {
                var eventFilter, data;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            eventFilter = {
                                source: deviceId,
                                type: type,
                                dateFrom: this.dateFrom.toISOString(),
                                dateTo: this.dateTo.toISOString(),
                                pageSize: 1
                            };
                            return [4 /*yield*/, this.event.list(eventFilter)];
                        case 1:
                            data = (_b.sent()).data;
                            return [2 /*return*/, data[0]];
                    }
                });
            });
        };
        /**
         * Gets a list of operations for the given device Id, and operation type.
         * @param deviceId The device Id for which the operation should be queried.
         * @param operationType Operation type fragment.
         */
        RepositoryService.prototype.getConfigFileOperationList = function (deviceId, operationType) {
            return __awaiter(this, void 0, void 0, function () {
                var operationFilter;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            operationFilter = {
                                deviceId: deviceId,
                                fragmentType: operationType,
                                dateFrom: this.dateFrom.toISOString(),
                                dateTo: this.dateTo.toISOString(),
                                revert: true,
                                pageSize: 2000
                            };
                            return [4 /*yield*/, this.operation.list(operationFilter)];
                        case 1: return [2 /*return*/, (_b.sent()).data];
                    }
                });
            });
        };
        /**
         * Gets latest uploaded configuration snapshot for the given device, and configuration type.
         * @param device The device for which the configuration snapshot was uploaded.
         * @param configurationType Selected configuration type.
         */
        RepositoryService.prototype.getConfigSnapshot = function (device, configurationType) {
            return __awaiter(this, void 0, void 0, function () {
                var event, configSnapshot, _b, ex_1, msg;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0: return [4 /*yield*/, this.getLatestConfigurationEvent(device.id, configurationType)];
                        case 1:
                            event = _c.sent();
                            if (!event) return [3 /*break*/, 6];
                            configSnapshot = {
                                time: event.time,
                                name: event.text,
                                deviceType: device.type,
                                configurationType: configurationType
                            };
                            _c.label = 2;
                        case 2:
                            _c.trys.push([2, 5, , 6]);
                            _b = configSnapshot;
                            return [4 /*yield*/, this.eventBinary.download(event)];
                        case 3: return [4 /*yield*/, (_c.sent()).text()];
                        case 4:
                            _b.binary = _c.sent();
                            if (event.c8y_IsBinary) {
                                configSnapshot.binaryType = event.c8y_IsBinary.type;
                            }
                            return [3 /*break*/, 6];
                        case 5:
                            ex_1 = _c.sent();
                            msg = ngxComponents.gettext('Could not get the binary.');
                            this.alert.danger(msg);
                            return [3 /*break*/, 6];
                        case 6: return [2 /*return*/, configSnapshot];
                    }
                });
            });
        };
        RepositoryService.prototype.getLegacyConfigSnapshot = function (deviceId) {
            return __awaiter(this, void 0, void 0, function () {
                var configSnapshot, mo, device, snapshotId, ex_2, _b;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0: return [4 /*yield*/, this.inventory.detail(deviceId, { withChildren: false })];
                        case 1:
                            device = (_c.sent()).data;
                            snapshotId = device.c8y_ConfigurationDump && device.c8y_ConfigurationDump.id;
                            if (!snapshotId) {
                                return [2 /*return*/];
                            }
                            _c.label = 2;
                        case 2:
                            _c.trys.push([2, 4, , 5]);
                            return [4 /*yield*/, this.inventory.detail(snapshotId)];
                        case 3:
                            mo = (_c.sent()).data;
                            return [3 /*break*/, 5];
                        case 4:
                            ex_2 = _c.sent();
                            return [3 /*break*/, 5];
                        case 5:
                            if (!mo) return [3 /*break*/, 7];
                            configSnapshot = {
                                time: mo.creationTime,
                                name: mo.name
                            };
                            _b = configSnapshot;
                            return [4 /*yield*/, this.getBinaryText(mo.url, { allowExternal: false })];
                        case 6:
                            _b.binary = _c.sent();
                            _c.label = 7;
                        case 7: return [2 /*return*/, configSnapshot];
                    }
                });
            });
        };
        /**
         * Returns a binary object as text.
         * @param binaryUrl The URL to find binary
         * @param options The object with additional options:
         * - **allowExternal** - `boolean` - allows downloading external binary file
         * - **noAlerts** - `boolean` - do not display an alert message; defaults to `false`
         */
        RepositoryService.prototype.getBinaryText = function (binaryUrl, options) {
            return __awaiter(this, void 0, void 0, function () {
                var binaryId, res;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            binaryId = this.inventoryBinary.getIdFromUrl(binaryUrl);
                            if (!!binaryId) return [3 /*break*/, 3];
                            if (!options.allowExternal) return [3 /*break*/, 2];
                            return [4 /*yield*/, this.getExternalBinaryResponse(binaryUrl, options)];
                        case 1:
                            res = _b.sent();
                            _b.label = 2;
                        case 2: return [3 /*break*/, 5];
                        case 3: return [4 /*yield*/, this.getInternalBinaryResponse(binaryId, options)];
                        case 4:
                            res = _b.sent();
                            _b.label = 5;
                        case 5:
                            if (!res) {
                                return [2 /*return*/, null];
                            }
                            return [2 /*return*/, res.text()];
                    }
                });
            });
        };
        /**
         * Returns a binary object as File.
         * @param binaryUrl The URL to find binary
         * @param options The object with additional options:
         * - **allowExternal** - `boolean` - allows downloading external binary file
         */
        RepositoryService.prototype.getBinaryFile = function (binaryUrl, options) {
            return __awaiter(this, void 0, void 0, function () {
                var binaryId, _b, name, contentType, res, _c, arrayBuffer;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0:
                            binaryId = this.inventoryBinary.getIdFromUrl(binaryUrl);
                            if (!binaryId && !options.allowExternal) {
                                return [2 /*return*/, null];
                            }
                            return [4 /*yield*/, this.inventory.detail(binaryId)];
                        case 1:
                            _b = (_d.sent()).data, name = _b.name, contentType = _b.contentType;
                            if (!!!binaryId) return [3 /*break*/, 3];
                            return [4 /*yield*/, this.getInternalBinaryResponse(binaryId)];
                        case 2:
                            _c = _d.sent();
                            return [3 /*break*/, 5];
                        case 3: return [4 /*yield*/, this.getExternalBinaryResponse(binaryUrl)];
                        case 4:
                            _c = _d.sent();
                            _d.label = 5;
                        case 5:
                            res = _c;
                            return [4 /*yield*/, res.arrayBuffer()];
                        case 6:
                            arrayBuffer = _d.sent();
                            return [2 /*return*/, new File([arrayBuffer], name, { type: contentType })];
                    }
                });
            });
        };
        /**
         * Gets the last configuration update operation for given device.
         * Looks for c8y_Configuration and c8y_SendConfiguration operations.
         * @param deviceId The ID of the device to find an operation for.
         */
        RepositoryService.prototype.getLastConfigUpdateOperation = function (deviceId) {
            return __awaiter(this, void 0, void 0, function () {
                var filters;
                return __generator(this, function (_b) {
                    filters = {
                        deviceId: deviceId,
                        dateFrom: new Date(0).toISOString(),
                        dateTo: new Date(Date.now()).toISOString(),
                        revert: true,
                        pageSize: 1
                    };
                    return [2 /*return*/, this.getLatestMatchingOperation([
                            Object.assign(Object.assign({}, filters), { fragmentType: 'c8y_Configuration' }),
                            Object.assign(Object.assign({}, filters), { fragmentType: 'c8y_SendConfiguration' })
                        ])];
                });
            });
        };
        /**
         * Prepares a configuration download operation for given device and its current configuration.
         * Supports c8y_SendConfiguration operation.
         * @param device The device for which operation should be prepared.
         */
        RepositoryService.prototype.createTextBasedConfigurationReloadOperation = function (device) {
            return {
                deviceId: device.id,
                description: ngxComponents.gettext('Requested current configuration'),
                c8y_SendConfiguration: {}
            };
        };
        /**
         * Prepares a configuration update operation for the given device.
         * Supports c8y_Configuration operation.
         * @param device The device for which operation should be prepared.
         * @param config The configuration which will update the existing one.
         */
        RepositoryService.prototype.createTextBasedConfigurationUpdateOperation = function (device, config) {
            return {
                deviceId: device.id,
                description: ngxComponents.gettext('Configuration update'),
                c8y_Configuration: {
                    config: config
                }
            };
        };
        RepositoryService.prototype.getBinary = function (binaryId) {
            return __awaiter(this, void 0, void 0, function () {
                var ex_3, msg;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            _b.trys.push([0, 2, , 3]);
                            return [4 /*yield*/, this.inventoryBinary.download(binaryId)];
                        case 1: return [2 /*return*/, _b.sent()];
                        case 2:
                            ex_3 = _b.sent();
                            msg = ngxComponents.gettext('Could not get the binary.');
                            this.alert.danger(msg);
                            return [3 /*break*/, 3];
                        case 3: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Gets all available snapshots from the repository for the given device.
         * @param device The device for which the snapshots should be prepared.
         * @param configurationType Selected configuration type.
         */
        RepositoryService.prototype.getSnapshotsFromRepository = function (device, configurationType) {
            return __awaiter(this, void 0, void 0, function () {
                var searchQuery, res;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            searchQuery = this.getConfigurationTypeQuery(device, configurationType);
                            return [4 /*yield*/, this.listRepositoryEntries(exports.RepositoryType.CONFIGURATION, {
                                    query: searchQuery,
                                    params: { pageSize: 100 }
                                })];
                        case 1:
                            res = _b.sent();
                            return [2 /*return*/, res.data];
                    }
                });
            });
        };
        /**
         * Checks if a device already have a given software installed
         * @param deviceId Id of the device to be checked
         * @param software The software to be checked
         */
        RepositoryService.prototype.isSoftwareInstalledOnDevice = function (deviceId, software) {
            return __awaiter(this, void 0, void 0, function () {
                var queryFilter;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, this.advancedSoftwareService.isASMAvailable()];
                        case 1:
                            if (!(_b.sent())) {
                                return [2 /*return*/, false];
                            }
                            queryFilter = { deviceId: deviceId };
                            if (software === null || software === void 0 ? void 0 : software.name) {
                                lodashEs.set(queryFilter, 'name', software.name);
                            }
                            if (software === null || software === void 0 ? void 0 : software.version) {
                                lodashEs.set(queryFilter, 'version', software.version);
                            }
                            return [2 /*return*/, this.advancedSoftwareService.list(queryFilter).then(function (result) { var _a; return !!((_a = result.data) === null || _a === void 0 ? void 0 : _a.length); })];
                    }
                });
            });
        };
        /**
         * Returns a binary object.
         * @param binaryId binary ID
         * @param options The object with additional options:
         * - **noAlerts** - `boolean` - do not display an alert message; defaults to `false`
         */
        RepositoryService.prototype.getInternalBinaryResponse = function (binaryId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(this, void 0, void 0, function () {
                var res, ex_4, msg;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            _b.trys.push([0, 2, , 3]);
                            return [4 /*yield*/, this.inventoryBinary.download(binaryId)];
                        case 1:
                            res = _b.sent();
                            return [3 /*break*/, 3];
                        case 2:
                            ex_4 = _b.sent();
                            if (!options.noAlerts) {
                                msg = ngxComponents.gettext('Could not get the binary.');
                                this.alert.danger(msg);
                            }
                            return [3 /*break*/, 3];
                        case 3: return [2 /*return*/, res];
                    }
                });
            });
        };
        /**
         * Returns a binary object.
         * @param binaryUrl The URL to find binary
         * @param options The object with additional options:
         * - **noAlerts** - `boolean` - do not display an alert message; defaults to `false`
         */
        RepositoryService.prototype.getExternalBinaryResponse = function (binaryUrl, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(this, void 0, void 0, function () {
                var res, fetchRes, _a_1, msg;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            _b.trys.push([0, 2, , 3]);
                            return [4 /*yield*/, fetch(binaryUrl)];
                        case 1:
                            fetchRes = _b.sent();
                            if (fetchRes.status >= 400) {
                                throw res;
                            }
                            res = fetchRes;
                            return [3 /*break*/, 3];
                        case 2:
                            _a_1 = _b.sent();
                            if (!options.noAlerts) {
                                msg = ngxComponents.gettext('Could not get the external binary');
                                this.alert.danger(msg);
                            }
                            return [3 /*break*/, 3];
                        case 3: return [2 /*return*/, res];
                    }
                });
            });
        };
        RepositoryService.prototype.createEntry = function (mo) {
            return __awaiter(this, void 0, void 0, function () {
                var binaryId, newMo;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, this.inventoryBinary.getIdFromUrl(mo.url)];
                        case 1:
                            binaryId = _b.sent();
                            return [4 /*yield*/, this.inventory.create(mo)];
                        case 2:
                            newMo = _b.sent();
                            if (!binaryId) return [3 /*break*/, 4];
                            return [4 /*yield*/, this.inventory.childAdditionsAdd(binaryId, newMo.data)];
                        case 3:
                            _b.sent();
                            _b.label = 4;
                        case 4: return [2 /*return*/, newMo];
                    }
                });
            });
        };
        RepositoryService.prototype.updateEntry = function (mo, url) {
            return __awaiter(this, void 0, void 0, function () {
                var existingBinaryId, newBinaryId, id;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, this.inventoryBinary.getIdFromUrl(url)];
                        case 1:
                            existingBinaryId = _b.sent();
                            return [4 /*yield*/, this.inventoryBinary.getIdFromUrl(mo.url)];
                        case 2:
                            newBinaryId = _b.sent();
                            if (!(existingBinaryId && existingBinaryId !== newBinaryId)) return [3 /*break*/, 4];
                            id = this.inventoryBinary.getIdFromUrl(url);
                            return [4 /*yield*/, this.inventoryBinary.delete(id)];
                        case 3:
                            _b.sent();
                            _b.label = 4;
                        case 4:
                            if (!newBinaryId) return [3 /*break*/, 6];
                            return [4 /*yield*/, this.inventory.childAdditionsAdd(newBinaryId, mo)];
                        case 5:
                            _b.sent();
                            _b.label = 6;
                        case 6: return [2 /*return*/, this.inventory.update(mo)];
                    }
                });
            });
        };
        RepositoryService.prototype.getBaseVersionResultListForLegacyEntry = function (entry) {
            var _b;
            return Promise.resolve({
                res: {},
                data: [
                    Object.assign(Object.assign({}, entry), (_b = {}, _b[entry.type] = {
                        version: entry.version,
                        url: entry.url
                    }, _b))
                ]
            });
        };
        RepositoryService.prototype.getDeviceSoftwareChangesFromSoftwareListOperation = function (operation, device) {
            return __awaiter(this, void 0, void 0, function () {
                var changes, deviceSoftwareList;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            changes = [];
                            return [4 /*yield*/, this.getCurrentSoftware(device, 'c8y_SoftwareList', [])];
                        case 1:
                            deviceSoftwareList = _b.sent();
                            lodashEs.forEach(operation.c8y_SoftwareList, function (operationSoftware) {
                                var deviceSoftware = lodashEs.find(deviceSoftwareList, { name: operationSoftware.name });
                                if ((operationSoftware && operationSoftware.version) !==
                                    (deviceSoftware && deviceSoftware.version)) {
                                    changes.push(Object.assign(Object.assign({}, operationSoftware), { action: 'install' }));
                                }
                            });
                            lodashEs.forEach(deviceSoftwareList, function (deviceSoftware) {
                                var operationSoftware = lodashEs.find(operation.c8y_SoftwareList, { name: deviceSoftware.name });
                                if ((operationSoftware && operationSoftware.version) !==
                                    (deviceSoftware && deviceSoftware.version)) {
                                    var installChange = changes.find(function (change) { return deviceSoftware.name === change.name && change.action === 'install'; });
                                    // check that this software is not an installation software change, otherwise it's an update and not a removal
                                    if (!installChange) {
                                        changes.push(Object.assign(Object.assign({}, deviceSoftware), { action: 'delete' }));
                                    }
                                }
                            });
                            return [2 /*return*/, changes];
                    }
                });
            });
        };
        RepositoryService.prototype.getDeviceSoftwareChangesFromSoftwareOperation = function (operation, device) {
            return __awaiter(this, void 0, void 0, function () {
                var changes, deviceSoftware;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            changes = [];
                            return [4 /*yield*/, this.getCurrentSoftware(device, 'c8y_Software', {})];
                        case 1:
                            deviceSoftware = _b.sent();
                            lodashEs.forEach(deviceSoftware, function (deviceSoftwareVersion, deviceSoftwareName) {
                                if (operation.c8y_Software[deviceSoftwareName] !== deviceSoftwareVersion) {
                                    changes.push({
                                        name: deviceSoftwareName,
                                        version: deviceSoftwareVersion,
                                        action: 'delete'
                                    });
                                }
                            });
                            lodashEs.forEach(operation.c8y_Software, function (operationSoftwareVersion, operationSoftwareName) {
                                var deviceSoftwareVersion = deviceSoftware && deviceSoftware[operationSoftwareName];
                                if (deviceSoftwareVersion !== operationSoftwareVersion) {
                                    changes.push({
                                        name: operationSoftwareName,
                                        version: operationSoftwareVersion,
                                        action: 'install'
                                    });
                                }
                            });
                            return [2 /*return*/, changes];
                    }
                });
            });
        };
        RepositoryService.prototype.getCurrentSoftware = function (device, swFragment, defaultValue) {
            var _a;
            return __awaiter(this, void 0, void 0, function () {
                var isASMAvailable, softwareResultList, list;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, this.advancedSoftwareService.isASMAvailable()];
                        case 1:
                            isASMAvailable = _b.sent();
                            if (!isASMAvailable) return [3 /*break*/, 6];
                            return [4 /*yield*/, this.advancedSoftwareService.list({ deviceId: device.id, pageSize: 100 })];
                        case 2:
                            softwareResultList = _b.sent();
                            list = ((softwareResultList === null || softwareResultList === void 0 ? void 0 : softwareResultList.data) || []).map(function (sw) { return lodashEs.pick(lodashEs.omitBy(sw, lodashEs.isNil), ['name', 'version', 'url', 'softwareType']); });
                            _b.label = 3;
                        case 3:
                            if (!((_a = softwareResultList.paging) === null || _a === void 0 ? void 0 : _a.nextPage)) return [3 /*break*/, 5];
                            return [4 /*yield*/, softwareResultList.paging.next()];
                        case 4:
                            softwareResultList = _b.sent();
                            list = __spreadArray(__spreadArray([], __read(list)), __read(((softwareResultList === null || softwareResultList === void 0 ? void 0 : softwareResultList.data) || []).map(function (sw) { return lodashEs.pick(lodashEs.omitBy(sw, lodashEs.isNil), ['name', 'version', 'url', 'softwareType']); })));
                            return [3 /*break*/, 3];
                        case 5:
                            if (!(list === null || list === void 0 ? void 0 : list.length)) {
                                return [2 /*return*/, defaultValue];
                            }
                            return [2 /*return*/, Array.isArray(defaultValue) ? list : this.softwareListToLegacy(list)];
                        case 6: return [2 /*return*/, device[swFragment] || defaultValue];
                    }
                });
            });
        };
        RepositoryService.prototype.softwareListToLegacy = function (list) {
            return (list || []).reduce(function (prev, curr) {
                var _b;
                return (Object.assign(Object.assign({}, prev), (_b = {}, _b[curr.name] = curr.version, _b)));
            }, {});
        };
        return RepositoryService;
    }());
    RepositoryService.decorators = [
        { type: core.Injectable }
    ];
    RepositoryService.ctorParameters = function () { return [
        { type: client.InventoryService },
        { type: client.InventoryBinaryService },
        { type: client.OperationService },
        { type: ngxComponents.AlertService },
        { type: client.EventService },
        { type: ngxComponents.OperationRealtimeService },
        { type: client.EventBinaryService },
        { type: AdvancedSoftwareService }
    ]; };

    var LinkRenderType;
    (function (LinkRenderType) {
        LinkRenderType[LinkRenderType["DOWNLOAD"] = 0] = "DOWNLOAD";
        LinkRenderType[LinkRenderType["LINK"] = 1] = "LINK";
        LinkRenderType[LinkRenderType["TEXTONLY"] = 2] = "TEXTONLY";
    })(LinkRenderType || (LinkRenderType = {}));

    var FileDownloadComponent = /** @class */ (function () {
        function FileDownloadComponent(repositoryService, inventoryBinaryService, alertService) {
            this.repositoryService = repositoryService;
            this.inventoryBinaryService = inventoryBinaryService;
            this.alertService = alertService;
            this.linkRenderType = LinkRenderType;
            this.isDownloading = false;
        }
        FileDownloadComponent.prototype.getBinaryName$ = function (binaryUrl) {
            return this.repositoryService.getBinaryName$(binaryUrl);
        };
        FileDownloadComponent.prototype.determineBehavior = function () {
            var result;
            if (this.inventoryBinaryService.getIdFromUrl(this.url)) {
                result = LinkRenderType.DOWNLOAD;
            }
            else if (this.url.match(/\/\//g)) {
                result = LinkRenderType.LINK;
            }
            else {
                result = LinkRenderType.TEXTONLY;
            }
            return result;
        };
        FileDownloadComponent.prototype.downloadFile = function () {
            return __awaiter(this, void 0, void 0, function () {
                var binary, ex_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.trys.push([0, 2, , 3]);
                            this.isDownloading = true;
                            return [4 /*yield*/, this.repositoryService.getBinaryFile(this.url, {
                                    allowExternal: false
                                })];
                        case 1:
                            binary = _a.sent();
                            this.isDownloading = false;
                            fileSaver.saveAs(binary);
                            return [3 /*break*/, 3];
                        case 2:
                            ex_1 = _a.sent();
                            this.isDownloading = false;
                            if (ex_1) {
                                this.alertService.addServerFailure(ex_1);
                            }
                            return [3 /*break*/, 3];
                        case 3: return [2 /*return*/];
                    }
                });
            });
        };
        return FileDownloadComponent;
    }());
    FileDownloadComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'c8y-file-download',
                    template: "<a\n  *ngIf=\"determineBehavior() === linkRenderType.LINK\"\n  href=\"{{ url }}\"\n  class=\"pointer\"\n  target=\"_blank\"\n  rel=\"noopener noreferrer\"\n>\n  {{ getBinaryName$(url) | async }}\n</a>\n\n<span *ngIf=\"determineBehavior() === linkRenderType.TEXTONLY\">{{\n  getBinaryName$(url) | async\n}}</span>\n\n<span *ngIf=\"determineBehavior() === linkRenderType.DOWNLOAD\">\n  <a *ngIf=\"!isDownloading\" class=\"pointer\" (click)=\"downloadFile()\">\n    {{ getBinaryName$(url) | async }}\n  </a>\n\n  <span *ngIf=\"isDownloading\">\n    <i c8yIcon=\"spinner\" class=\"icon-spin\"></i> {{ 'Downloading\u2026' | translate }}\n  </span>\n</span>\n"
                },] }
    ];
    FileDownloadComponent.ctorParameters = function () { return [
        { type: RepositoryService },
        { type: client.InventoryBinaryService },
        { type: ngxComponents.AlertService }
    ]; };
    FileDownloadComponent.propDecorators = {
        url: [{ type: core.Input }]
    };
    __decorate([
        ngxComponents.memoize()
    ], FileDownloadComponent.prototype, "getBinaryName$", null);
    __decorate([
        ngxComponents.memoize()
    ], FileDownloadComponent.prototype, "determineBehavior", null);

    // MODAL STRUCTURE
    // - selectModalObject (repository entry (repositoryCategory) -> type c8y_Firmware/c8y_Software)
    //   -- ISelectModalOption (repository binary entry (repositoryBinary) => type c8y_FirmwareBinary/c8y_SoftwareBinary)
    //   -- ISelectModalOption...
    // - selectModalObject...
    /**
     * RepositorySelectModalComponent displays repository entries options and allows to select them.
     *
     * @example
     * ```
     * import { take } from 'rxjs/operators';
     * import { RepositorySelectModalComponent, ModalSelectionMode, RepositoryType } from '@c8y/ngx-components/repository/shared';
     *
     * const initialState = {
     *   repositoryType: RepositoryType.FIRMWARE,
     *   title: gettext('Install firmware'),
     *   subTitle: gettext('Available firmwares matching the device type'),
     *   icon: 'c8y-firmware',
     *   mode: ModalSelectionMode.SINGLE,
     *   labels: { ok: gettext('Install') },
     *   disableSelected: false
     * };
     *
     * const modal = this.bsModal.show(RepositorySelectModalComponent, {
     *   ignoreBackdropClick: true,
     *   initialState
     * });
     *
     * modal.content.load.next();
     * modal.content.resultEmitter.pipe(take(1)).subscribe((firmware) => {
     *   ...
     * })
     * ```
     */
    var RepositorySelectModalComponent = /** @class */ (function () {
        function RepositorySelectModalComponent(repositoryService, translateService) {
            var _this = this;
            this.repositoryService = repositoryService;
            this.translateService = translateService;
            /**
             * Optional
             * Allows to provide custom data.
             * @example
             * ```
             * import { from } from 'rxjs';
             *
             * const repositoryEntry = { name: 'ExampleEntry', type: 'c8y_Firmware' };
             * const versions = [{ c8y_Firmware: { version: '1.0.0', url: 'http://example.com' } }];
             *
             * const initialState = {repositoryEntriesWithVersions$: from({ ...repositoryEntry, versions })};
             * ```
             */
            this.repositoryEntriesWithVersions$ = undefined;
            /**
             * Optional
             * Allows to use custom badges templates.
             * @example
             * ```
             * import { gettext } from '@c8y/ngx-components';
             *
             * const badgeTemplates = { '=1': gettext('{{count}} version'), other: gettext('{{count}} versions') };
             * const initialState = { badgeTemplates };
             * ```
             */
            this.badgeTemplates = { '=1': ngxComponents.gettext('{{count}} version'), other: ngxComponents.gettext('{{count}} versions') };
            /**
             * Optional
             * Allows to provide custom modal title.
             */
            this.title = ngxComponents.gettext('Select repository entry');
            /**
             * Loads the content of the modal.
             * Must be invoked by the modal's caller.
             */
            this.load = new rxjs.Subject();
            /**
             * Triggers an update of the item list emitted.
             */
            this.updateInstallableList$ = new rxjs.Subject();
            /**
             * Optional
             * Emits a filter criteria object currently entered in the filter input.
             * Use it to filter the items if you use custom repositoryEntriesWithVersions$.
             */
            this.searchTerm = new rxjs.BehaviorSubject({});
            /**
             * Optional
             * Allows to provide device type query to restrict search criteria.
             * Only takes effect when repositoryEntriesWithVersions$ is not provided,
             * otherwise modal's caller have to provide already filtered data in the repositoryEntriesWithVersions$.
             */
            this.deviceTypeQuery = {};
            /**
             * Optional
             * Allows to provide query to restrict search criteria.
             * Only takes effect when repositoryEntriesWithVersions$ is not provided,
             * otherwise modal's caller have to provide already filtered data in the repositoryEntriesWithVersions$.
             */
            this.searchQuery = {};
            /**
             * Optional
             * Allows to provide custom labels for the buttons responsible for confirm/dismiss modal actions.
             */
            this.labels = { ok: ngxComponents.gettext('Save') };
            /**
             * Optional
             * Allows to hide the name filter input field.
             * By default, the filter input field is displayed.
             */
            this.showFilter = true;
            /**
             * Optional
             * Allows to show a warning that the search criteria should be narrowed down.
             * By default, this warning is hidden.
             */
            this.areMoreEntries = false;
            /**
             * Emits whenever a new repository binary have been selected in the modal.
             */
            this.onChoiceUpdated = new core.EventEmitter();
            /**
             * Emits the list of selected options.
             */
            this.resultEmitter = new core.EventEmitter();
            /**
             * Optional
             * Allows to change selection mode.
             * Supported options:
             *   * single: only single option can be selected.
             *   * multiple: multiple options can be selected.
             */
            this.mode = ngxComponents.ModalSelectionMode.SINGLE;
            /**
             * Allows to block selection of the other versions from the same repository entry.
             */
            this.disableSelected = true;
            this.filterCriteria = {};
            this.repositoryEntries$ = this.load.pipe(operators.switchMap(function () { return _this.repositoryEntriesWithVersions$; }), operators.mergeMap(function (mos) { return _this.aggregate(mos); }), operators.tap(function (items) {
                _this.areMoreEntries = items.length >= _this.PAGE_SIZE ? true : false;
            }), operators.tap(function (items) { return (_this.repositoryEntries = items); }));
            this.modalEntries = rxjs.merge(this.repositoryEntries$, this.updateInstallableList$.pipe(operators.map(function (updateItemEvent) {
                var itemToUpdate = (_this.repositoryEntries || []).find(function (item) { return item.groupId === updateItemEvent.object.groupId; });
                if (itemToUpdate) {
                    var optionToUpdate = (itemToUpdate.options || []).find(function (option) { return option.obj.id === updateItemEvent.object.selectedId; });
                    if (optionToUpdate) {
                        optionToUpdate.template = updateItemEvent.template;
                        if (updateItemEvent.mapper) {
                            optionToUpdate.obj = updateItemEvent.mapper(optionToUpdate.obj);
                        }
                    }
                }
                return _this.repositoryEntries;
            })));
            this.PAGE_SIZE = 100;
            this.queriesUtil = new client.QueriesUtil();
        }
        RepositorySelectModalComponent.prototype.ngOnInit = function () {
            var _this = this;
            if (!this.repositoryType) {
                throw new Error('Repository type must be defined');
            }
            if (!this.repositoryEntriesWithVersions$) {
                this.repositoryEntriesWithVersions$ = rxjs.of(1).pipe(operators.mergeMap(function () { return _this.repositoryService.listRepositoryEntries(_this.repositoryType, {
                    query: _this.queriesUtil.addAndFilter(_this.deviceTypeQuery, lodashEs.has(_this.searchQuery, 'name')
                        ? Object.assign(Object.assign({}, _this.searchQuery), { name: "*" + _this.searchQuery.name + "*" }) : _this.searchQuery),
                    params: { pageSize: _this.PAGE_SIZE }
                }); }), operators.map(function (_a) {
                    var data = _a.data;
                    return data;
                }), operators.map(function (mos) { return _this.getAndAssignRepositoryBinaries(mos); }));
            }
        };
        RepositorySelectModalComponent.prototype.getAndAssignRepositoryBinaries = function (mos) {
            var _this = this;
            mos.forEach(function (mo) {
                mo.versions = _this.repositoryService.listAllVersions(mo);
            });
            return mos;
        };
        RepositorySelectModalComponent.prototype.search = function (filterCriteria) {
            this.filterCriteria = lodashEs.omitBy(Object.assign(Object.assign({}, this.filterCriteria), filterCriteria), lodashEs.isEmpty);
            if (!lodashEs.isEqual(this.filterCriteria, this.searchQuery)) {
                this.searchTerm.next(this.filterCriteria);
                this.searchQuery = this.filterCriteria;
                this.load.next();
            }
        };
        RepositorySelectModalComponent.prototype.result = function (selectedItems) {
            this.resultEmitter.emit(selectedItems);
        };
        RepositorySelectModalComponent.prototype.aggregate = function (mos) {
            return __awaiter(this, void 0, void 0, function () {
                var repositoryType, selectedItems;
                var _this = this;
                return __generator(this, function (_a) {
                    repositoryType = this.repositoryType;
                    selectedItems = this.selected;
                    return [2 /*return*/, Promise.all(mos.map(function (repositoryEntry) { return __awaiter(_this, void 0, void 0, function () {
                            var options, _a, selectModalObject;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        _a = this.getSelectModalOptions;
                                        return [4 /*yield*/, this.repositoryService.fetchAllItemsFromList(repositoryEntry.versions)];
                                    case 1:
                                        options = _a.apply(this, [_b.sent(), selectedItems, repositoryEntry, repositoryType]);
                                        selectModalObject = this.getSelectModalObject(repositoryEntry, options);
                                        return [2 /*return*/, selectModalObject];
                                }
                            });
                        }); }))];
                });
            });
        };
        RepositorySelectModalComponent.prototype.getSelectModalOptions = function (versions, selectedItems, repositoryEntry, repositoryType) {
            var _this = this;
            var selectModalOptions = [];
            versions.forEach(function (repositoryBinary) {
                var isSelected = _this.isBinaryRepositorySelected(selectedItems, repositoryEntry, repositoryBinary, repositoryType);
                var version = repositoryBinary["" + repositoryType].version;
                var bodyValue = version || "(" + _this.translateService.instant(ngxComponents.gettext('not specified`version`')) + ")";
                var bodyClass = version ? '' : 'text-muted';
                selectModalOptions.push({
                    body: [
                        {
                            value: bodyValue,
                            class: bodyClass
                        }
                    ],
                    obj: Object.assign(Object.assign(Object.assign({ id: repositoryBinary.id, name: repositoryEntry.name, version: version }, (lodashEs.get(repositoryBinary, 'c8y_Patch.dependency') && {
                        dependency: lodashEs.get(repositoryBinary, 'c8y_Patch.dependency')
                    })), (lodashEs.get(repositoryBinary, 'c8y_Patch') && { isPatch: true })), { url: repositoryBinary["" + repositoryType].url, softwareType: repositoryEntry.softwareType }),
                    selected: isSelected
                });
            });
            return selectModalOptions;
        };
        RepositorySelectModalComponent.prototype.isBinaryRepositorySelected = function (selectedItems, repositoryEntry, repositoryBinary, repositoryType) {
            var isSelected = selectedItems
                ? selectedItems.filter(function (repositoryFragment) { return repositoryFragment.name === repositoryEntry.name &&
                    repositoryFragment.version === repositoryBinary["" + repositoryType].version; }).length > 0
                : false;
            return isSelected;
        };
        RepositorySelectModalComponent.prototype.getSelectModalObject = function (repositoryEntry, options) {
            var label = options.length === 1
                ? this.translateService.instant(this.badgeTemplates['=1'], { count: options.length })
                : this.translateService.instant(this.badgeTemplates.other, { count: options.length });
            var selectModalObject = {
                groupId: repositoryEntry.id,
                body: [
                    { value: repositoryEntry.name, class: 'text-truncate' },
                    { value: repositoryEntry.description, class: 'text-truncate text-muted' }
                ],
                additionalInformation: { value: label, class: 'label label-info' },
                options: options
            };
            return selectModalObject;
        };
        return RepositorySelectModalComponent;
    }());
    RepositorySelectModalComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'c8y-repository-select-modal',
                    template: "<c8y-select-modal\n  [icon]=\"icon\"\n  [title]=\"title\"\n  [subTitle]=\"subTitle\"\n  [items]=\"modalEntries | async\"\n  [mode]=\"mode\"\n  [disableSelected]=\"disableSelected\"\n  [labels]=\"labels\"\n  [showFilter]=\"showFilter\"\n  [additionalFilterTemplate]=\"additionalFilterTemplate\"\n  [areMoreEntries]=\"areMoreEntries\"\n  [noItemsMessage]=\"noItemsMessage\"\n  (search)=\"search({ name: $event })\"\n  (onChoiceUpdated)=\"onChoiceUpdated.emit($event)\"\n  (result)=\"result($event)\"\n>\n</c8y-select-modal>\n"
                },] }
    ];
    RepositorySelectModalComponent.ctorParameters = function () { return [
        { type: RepositoryService },
        { type: core$1.TranslateService }
    ]; };

    var SoftwareTypeComponent = /** @class */ (function () {
        function SoftwareTypeComponent(repositoryService, changeDetectorRef, translateService) {
            var _this = this;
            this.repositoryService = repositoryService;
            this.changeDetectorRef = changeDetectorRef;
            this.translateService = translateService;
            this.required = true;
            this.placeholder = this.translateService.instant(ngxComponents.gettext('e.g. {{ example }}'), {
                example: 'yum'
            });
            this.emitResultsOnly = false;
            this.showBtnInNotFoundMessage = true;
            this.allowFreeEntries = true;
            this.showClearSelectionOption = false;
            this.clearSelectionOptionLabel = ngxComponents.gettext('All software types');
            this.onSelectSoftware = new core.EventEmitter();
            this.filterPipe = rxjs.pipe(operators.tap());
            this.search$ = new rxjs.BehaviorSubject(null);
            this.queriesUtil = new client.QueriesUtil();
            this.softwareTypes = new Set();
            this.softwaresResult$ = this.search$.pipe(operators.debounceTime(300), operators.tap(function () { return _this.softwareTypes.clear(); }), operators.switchMap(function (searchString) {
                if (!_this.emitResultsOnly || !searchString) {
                    _this.onSelectSoftware.emit(_this.softwareTypeMO);
                }
                return _this.getSoftwareByTypeResult(searchString);
            }), operators.shareReplay(1));
            this.filterPipe = rxjs.pipe(operators.map(this.removeDuplicatesBySoftwareType.bind(this)));
        }
        SoftwareTypeComponent.prototype.ngOnInit = function () {
            this.notFoundTemplateToUse = this.showBtnInNotFoundMessage
                ? this.notFoundTypeAddNewTemplate
                : this.notFoundTypeTemplate;
        };
        SoftwareTypeComponent.prototype.getSoftwareByTypeResult = function (searchString) {
            var query = this.queriesUtil.prependOrderbys({}, [{ softwareType: 1 }]);
            var filter = !!searchString
                ? {
                    softwareType: {
                        __eq: "*" + searchString + "*"
                    }
                }
                : {
                    __has: 'softwareType'
                };
            query = this.queriesUtil.addAndFilter(query, filter);
            return this.repositoryService.listRepositoryEntries(exports.RepositoryType.SOFTWARE, {
                query: query,
                params: {
                    pageSize: 200
                }
            });
        };
        SoftwareTypeComponent.prototype.selectSoftware = function (software) {
            this.softwareTypeMO = software;
            this.onSelectSoftware.emit(software);
            this.deviceSoftwareTypeModel.searchControlModel.control.markAsDirty();
            this.deviceSoftwareTypeModel.onChange(software);
        };
        SoftwareTypeComponent.prototype.clearSoftware = function () {
            this.softwareTypeMO = undefined;
            this.search$.next('');
            this.onSelectSoftware.emit();
        };
        SoftwareTypeComponent.prototype.resetInput = function () {
            this.deviceSoftwareTypeModel.reset();
        };
        SoftwareTypeComponent.prototype.writeValue = function (value) {
            this.deviceSoftwareTypeModel.writeValue(value);
        };
        SoftwareTypeComponent.prototype.registerOnChange = function (fn) {
            this.deviceSoftwareTypeModel.registerOnChange(fn);
        };
        SoftwareTypeComponent.prototype.registerOnTouched = function (fn) {
            this.deviceSoftwareTypeModel.registerOnTouched(fn);
        };
        SoftwareTypeComponent.prototype.setDisabledState = function (isDisabled) {
            this.deviceSoftwareTypeModel.setDisabledState(isDisabled);
        };
        SoftwareTypeComponent.prototype.validate = function (control) {
            return this.deviceSoftwareTypeModel.validate(control);
        };
        SoftwareTypeComponent.prototype.removeDuplicatesBySoftwareType = function (list) {
            var _this = this;
            var uniqueBySoftwareType = lodashEs.uniqBy(list, 'softwareType').filter(function (sw) { return !_this.softwareTypes.has(sw.softwareType); });
            uniqueBySoftwareType.forEach(function (sw) { return _this.softwareTypes.add(sw.softwareType); });
            return uniqueBySoftwareType;
        };
        return SoftwareTypeComponent;
    }());
    SoftwareTypeComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'c8y-software-type',
                    template: "<c8y-typeahead\n  [(ngModel)]=\"softwareTypeMO\"\n  [required]=\"required\"\n  [disabled]=\"disabled\"\n  name=\"softwareType\"\n  [placeholder]=\"placeholder\"\n  [allowFreeEntries]=\"allowFreeEntries\"\n  #deviceSoftwareTypeModel\n  (onSearch)=\"search$.next($event)\"\n  displayProperty=\"softwareType\"\n  [ngStyle]=\"style\"\n>\n  <c8y-li\n    *ngIf=\"showClearSelectionOption\"\n    class=\"p-l-8 p-r-8 c8y-list__item--link\"\n    (click)=\"clearSoftware()\"\n    [active]=\"!softwareTypeMO?.softwareType\"\n  >\n    <span>{{ clearSelectionOptionLabel | translate }}</span>\n  </c8y-li>\n  <c8y-li\n    *c8yFor=\"\n      let software of softwaresResult$;\n      pipe: filterPipe;\n      loadMore: 'auto';\n      notFound: notFoundTemplateToUse\n    \"\n    class=\"p-l-8 p-r-8 c8y-list__item--link\"\n    (click)=\"selectSoftware(software)\"\n    [active]=\"softwareTypeMO?.softwareType === software.softwareType\"\n  >\n    <c8y-highlight\n      [text]=\"software.softwareType || '--'\"\n      [pattern]=\"search$ | async\"\n    ></c8y-highlight>\n  </c8y-li>\n  <ng-template #notFoundTypeAddNewTemplate>\n    <c8y-li class=\"bg-gray-lighter p-8\" *ngIf=\"(search$ | async)?.length > 0\">\n      <span translate>No match found.</span>\n      <button\n        title=\"{{ 'Add new`software type`' | translate }}\"\n        type=\"button\"\n        class=\"btn btn-primary btn-xs m-l-8\"\n        translate\n      >\n        Add new`software type`\n      </button>\n    </c8y-li>\n  </ng-template>\n  <ng-template #notFoundTypeTemplate>\n    <c8y-li\n      class=\"bg-gray-lighter p-8\"\n      *ngIf=\"(search$ | async)?.length > 0 && (softwaresResult$ | async)?.data?.length === 0\"\n    >\n      <span translate>No match found. Refine your search terms or check your spelling.</span>\n    </c8y-li>\n  </ng-template>\n</c8y-typeahead>\n",
                    providers: [
                        {
                            provide: forms.NG_VALUE_ACCESSOR,
                            multi: true,
                            useExisting: core.forwardRef(function () { return SoftwareTypeComponent; })
                        },
                        {
                            provide: forms.NG_VALIDATORS,
                            useExisting: core.forwardRef(function () { return SoftwareTypeComponent; }),
                            multi: true
                        }
                    ]
                },] }
    ];
    SoftwareTypeComponent.ctorParameters = function () { return [
        { type: RepositoryService },
        { type: core.ChangeDetectorRef },
        { type: core$1.TranslateService }
    ]; };
    SoftwareTypeComponent.propDecorators = {
        softwareTypeMO: [{ type: core.Input }],
        disabled: [{ type: core.Input }],
        style: [{ type: core.Input }],
        required: [{ type: core.Input }],
        placeholder: [{ type: core.Input }],
        emitResultsOnly: [{ type: core.Input }],
        showBtnInNotFoundMessage: [{ type: core.Input }],
        allowFreeEntries: [{ type: core.Input }],
        showClearSelectionOption: [{ type: core.Input }],
        clearSelectionOptionLabel: [{ type: core.Input }],
        deviceSoftwareTypeModel: [{ type: core.ViewChild, args: ['deviceSoftwareTypeModel', { static: true },] }],
        notFoundTypeAddNewTemplate: [{ type: core.ViewChild, args: ['notFoundTypeAddNewTemplate', { static: true },] }],
        notFoundTypeTemplate: [{ type: core.ViewChild, args: ['notFoundTypeTemplate', { static: true },] }],
        onSelectSoftware: [{ type: core.Output }]
    };

    var SharedRepositoryModule = /** @class */ (function () {
        function SharedRepositoryModule() {
        }
        return SharedRepositoryModule;
    }());
    SharedRepositoryModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [common.CommonModule, ngxComponents.CoreModule, ngxComponents.FormsModule, popover.PopoverModule],
                    declarations: [RepositorySelectModalComponent, FileDownloadComponent, SoftwareTypeComponent],
                    entryComponents: [RepositorySelectModalComponent],
                    providers: [AdvancedSoftwareService, RepositoryService, ngxComponents.OperationRealtimeService],
                    exports: [RepositorySelectModalComponent, FileDownloadComponent, SoftwareTypeComponent]
                },] }
    ];

    /**
     * Generated bundle index. Do not edit.
     */

    exports.AdvancedSoftwareService = AdvancedSoftwareService;
    exports.FileDownloadComponent = FileDownloadComponent;
    exports.REPOSITORY_BINARY_TYPES = REPOSITORY_BINARY_TYPES;
    exports.RepositorySelectModalComponent = RepositorySelectModalComponent;
    exports.RepositoryService = RepositoryService;
    exports.SharedRepositoryModule = SharedRepositoryModule;
    exports.SoftwareTypeComponent = SoftwareTypeComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=c8y-ngx-components-repository-shared.umd.js.map
