import { IIdentified, IMeasurement, MeasurementService } from '@c8y/client';
import { Observable } from 'rxjs';
import { RealtimeSubjectService } from './realtime-subject.service';
import { RealtimeService } from './realtime.service';
export declare class MeasurementRealtimeService extends RealtimeService<IMeasurement> {
    protected realtimeSubject: RealtimeSubjectService;
    protected measurementService: MeasurementService;
    constructor(realtimeSubject: RealtimeSubjectService, measurementService: MeasurementService);
    /**
     * Get an Observable of all measurements filtered by fragment and series.
     *
     * @param {string} fragment Measurement fragment
     *
     * @param {string} series Measurement series
     *
     * @param {string | number | IIdentified} entityOrId Entity object or id
     *
     * @returns An [[Observable]] of newly created entity objects.
     */
    onCreateOfSpecificMeasurement$(fragment: string, series: string, entityOrId?: string | number | IIdentified): Observable<IMeasurement>;
    /**
     * Get an Observable of all measurements filtered by fragment and series.
     * Combines the latest value from measurement API and future values via realtime API.
     *
     * @param {string} fragment Measurement fragment
     *
     * @param {string} series Measurement series
     *
     * @param {string | number | IIdentified} entityOrId Entity object or id
     *
     * @param {number} pageSize Number of measurements to initially retrieve from backend
     *
     * @param {boolean} emitNullIfInitialValuesWereNotFound Flag that if set to true will initially emit value of null in case no measurement could have been retrieved from backend
     *
     * @returns An [[Observable]] of newly created entity objects.
     */
    latestValueOfSpecificMeasurement$(fragment: string, series: string, entityOrId: string | number | IIdentified, pageSize?: number, emitNullIfInitialValuesWereNotFound?: boolean): Observable<IMeasurement>;
    protected lastMeasurement$(fragment: string, series: string, entityOrId: string | number | IIdentified, pageSize: number, emitNullIfInitialValuesWereNotFound?: boolean): Observable<IMeasurement>;
    protected channel(): string;
}
