"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApplicationService = void 0;
const core_1 = require("../core");
const inventory_1 = require("../inventory");
const tenant_1 = require("../tenant");
const user_1 = require("../user");
const ApplicationBinaryService_1 = require("./ApplicationBinaryService");
const ApplicationType_1 = require("./ApplicationType");
const gettext_1 = require("../gettext");
class ApplicationService extends core_1.Service {
    constructor() {
        super(...arguments);
        this.baseUrl = 'application';
        this.listUrl = 'applications';
        this.propertyName = 'applications';
        this.channel = '/applications/*';
    }
    /**
     * Creates a new application.
     *
     * @param {IIdentified} entity Application object.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * **Example**
     * ```typescript
     *
     *  const newApp = {
     *    name: 'New application',
     *    type: 'EXTERNAL',
     *    key: 'new-app'
     *  };
     *
     *  (async () => {
     *    const {data, res} = await applicationService.create(newApp);
     *  })();
     * ```
     */
    create(entity) {
        const _super = Object.create(null, {
            create: { get: () => super.create }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return _super.create.call(this, entity);
        });
    }
    clone(entity) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `${this.getDetailUrl(entity)}/clone`;
            const method = 'POST';
            const body = '';
            const headers = { 'content-type': 'application/json', accept: 'application/json' };
            const res = yield this.fetch(url, { method, body, headers });
            const data = yield res.json();
            return { res, data };
        });
    }
    /**
     * Gets the list of existing applications filtered by parameters.
     *
     * @returns Response wrapped in [[IResultList]]
     *
     * @param {object} filter Object containing filters for querying applications.
     *
     * **Example**
     * ```typescript
     *
     *  const filter: object = {
     *     pageSize: 100,
     *     withTotalPages: true
     *   };
     *
     *   (async () => {
     *     const {data, res, paging} = await applicationService.list(filter);
     *   })();
     * ```
     */
    list(filter = {}) {
        const _super = Object.create(null, {
            list: { get: () => super.list }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return _super.list.call(this, filter);
        });
    }
    /**
     * Gets the details of selected application.
     *
     * @param {string|number|IIdentified} entityOrId Entity or Id of the entity.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * **Example**
     * ```typescript
     *
     *    const applicationId: number = 1;
     *
     *    (async () => {
     *      const {data, res} = await applicationService.detail(applicationId);
     *   })();
     * ```
     */
    detail(entityOrId) {
        const _super = Object.create(null, {
            detail: { get: () => super.detail }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return _super.detail.call(this, entityOrId);
        });
    }
    /**
     * Updates existing application.
     * Make sure that you specifiy the application id within the update object.
     *
     * @param {IIdentified} entity Application object.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * **Example**
     * ```typescript
     *
     *  const updateApp = {
     *    id: 38
     *    name: 'Updated application'
     *  };
     *
     *  (async () => {
     *    const {data, res} = await applicationService.update(updateApp);
     *  })();
     * ```
     */
    update(entity) {
        const _super = Object.create(null, {
            update: { get: () => super.update }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return _super.update.call(this, entity);
        });
    }
    /**
     * Removes an application with given id.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @param {string | number | IIdentified} entityOrId entity or id of the application.
     *
     * **Example**
     * ```typescript
     *
     *  const removeApp: object = {
     *     id: 38
     *   };
     *
     *   (async () => {
     *     const {data, res} = await applicationService.delete(removeApp);
     *     // data will be null
     *   })();
     * ```
     */
    delete(entityOrId) {
        const _super = Object.create(null, {
            delete: { get: () => super.delete }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return _super.delete.call(this, entityOrId);
        });
    }
    listByName(name) {
        return __awaiter(this, void 0, void 0, function* () {
            const headers = { 'content-type': 'application/json' };
            const url = `applicationsByName/${encodeURIComponent(name)}`;
            const res = yield this.fetch(url, { headers });
            const json = yield res.json();
            const data = json[this.propertyName];
            return { res, data };
        });
    }
    listByTenant(tenantOrName, params = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const headers = { 'content-type': 'application/json' };
            const tenantService = new tenant_1.TenantService(this.client);
            const tenantName = this.getIdString(tenantOrName || (yield tenantService.current()).data.name);
            const url = `applicationsByTenant/${encodeURIComponent(tenantName)}`;
            const res = yield this.fetch(url, { headers, params });
            const json = yield res.json();
            const data = json[this.propertyName];
            return { res, data };
        });
    }
    listByOwner(tenantOrName, params = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const headers = { 'content-type': 'application/json' };
            const tenantService = new tenant_1.TenantService(this.client);
            const tenantName = this.getIdString(tenantOrName || (yield tenantService.current()).data.name);
            const url = `applicationsByOwner/${encodeURIComponent(tenantName)}`;
            const res = yield this.fetch(url, { headers, params });
            const json = yield res.json();
            const data = json[this.propertyName];
            return { res, data };
        });
    }
    listByUser(userOrId, params = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const headers = { 'content-type': 'application/json' };
            const userService = new user_1.UserService(this.client);
            const userId = this.getIdString(userOrId || (yield userService.current()).data);
            const url = `applicationsByUser/${encodeURIComponent(userId)}`;
            const res = yield this.fetch(url, { headers, params });
            const json = yield res.json();
            const data = json[this.propertyName];
            return { res, data };
        });
    }
    reactivateArchive(appId) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `${this.listUrl}/${appId}/refresh`;
            const method = 'POST';
            const body = '';
            const headers = { 'content-type': 'application/json', accept: 'application/json' };
            const res = yield this.fetch(url, { method, body, headers });
            return { res, data: null };
        });
    }
    binary(application) {
        return new ApplicationBinaryService_1.ApplicationBinaryService(this.client, application);
    }
    getHref(application) {
        if (application.type === ApplicationType_1.ApplicationType.EXTERNAL) {
            return application.externalUrl;
        }
        return `/apps/${application.public ? 'public/' : ''}${application.contextPath}`;
    }
    /**
     * Checks if current user can access specified application.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * @param {string | IApplication} application Application name or contextPath as a
     * string or Application object.
     *
     * **Example**
     * ```typescript
     *
     *  const checkApp: object = {
     *    name: 'myApplication'
     *  };
     *
     *  (async () => {
     *    const {data, res} = await applicationService.isAvailable(checkApp);
     *  })();
     * ```
     */
    isAvailable(application) {
        return __awaiter(this, void 0, void 0, function* () {
            const { res, data } = yield this.listByUser(undefined, {
                dropOverwrittenApps: true,
                noPaging: true
            });
            const available = (data || []).some((availableApp) => typeof application === 'string'
                ? availableApp.name === application || availableApp.contextPath === application
                : this.isMatch(availableApp, application));
            return { data: available, res };
        });
    }
    /**
     * Gets instance details of the specified application (microservice).
     *
     * @param {string|number|IApplication} entityOrId Entity or Id of the application.
     *
     * @returns Response wrapped in [[IResultList]]
     *
     * **Example**
     * ```typescript
     *
     *    const applicationId: number = 1;
     *
     *    (async () => {
     *      const {data, res} = await applicationService.getStatusDetails(applicationId);
     *   })();
     * ```
     */
    getStatusDetails(entityOrId) {
        return __awaiter(this, void 0, void 0, function* () {
            const appId = this.getEntityId(entityOrId);
            const inventory = new inventory_1.InventoryService(this.client, this.realtime);
            return inventory.list({ type: `c8y_Application_${appId}` });
        });
    }
    /**
     * Extracts instance names of the provided IApplicationManagedObject.
     *
     * @param {IApplicationManagedObject} appStatusDetails Application details managedObject.
     *
     * @returns instance names
     *
     * **Example**
     * ```typescript
     *
     *    const applicationId: number = 1;
     *
     *    (async () => {
     *      const {data, res} = await applicationService.getStatusDetails(applicationId);
     *      const instances = data.map((appMO) => applicationService.getInstanceNames(appMO));
     *   })();
     * ```
     */
    getInstanceNames(appStatusDetails) {
        let instanceNames = new Array();
        if (appStatusDetails && appStatusDetails.c8y_Status && appStatusDetails.c8y_Status.instances) {
            instanceNames = Object.keys(appStatusDetails.c8y_Status.instances);
        }
        return instanceNames;
    }
    /**
     * Get log for a specific application instance.
     *
     * @param {string|number|IApplication} entityOrId Entity or Id of the application.
     *
     * @param {string} instanceName instance name of the application.
     *
     * @param {IApplicationInstanceLogRequestParams} params Object containing parameters for querying the log file.
     *
     * @returns Response wrapped in [[IResult]]
     *
     * **Example**
     * ```typescript
     *
     *    const applicationId: number = 1;
     *    const applicationInstanceName: string = 'apama-ctrl-1c-4g-scope-t123456789-deployment-abcdefghij-abcde';
     *
     *    (async () => {
     *      const {data, res} = await applicationService.getInstanceLog(applicationId, applicationInstanceName);
     *   })();
     * ```
     */
    getInstanceLog(entityOrId, instanceName, params) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `${this.getDetailUrl(entityOrId)}/logs/${instanceName}`;
            const headers = { accept: this.mimeType('applicationLogs') };
            const res = yield this.fetch(url, { headers, params });
            const data = yield res.json();
            return { res, data };
        });
    }
    /**
     * Gets manifest (cumulocity.json file) of a given application.
     *
     * @param {IApplication} app Application entity.
     *
     * @returns Application manifest object.
     */
    getAppManifest(app) {
        return __awaiter(this, void 0, void 0, function* () {
            const date = new Date();
            const result = yield this.client.fetch(`/apps/${app.contextPath}/cumulocity.json?nocache=${date.getTime()}`);
            if (result.status >= 400) {
                throw new Error(gettext_1.gettext('No Cumulocity IoT manifest found.'));
            }
            const c8yJson = yield result.json();
            return c8yJson;
        });
    }
    /**
     * Updates manifest (cumulocity.json file) of a given application.
     *
     * @param {string|number|IApplication} entityOrId Entity or Id of the application.
     *
     * @param {any} manifestJSON Application manifest object to be stored.
     *
     * @returns Application manifest object.
     */
    storeAppManifest(entityOrId, manifestJSON) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.binary(entityOrId).updateFiles([
                { path: 'cumulocity.json', contents: JSON.stringify(manifestJSON) }
            ]);
        });
    }
    isMatch(object, source) {
        return Object.keys(source).every((key) => {
            if (Array.isArray(object[key]) && Array.isArray(source[key])) {
                return source[key].every((el) => object[key].includes(el));
            }
            else if (typeof object[key] === 'object' &&
                object[key] !== null &&
                typeof source[key] === 'object' &&
                source[key] !== null) {
                return this.isMatch(object[key], source[key]);
            }
            else {
                return object[key] === source[key];
            }
        });
    }
}
exports.ApplicationService = ApplicationService;
//# sourceMappingURL=ApplicationService.js.map